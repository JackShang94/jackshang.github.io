<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>5.2.2.红黑树 | Shang Liang Liang's Blog</title><meta name="description" content="红黑树1.1 定义红黑树是平衡二叉树的一种，它保证在最坏情况下基本动态集合操作的&#x3D;&#x3D;事件复杂度为O(log n)&#x3D;&#x3D;。时间复杂度证明：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;skywang12345&#x2F;p&#x2F;3245399.html (1) 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。 (2"><meta name="keywords" content="Data Structure"><meta name="author" content="Shang Liang Liang"><meta name="copyright" content="Shang Liang Liang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/logo.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="5.2.2.红黑树"><meta name="twitter:description" content="红黑树1.1 定义红黑树是平衡二叉树的一种，它保证在最坏情况下基本动态集合操作的&#x3D;&#x3D;事件复杂度为O(log n)&#x3D;&#x3D;。时间复杂度证明：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;skywang12345&#x2F;p&#x2F;3245399.html (1) 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。 (2"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gwkue98fd3j30mx0cmgmm.jpg"><meta property="og:type" content="article"><meta property="og:title" content="5.2.2.红黑树"><meta property="og:url" content="http://yoursite.com/2021/11/17/5.2.2.%E7%BA%A2%E9%BB%91%E6%A0%91/"><meta property="og:site_name" content="Shang Liang Liang's Blog"><meta property="og:description" content="红黑树1.1 定义红黑树是平衡二叉树的一种，它保证在最坏情况下基本动态集合操作的&#x3D;&#x3D;事件复杂度为O(log n)&#x3D;&#x3D;。时间复杂度证明：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;skywang12345&#x2F;p&#x2F;3245399.html (1) 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。 (2"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gwkue98fd3j30mx0cmgmm.jpg"><meta property="article:published_time" content="2021-11-17T14:32:39.000Z"><meta property="article:modified_time" content="2021-11-21T00:05:42.618Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://yoursite.com/2021/11/17/5.2.2.%E7%BA%A2%E9%BB%91%E6%A0%91/"><link rel="prev" title="5.2.3.最优二叉树--哈夫曼树" href="http://yoursite.com/2021/11/17/5.2.3.%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91--%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"><link rel="next" title="5.2.1.平衡二叉树(AVL)" href="http://yoursite.com/2021/11/17/5.2.1.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(AVL)/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?16c6948b730158e8efcea17a55c7ca6d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Shang Liang Liang","link":"链接: ","source":"来源: Shang Liang Liang's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: false,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Shang Liang Liang's Blog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">40</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#红黑树"><span class="toc-text">红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-定义"><span class="toc-text">1.1 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-特性"><span class="toc-text">1.2 特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-红黑树的基本操作"><span class="toc-text">1.3 红黑树的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-添加"><span class="toc-text">1.3.1 添加</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-1-情况说明：被插入的节点是根节点。"><span class="toc-text">1.3.1.1. 情况说明：被插入的节点是根节点。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-2-情况说明：被插入的节点的父节点是黑色。"><span class="toc-text">1.3.1.2. 情况说明：被插入的节点的父节点是黑色。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-3-情况说明：被插入的节点的父节点是红色。"><span class="toc-text">1.3.1.3.情况说明：被插入的节点的父节点是红色。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Case-1-叔叔是红色"><span class="toc-text">(Case 1)叔叔是红色</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Case1-1-现象说明"><span class="toc-text">Case1.1 现象说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Case1-2-处理策略"><span class="toc-text">Case1.2 处理策略</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Case1-3-示意图"><span class="toc-text">Case1.3 示意图</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Case-2-叔叔是黑色，且当前节点是右孩子"><span class="toc-text">(Case 2)叔叔是黑色，且当前节点是右孩子</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Case2-1-现象说明"><span class="toc-text">Case2.1 现象说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Case2-2-处理策略"><span class="toc-text">Case2.2 处理策略</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Case2-3-示意图"><span class="toc-text">Case2.3 示意图</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Case-3-叔叔是黑色，且当前节点是左孩子"><span class="toc-text">(Case 3)叔叔是黑色，且当前节点是左孩子</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Case3-1-现象说明"><span class="toc-text">Case3.1 现象说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Case3-2-处理策略"><span class="toc-text">Case3.2 处理策略</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Case3-3-示意图"><span class="toc-text">Case3.3 示意图</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-删除"><span class="toc-text">1.3.2 删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-1-情况说明：x是“红-黑”节点。"><span class="toc-text">1.3.2.1.情况说明：x是“红+黑”节点。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-2-情况说明：x是“黑-黑”节点，且x是根。"><span class="toc-text">1.3.2.2.情况说明：x是“黑+黑”节点，且x是根。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-3-情况说明：x是“黑-黑”节点，且x不是根。"><span class="toc-text">1.3.2.3.情况说明：x是“黑+黑”节点，且x不是根。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Case-1-x是”黑-黑”节点，x的兄弟节点是红色"><span class="toc-text">(Case 1)x是”黑+黑”节点，x的兄弟节点是红色</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Case1-1-现象说明-1"><span class="toc-text">Case1.1 现象说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Case1-2-处理策略-1"><span class="toc-text">Case1.2 处理策略</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Case1-3-示意图-1"><span class="toc-text">Case1.3 示意图</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Case-2-x是”黑-黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色"><span class="toc-text">(Case 2) x是”黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-现象说明"><span class="toc-text">2.1 现象说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-处理策略"><span class="toc-text">2.2 处理策略</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-示意图"><span class="toc-text">2.3 示意图</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Case-3-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的"><span class="toc-text">(Case 3)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-1-现象说明"><span class="toc-text">3.1 现象说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-2-处理策略"><span class="toc-text">3.2 处理策略</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-3-示意图"><span class="toc-text">3.3 示意图</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Case-4-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色"><span class="toc-text">(Case 4)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#4-1-现象说明"><span class="toc-text">4.1 现象说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-2-处理策略"><span class="toc-text">4.2 处理策略</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-3-示意图"><span class="toc-text">4.3 示意图</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div class="post-bg" id="nav" style="background-image: url(https://tva1.sinaimg.cn/large/008i3skNly1gwkue98fd3j30mx0cmgmm.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Shang Liang Liang's Blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">5.2.2.红黑树</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-11-17 22:32:39"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-11-17</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-11-21 08:05:42"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-11-21</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Data-Structure/">Data Structure</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">8.4k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 27 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>红黑树是平衡二叉树的一种，它保证在最坏情况下基本动态集合操作的==<strong>事件复杂度为O(log n)</strong>==。时间复杂度证明：<a href="https://www.cnblogs.com/skywang12345/p/3245399.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3245399.html</a></p>
<p>(1) 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入<strong>最多只需要三次旋转</strong>就能达到平衡，实现起来也更为简单。</p>
<p>(2) 平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。</p>
<p>红黑树和平衡二叉树区别如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlhlzai1oj315h0u043d.jpg" alt="image-20211120120927328"></p>
<h2 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2 特性"></a>1.2 特性</h2><p>==<strong>红黑树具有五个特性：</strong>==</p>
<ol>
<li>==<strong>每个结点要么是红的要么是黑的。</strong>==</li>
<li>==<strong>根结点是黑的。</strong>==</li>
<li>==<strong>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。</strong>==</li>
<li>==<strong>如果一个结点是红的，那么它的两个儿子都是黑的。</strong>==</li>
<li>==<strong>对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。</strong>==</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlhl6dzddj31i90u0q5x.jpg" alt="image-20211120120840570"></p>
<p>红黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只要求达到部分平衡。这是一种折中的方案，大大提高了结点删除和插入的效率。C++中的STL就常用到红黑树作为底层的数据结构。</p>
<p>红黑树应用：例如，Java集合中的<a href="http://www.cnblogs.com/skywang12345/p/3311268.html" target="_blank" rel="noopener">TreeSet</a>和<a href="http://www.cnblogs.com/skywang12345/p/3310928.html" target="_blank" rel="noopener">TreeMap</a>，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p>
<h2 id="1-3-红黑树的基本操作"><a href="#1-3-红黑树的基本操作" class="headerlink" title="1.3 红黑树的基本操作"></a>1.3 红黑树的基本操作</h2><h3 id="1-3-1-添加"><a href="#1-3-1-添加" class="headerlink" title="1.3.1 添加"></a>1.3.1 添加</h3><p>将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下：</p>
<p><strong>第一步: 将红黑树当作一颗二叉查找树，将节点插入。</strong><br>红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。<br>好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！</p>
<p><strong>第二步：将插入的节点着色为”红色”。</strong><br>为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：<br>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。<br>将插入的节点着色为红色，不会违背”特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。</p>
<p><strong>第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。</strong><br>第二步中，将插入节点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？<br>对于”特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。<br>对于”特性(2)”，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。<br>对于”特性(3)”，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。<br>对于”特性(4)”，是有可能违背的！<br>那接下来，想办法使之”满足特性(4)”，就可以将树重新构造成红黑树了。</p>
<ol>
<li><strong>添加操作的伪代码《算法导论》</strong></li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">RB-INSERT(T, z)  <br><span class="hljs-number">01</span>  y ← nil[T]                        <span class="hljs-comment">// 新建节点“y”，将y设为空节点。</span><br><span class="hljs-number">02</span>  x ← root[T]                       <span class="hljs-comment">// 设“红黑树T”的根节点为“x”</span><br><span class="hljs-number">03</span>  <span class="hljs-keyword">while</span> x ≠ nil[T]                  <span class="hljs-comment">// 找出要插入的节点“z”在二叉树T中的位置“y”</span><br><span class="hljs-number">04</span>      <span class="hljs-keyword">do</span> y ← x                      <br><span class="hljs-number">05</span>         <span class="hljs-keyword">if</span> key[z] &lt; key[x]  <br><span class="hljs-number">06</span>            then x ← left[x]  <br><span class="hljs-number">07</span>            <span class="hljs-keyword">else</span> x ← right[x]  <br><span class="hljs-number">08</span>  p[z] ← y                          <span class="hljs-comment">// 设置 “z的父亲” 为 “y”</span><br><span class="hljs-number">09</span>  <span class="hljs-keyword">if</span> y = nil[T]                     <br><span class="hljs-number">10</span>     then root[T] ← z               <span class="hljs-comment">// 情况1：若y是空节点，则将z设为根</span><br><span class="hljs-number">11</span>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> key[z] &lt; key[y]        <br><span class="hljs-number">12</span>             then left[y] ← z       <span class="hljs-comment">// 情况2：若“z所包含的值” &lt; “y所包含的值”，则将z设为“y的左孩子”</span><br><span class="hljs-number">13</span>             <span class="hljs-keyword">else</span> right[y] ← z      <span class="hljs-comment">// 情况3：(“z所包含的值” &gt;= “y所包含的值”)将z设为“y的右孩子” </span><br><span class="hljs-number">14</span>  left[z] ← nil[T]                  <span class="hljs-comment">// z的左孩子设为空</span><br><span class="hljs-number">15</span>  right[z] ← nil[T]                 <span class="hljs-comment">// z的右孩子设为空。至此，已经完成将“节点z插入到二叉树”中了。</span><br><span class="hljs-number">16</span>  color[z] ← RED                    <span class="hljs-comment">// 将z着色为“红色”</span><br><span class="hljs-number">17</span>  RB-INSERT-FIXUP(T, z)             <span class="hljs-comment">// 通过RB-INSERT-FIXUP对红黑树的节点进行颜色修改以及旋转，让树T仍然是一颗红黑树</span><br></code></pre></td></tr></table></figure>

<p>结合伪代码以及为代码上面的说明，先理解RB-INSERT。理解了RB-INSERT之后，我们接着对 RB-INSERT-FIXUP的伪代码进行说明。</p>
<ol start="2">
<li><strong>添加修正操作的伪代码《算法导论》</strong></li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">RB-INSERT-FIXUP(T, z)<br><span class="hljs-number">01</span> <span class="hljs-keyword">while</span> color[p[z]] = RED                                                  <span class="hljs-comment">// 若“当前节点(z)的父节点是红色”，则进行以下处理。</span><br><span class="hljs-number">02</span>     <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> p[z] = left[p[p[z]]]                                           <span class="hljs-comment">// 若“z的父节点”是“z的祖父节点的左孩子”，则进行以下处理。</span><br><span class="hljs-number">03</span>           then y ← right[p[p[z]]]                                        <span class="hljs-comment">// 将y设置为“z的叔叔节点(z的祖父节点的右孩子)”</span><br><span class="hljs-number">04</span>                <span class="hljs-keyword">if</span> color[y] = RED                                         <span class="hljs-comment">// Case 1条件：叔叔是红色</span><br><span class="hljs-number">05</span>                   then color[p[z]] ← BLACK                    ▹ Case <span class="hljs-number">1</span>   <span class="hljs-comment">//  (01) 将“父节点”设为黑色。</span><br><span class="hljs-number">06</span>                        color[y] ← BLACK                       ▹ Case <span class="hljs-number">1</span>   <span class="hljs-comment">//  (02) 将“叔叔节点”设为黑色。</span><br><span class="hljs-number">07</span>                        color[p[p[z]]] ← RED                   ▹ Case <span class="hljs-number">1</span>   <span class="hljs-comment">//  (03) 将“祖父节点”设为“红色”。</span><br><span class="hljs-number">08</span>                        z ← p[p[z]]                            ▹ Case <span class="hljs-number">1</span>   <span class="hljs-comment">//  (04) 将“祖父节点”设为“当前节点”(红色节点)</span><br><span class="hljs-number">09</span>                   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> z = right[p[z]]                                <span class="hljs-comment">// Case 2条件：叔叔是黑色，且当前节点是右孩子</span><br><span class="hljs-number">10</span>                           then z ← p[z]                       ▹ Case <span class="hljs-number">2</span>   <span class="hljs-comment">//  (01) 将“父节点”作为“新的当前节点”。</span><br><span class="hljs-number">11</span>                                LEFT-ROTATE(T, z)              ▹ Case <span class="hljs-number">2</span>   <span class="hljs-comment">//  (02) 以“新的当前节点”为支点进行左旋。</span><br><span class="hljs-number">12</span>                           color[p[z]] ← BLACK                 ▹ Case <span class="hljs-number">3</span>   <span class="hljs-comment">// Case 3条件：叔叔是黑色，且当前节点是左孩子。(01) 将“父节点”设为“黑色”。</span><br><span class="hljs-number">13</span>                           color[p[p[z]]] ← RED                ▹ Case <span class="hljs-number">3</span>   <span class="hljs-comment">//  (02) 将“祖父节点”设为“红色”。</span><br><span class="hljs-number">14</span>                           RIGHT-ROTATE(T, p[p[z]])            ▹ Case <span class="hljs-number">3</span>   <span class="hljs-comment">//  (03) 以“祖父节点”为支点进行右旋。</span><br><span class="hljs-number">15</span>        <span class="hljs-keyword">else</span> (same as then clause with <span class="hljs-string">"right"</span> <span class="hljs-keyword">and</span> <span class="hljs-string">"left"</span> exchanged)      <span class="hljs-comment">// 若“z的父节点”是“z的祖父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。</span><br><span class="hljs-number">16</span> color[root[T]] ← BLACK<br></code></pre></td></tr></table></figure>

<p>根据被插入节点的父节点的情况，可以将”当节点z被着色为红色节点，并插入二叉树”划分为三种情况来处理。</p>
<h4 id="1-3-1-1-情况说明：被插入的节点是根节点。"><a href="#1-3-1-1-情况说明：被插入的节点是根节点。" class="headerlink" title="1.3.1.1. 情况说明：被插入的节点是根节点。"></a>1.3.1.1. <strong>情况说明：被插入的节点是根节点。</strong></h4><p>  处理方法：直接把此节点涂为黑色。</p>
<h4 id="1-3-1-2-情况说明：被插入的节点的父节点是黑色。"><a href="#1-3-1-2-情况说明：被插入的节点的父节点是黑色。" class="headerlink" title="1.3.1.2. 情况说明：被插入的节点的父节点是黑色。"></a>1.3.1.2. <strong>情况说明：被插入的节点的父节点是黑色。</strong></h4><p>  处理方法：什么也不需要做。节点被插入后，仍然是红黑树。</p>
<h4 id="1-3-1-3-情况说明：被插入的节点的父节点是红色。"><a href="#1-3-1-3-情况说明：被插入的节点的父节点是红色。" class="headerlink" title="1.3.1.3.情况说明：被插入的节点的父节点是红色。"></a>1.3.1.3.<strong>情况说明：被插入的节点的父节点是红色。</strong></h4><p>  处理方法：那么，该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据”叔叔节点的情况”，将这种情况进一步划分为3种情况(Case)。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>现象说明</strong></th>
<th><strong>处理策略</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Case 1</td>
<td>当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</td>
<td>(01) 将“父节点”设为黑色。 (02) 将“叔叔节点”设为黑色。 (03) 将“祖父节点”设为“红色”。 (04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作, 即迭代。</td>
</tr>
<tr>
<td>Case 2</td>
<td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</td>
<td>(01) 将“父节点”作为“新的当前节点”。 (02) 以“新的当前节点”为支点进行左旋。</td>
</tr>
<tr>
<td>Case 3</td>
<td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</td>
<td>(01) 将“父节点”设为“黑色”。 (02) 将“祖父节点”设为“红色”。 (03) 以“祖父节点”为支点进行右旋。</td>
</tr>
</tbody></table>
<p>上面三种情况(Case)处理问题的核心思路都是：<strong>==将红色的节点移到根节点；然后，将根节点设为黑色==</strong>。下面对它们详细进行介绍。</p>
<h5 id="Case-1-叔叔是红色"><a href="#Case-1-叔叔是红色" class="headerlink" title="(Case 1)叔叔是红色"></a>(Case 1)叔叔是红色</h5><h6 id="Case1-1-现象说明"><a href="#Case1-1-现象说明" class="headerlink" title="Case1.1 现象说明"></a>Case<strong>1.1 现象说明</strong></h6><p>当前节点(即，被插入节点)的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。(插入35)</p>
<h6 id="Case1-2-处理策略"><a href="#Case1-2-处理策略" class="headerlink" title="Case1.2 处理策略"></a>Case<strong>1.2 处理策略</strong></h6><p>(01) 将“父节点”设为黑色。<br>(02) 将“叔叔节点”设为黑色。<br>(03) 将“祖父节点”设为“红色”。<br>(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</p>
<p>  <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>  “当前节点”和“父节点”都是红色，违背“特性(4)”。所以，将“父节点”设置“黑色”以解决这个问题。<br>  但是，将“父节点”由“红色”变成“黑色”之后，违背了“特性(5)”：因为，包含“父节点”的分支的黑色节点的总数增加了1。  解决这个问题的办法是：将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”。关于这里，说明几点：第一，为什么“祖父节点”之前是黑色？这个应该很容易想明白，因为在变换操作之前，该树是红黑树，“父节点”是红色，那么“祖父节点”一定是黑色。 第二，为什么将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；能解决“包含‘父节点’的分支的黑色节点的总数增加了1”的问题。这个道理也很简单。“包含‘父节点’的分支的黑色节点的总数增加了1” 同时也意味着 “包含‘祖父节点’的分支的黑色节点的总数增加了1”，既然这样，我们通过将“祖父节点”由“黑色”变成“红色”以解决“包含‘祖父节点’的分支的黑色节点的总数增加了1”的问题； 但是，这样处理之后又会引起另一个问题“包含‘叔叔’节点的分支的黑色节点的总数减少了1”，现在我们已知“叔叔节点”是“红色”，将“叔叔节点”设为“黑色”就能解决这个问题。 所以，将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；就解决了该问题。<br>  按照上面的步骤处理之后：当前节点、父节点、叔叔节点之间都不会违背红黑树特性，但祖父节点却不一定。若此时，祖父节点是根节点，直接将祖父节点设为“黑色”，那就完全解决这个问题了；若祖父节点不是根节点，那我们需要将“祖父节点”设为“新的当前节点”，接着对“新的当前节点”进行分析。</p>
<h6 id="Case1-3-示意图"><a href="#Case1-3-示意图" class="headerlink" title="Case1.3 示意图"></a>Case<strong>1.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251759273578917.jpg" target="_blank" rel="noopener"><strong><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljntndr2j318o0eitak.jpg" alt="img"></strong></a></p>
<h5 id="Case-2-叔叔是黑色，且当前节点是右孩子"><a href="#Case-2-叔叔是黑色，且当前节点是右孩子" class="headerlink" title="(Case 2)叔叔是黑色，且当前节点是右孩子"></a>(Case 2)叔叔是黑色，且当前节点是右孩子</h5><h6 id="Case2-1-现象说明"><a href="#Case2-1-现象说明" class="headerlink" title="Case2.1 现象说明"></a>Case<strong>2.1 现象说明</strong></h6><p>当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子。(插入70，图有错误)</p>
<h6 id="Case2-2-处理策略"><a href="#Case2-2-处理策略" class="headerlink" title="Case2.2 处理策略"></a>Case<strong>2.2 处理策略</strong></h6><p>(01) 将“父节点”作为“新的当前节点”。<br>(02) 以“新的当前节点”为支点进行左旋。</p>
<p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   首先，将“父节点”作为“新的当前节点”；接着，以“新的当前节点”为支点进行左旋。 为了便于理解，我们先说明第(02)步，再说明第(01)步；为了便于说明，我们设置“父节点”的代号为F(Father)，“当前节点”的代号为S(Son)。<br>为什么要“以F为支点进行左旋”呢？根据已知条件可知：S是F的右孩子。而之前我们说过，我们处理红黑树的核心思想：将红色的节点移到根节点；然后，将根节点设为黑色。既然是“将红色的节点移到根节点”，那就是说要不断的将破坏红黑树特性的红色节点上移(即向根方向移动)。 而S又是一个右孩子，因此，我们可以通过“左旋”来将S上移！<br>   按照上面的步骤(以F为支点进行左旋)处理之后：若S变成了根节点，那么直接将其设为“黑色”，就完全解决问题了；若S不是根节点，那我们需要执行步骤(01)，即“将F设为‘新的当前节点’”。那为什么不继续以S为新的当前节点继续处理，而需要以F为新的当前节点来进行处理呢？这是因为“左旋”之后，F变成了S的“子节点”，即S变成了F的父节点；而我们处理问题的时候，需要从下至上(由叶到根)方向进行处理；也就是说，必须先解决“孩子”的问题，再解决“父亲”的问题；所以，我们执行步骤(01)：将“父节点”作为“新的当前节点”。</p>
<h6 id="Case2-3-示意图"><a href="#Case2-3-示意图" class="headerlink" title="Case2.3 示意图"></a>Case<strong>2.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251801031546918.jpg" target="_blank" rel="noopener"><strong><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljo7qeefj31a90e30uk.jpg" alt="img"></strong></a></p>
<h5 id="Case-3-叔叔是黑色，且当前节点是左孩子"><a href="#Case-3-叔叔是黑色，且当前节点是左孩子" class="headerlink" title="(Case 3)叔叔是黑色，且当前节点是左孩子"></a>(Case 3)叔叔是黑色，且当前节点是左孩子</h5><h6 id="Case3-1-现象说明"><a href="#Case3-1-现象说明" class="headerlink" title="Case3.1 现象说明"></a><strong>Case3.1 现象说明</strong></h6><p>当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子。(插入40)</p>
<h6 id="Case3-2-处理策略"><a href="#Case3-2-处理策略" class="headerlink" title="Case3.2 处理策略"></a>Case<strong>3.2 处理策略</strong></h6><p>(01) 将“父节点”设为“黑色”。<br>(02) 将“祖父节点”设为“红色”。<br>(03) 以“祖父节点”为支点进行右旋。</p>
<p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“叔叔节点”为U(Uncle)，“父节点”为F(Father)，祖父节点为G(Grand-Father)。<br>   S和F都是红色，违背了红黑树的“特性(4)”，我们可以将F由“红色”变为“黑色”，就解决了“违背‘特性(4)’”的问题；但却引起了其它问题：违背特性(5)，因为将F由红色改为黑色之后，所有经过F的分支的黑色节点的个数增加了1。那我们如何解决“所有经过F的分支的黑色节点的个数增加了1”的问题呢？ 我们可以通过“将G由黑色变成红色”，同时“以G为支点进行右旋”来解决。</p>
<h6 id="Case3-3-示意图"><a href="#Case3-3-示意图" class="headerlink" title="Case3.3 示意图"></a>Case<strong>3.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201404/170945094945387.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljofpukej31a80e2dhp.jpg" alt="img"></a></p>
<p>提示：上面的进行Case 3处理之后，再将节点”120”当作当前节点，就变成了Case 2的情况。</p>
<h3 id="1-3-2-删除"><a href="#1-3-2-删除" class="headerlink" title="1.3.2 删除"></a>1.3.2 删除</h3><p>将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：</p>
<p><strong>第一步：将红黑树当作一颗二叉查找树，将节点删除。</strong><br>    这和”删除常规二叉查找树中删除节点的方法是一样的”。分3种情况：<br>    ① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。<br>    ② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。<br>    ③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了，下面就考虑后继节点。 在”被删除节点”有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然”的后继节点”不可能双子都非空，就意味着”该节点的后继节点”要么没有儿子，要么只有一个儿子。若没有儿子，则按”情况① “进行处理；若只有一个儿子，则按”情况② “进行处理。</p>
<p><strong>第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</strong><br>    因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p>
<p><strong>删除操作的伪代码《算法导论》</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">RB</span>-<span class="hljs-type">DELETE</span>(<span class="hljs-type">T</span>, z)<br><span class="hljs-number">01</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">left</span>[z] = <span class="hljs-literal">nil</span>[<span class="hljs-type">T</span>] or <span class="hljs-keyword">right</span>[z] = <span class="hljs-literal">nil</span>[<span class="hljs-type">T</span>]         <br><span class="hljs-number">02</span>    then y ← z                                  <span class="hljs-comment">// 若“z的左孩子” 或 “z的右孩子”为空，则将“z”赋值给 “y”；</span><br><span class="hljs-number">03</span>    <span class="hljs-keyword">else</span> y ← <span class="hljs-type">TREE</span>-<span class="hljs-type">SUCCESSOR</span>(z)                  <span class="hljs-comment">// 否则，将“z的后继节点”赋值给 “y”。</span><br><span class="hljs-number">04</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">left</span>[y] ≠ <span class="hljs-literal">nil</span>[<span class="hljs-type">T</span>]<br><span class="hljs-number">05</span>    then x ← <span class="hljs-keyword">left</span>[y]                            <span class="hljs-comment">// 若“y的左孩子” 不为空，则将“y的左孩子” 赋值给 “x”；</span><br><span class="hljs-number">06</span>    <span class="hljs-keyword">else</span> x ← <span class="hljs-keyword">right</span>[y]                           <span class="hljs-comment">// 否则，“y的右孩子” 赋值给 “x”。</span><br><span class="hljs-number">07</span> p[x] ← p[y]                                    <span class="hljs-comment">// 将“y的父节点” 设置为 “x的父节点”</span><br><span class="hljs-number">08</span> <span class="hljs-keyword">if</span> p[y] = <span class="hljs-literal">nil</span>[<span class="hljs-type">T</span>]                               <br><span class="hljs-number">09</span>    then root[<span class="hljs-type">T</span>] ← x                            <span class="hljs-comment">// 情况1：若“y的父节点” 为空，则设置“x” 为 “根节点”。</span><br><span class="hljs-number">10</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> y = <span class="hljs-keyword">left</span>[p[y]]                    <br><span class="hljs-number">11</span>            then <span class="hljs-keyword">left</span>[p[y]] ← x                 <span class="hljs-comment">// 情况2：若“y是它父节点的左孩子”，则设置“x” 为 “y的父节点的左孩子”</span><br><span class="hljs-number">12</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">right</span>[p[y]] ← x                <span class="hljs-comment">// 情况3：若“y是它父节点的右孩子”，则设置“x” 为 “y的父节点的右孩子”</span><br><span class="hljs-number">13</span> <span class="hljs-keyword">if</span> y ≠ z                                    <br><span class="hljs-number">14</span>    then key[z] ← key[y]                        <span class="hljs-comment">// 若“y的值” 赋值给 “z”。注意：这里只拷贝z的值给y，而没有拷贝z的颜色！！！</span><br><span class="hljs-number">15</span>         copy y's satellite data into z         <br><span class="hljs-number">16</span> <span class="hljs-keyword">if</span> color[y] = <span class="hljs-type">BLACK</span>                            <br><span class="hljs-number">17</span>    then <span class="hljs-type">RB</span>-<span class="hljs-type">DELETE</span>-<span class="hljs-type">FIXUP</span>(<span class="hljs-type">T</span>, x)                  <span class="hljs-comment">// 若“y为黑节点”，则调用</span><br><span class="hljs-number">18</span> <span class="hljs-keyword">return</span> y<br></code></pre></td></tr></table></figure>

<p>结合伪代码以及为代码上面的说明，先理解RB-DELETE。理解了RB-DELETE之后，接着对 RB-DELETE-FIXUP的伪代码进行说明</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">RB-DELETE-FIXUP(T, x)<br><span class="hljs-number">01</span> <span class="hljs-keyword">while</span> x ≠ root[T] <span class="hljs-keyword">and</span> color[x] = BLACK  <br><span class="hljs-number">02</span>     <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> x = left[p[x]]      <br><span class="hljs-number">03</span>           then w ← right[p[x]]                                             <span class="hljs-comment">// 若 “x”是“它父节点的左孩子”，则设置 “w”为“x的叔叔”(即x为它父节点的右孩子)                                          </span><br><span class="hljs-number">04</span>                <span class="hljs-keyword">if</span> color[w] = RED                                           <span class="hljs-comment">// Case 1: x是“黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</span><br><span class="hljs-number">05</span>                   then color[w] ← BLACK                        ▹  Case <span class="hljs-number">1</span>   <span class="hljs-comment">//   (01) 将x的兄弟节点设为“黑色”。</span><br><span class="hljs-number">06</span>                        color[p[x]] ← RED                       ▹  Case <span class="hljs-number">1</span>   <span class="hljs-comment">//   (02) 将x的父节点设为“红色”。</span><br><span class="hljs-number">07</span>                        LEFT-ROTATE(T, p[x])                    ▹  Case <span class="hljs-number">1</span>   <span class="hljs-comment">//   (03) 对x的父节点进行左旋。</span><br><span class="hljs-number">08</span>                        w ← right[p[x]]                         ▹  Case <span class="hljs-number">1</span>   <span class="hljs-comment">//   (04) 左旋后，重新设置x的兄弟节点。</span><br><span class="hljs-number">09</span>                <span class="hljs-keyword">if</span> color[left[w]] = BLACK <span class="hljs-keyword">and</span> color[right[w]] = BLACK       <span class="hljs-comment">// Case 2: x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</span><br><span class="hljs-number">10</span>                   then color[w] ← RED                          ▹  Case <span class="hljs-number">2</span>   <span class="hljs-comment">//   (01) 将x的兄弟节点设为“红色”。</span><br><span class="hljs-number">11</span>                        x ←  p[x]                               ▹  Case <span class="hljs-number">2</span>   <span class="hljs-comment">//   (02) 设置“x的父节点”为“新的x节点”。</span><br><span class="hljs-number">12</span>                   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> color[right[w]] = BLACK                          <span class="hljs-comment">// Case 3: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</span><br><span class="hljs-number">13</span>                           then color[left[w]] ← BLACK          ▹  Case <span class="hljs-number">3</span>   <span class="hljs-comment">//   (01) 将x兄弟节点的左孩子设为“黑色”。</span><br><span class="hljs-number">14</span>                                color[w] ← RED                  ▹  Case <span class="hljs-number">3</span>   <span class="hljs-comment">//   (02) 将x兄弟节点设为“红色”。</span><br><span class="hljs-number">15</span>                                RIGHT-ROTATE(T, w)              ▹  Case <span class="hljs-number">3</span>   <span class="hljs-comment">//   (03) 对x的兄弟节点进行右旋。</span><br><span class="hljs-number">16</span>                                w ← right[p[x]]                 ▹  Case <span class="hljs-number">3</span>   <span class="hljs-comment">//   (04) 右旋后，重新设置x的兄弟节点。</span><br><span class="hljs-number">17</span>                         color[w] ← color[p[x]]                 ▹  Case <span class="hljs-number">4</span>   <span class="hljs-comment">// Case 4: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的。(01) 将x父节点颜色 赋值给 x的兄弟节点。</span><br><span class="hljs-number">18</span>                         color[p[x]] ← BLACK                    ▹  Case <span class="hljs-number">4</span>   <span class="hljs-comment">//   (02) 将x父节点设为“黑色”。</span><br><span class="hljs-number">19</span>                         color[right[w]] ← BLACK                ▹  Case <span class="hljs-number">4</span>   <span class="hljs-comment">//   (03) 将x兄弟节点的右子节设为“黑色”。</span><br><span class="hljs-number">20</span>                         LEFT-ROTATE(T, p[x])                   ▹  Case <span class="hljs-number">4</span>   <span class="hljs-comment">//   (04) 对x的父节点进行左旋。</span><br><span class="hljs-number">21</span>                         x ← root[T]                            ▹  Case <span class="hljs-number">4</span>   <span class="hljs-comment">//   (05) 设置“x”为“根节点”。</span><br><span class="hljs-number">22</span>        <span class="hljs-keyword">else</span> (same as then clause with <span class="hljs-string">"right"</span> <span class="hljs-keyword">and</span> <span class="hljs-string">"left"</span> exchanged)        <span class="hljs-comment">// 若 “x”是“它父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。</span><br><span class="hljs-number">23</span> color[x] ← BLACK<br></code></pre></td></tr></table></figure>

<p>下面对删除函数进行分析。在分析之前，我们再次温习一下红黑树的几个特性：<br>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p>前面我们将”删除红黑树中的节点”大致分为两步，在第一步中”将红黑树当作一颗二叉查找树，将节点删除”后，可能违反”特性(2)、(4)、(5)”三个特性。第二步需要解决上面的三个问题，进而保持红黑树的全部特性。<br>为了便于分析，我们假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。为什么呢？<br>通过RB-DELETE算法，我们知道：删除节点y之后，x占据了原来节点y的位置。 既然删除y(y是黑色)，意味着减少一个黑色节点；那么，再在该位置上增加一个黑色即可。这样，当我们假设”x包含一个额外的黑色”，就正好弥补了”删除y所丢失的黑色节点”，也就不会违反”特性(5)”。 因此，假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。<br>现在，x不仅包含它原本的颜色属性，x还包含一个额外的黑色。即x的颜色属性是”红+黑”或”黑+黑”，它违反了”特性(1)”。</p>
<p>现在，我们面临的问题，由解决”违反了特性(2)、(4)、(5)三个特性”转换成了”解决违反特性(1)、(2)、(4)三个特性”。RB-DELETE-FIXUP需要做的就是通过算法恢复红黑树的特性(1)、(2)、(4)。RB-DELETE-FIXUP的思想是：将x所包含的额外的黑色不断沿树上移(向根方向移动)，直到出现下面的姿态：<br>a) x指向一个”红+黑”节点。此时，将x设为一个”黑”节点即可。<br>b) x指向根。此时，将x设为一个”黑”节点即可。<br>c) 非前面两种姿态。</p>
<p>将上面的姿态，可以概括为3种情况。</p>
<h4 id="1-3-2-1-情况说明：x是“红-黑”节点。"><a href="#1-3-2-1-情况说明：x是“红-黑”节点。" class="headerlink" title="1.3.2.1.情况说明：x是“红+黑”节点。"></a>1.3.2.1.情况说明：x是“红+黑”节点。</h4><p>  处理方法：直接把x设为黑色，结束。此时红黑树性质全部恢复。</p>
<h4 id="1-3-2-2-情况说明：x是“黑-黑”节点，且x是根。"><a href="#1-3-2-2-情况说明：x是“黑-黑”节点，且x是根。" class="headerlink" title="1.3.2.2.情况说明：x是“黑+黑”节点，且x是根。"></a>1.3.2.2.情况说明：x是“黑+黑”节点，且x是根。</h4><p>  处理方法：什么都不做，结束。此时红黑树性质全部恢复。</p>
<h4 id="1-3-2-3-情况说明：x是“黑-黑”节点，且x不是根。"><a href="#1-3-2-3-情况说明：x是“黑-黑”节点，且x不是根。" class="headerlink" title="1.3.2.3.情况说明：x是“黑+黑”节点，且x不是根。"></a>1.3.2.3.情况说明：x是“黑+黑”节点，且x不是根。</h4><p>  处理方法：这种情况又可以划分为4种子情况。这4种子情况如下表所示：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>现象说明</strong></th>
<th><strong>处理策略</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Case 1</strong></td>
<td>x是”黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</td>
<td>(01) 将x的兄弟节点设为“黑色”。 (02) 将x的父节点设为“红色”。 (03) 对x的父节点进行左旋。 (04) 左旋后，重新设置x的兄弟节点。</td>
</tr>
<tr>
<td><strong>Case 2</strong></td>
<td>x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</td>
<td>(01) 将x的兄弟节点设为“红色”。 (02) 设置“x的父节点”为“新的x节点”。</td>
</tr>
<tr>
<td><strong>Case 3</strong></td>
<td>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</td>
<td>(01) 将x兄弟节点的左孩子设为“黑色”。 (02) 将x兄弟节点设为“红色”。 (03) 对x的兄弟节点进行右旋。 (04) 右旋后，重新设置x的兄弟节点。</td>
</tr>
<tr>
<td><strong>Case 4</strong></td>
<td>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</td>
<td>(01) 将x父节点颜色 赋值给 x的兄弟节点。 (02) 将x父节点设为“黑色”。 (03) 将x兄弟节点的右子节设为“黑色”。 (04) 对x的父节点进行左旋。 (05) 设置“x”为“根节点”。</td>
</tr>
</tbody></table>
<h5 id="Case-1-x是”黑-黑”节点，x的兄弟节点是红色"><a href="#Case-1-x是”黑-黑”节点，x的兄弟节点是红色" class="headerlink" title="(Case 1)x是”黑+黑”节点，x的兄弟节点是红色"></a><strong>(Case 1)x是”黑+黑”节点，x的兄弟节点是红色</strong></h5><h6 id="Case1-1-现象说明-1"><a href="#Case1-1-现象说明-1" class="headerlink" title="Case1.1 现象说明"></a><strong>Case1.1 现象说明</strong></h6><p>x是”黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</p>
<h6 id="Case1-2-处理策略-1"><a href="#Case1-2-处理策略-1" class="headerlink" title="Case1.2 处理策略"></a><strong>Case1.2 处理策略</strong></h6><p>(01) 将x的兄弟节点设为“黑色”。<br>(02) 将x的父节点设为“红色”。<br>(03) 对x的父节点进行左旋。<br>(04) 左旋后，重新设置x的兄弟节点。</p>
<p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   这样做的目的是将“Case 1”转换为“Case 2”、“Case 3”或“Case 4”，从而进行进一步的处理。对x的父节点进行左旋；左旋后，为了保持红黑树特性，就需要在左旋前“将x的兄弟节点设为黑色”，同时“将x的父节点设为红色”；左旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p>
<h6 id="Case1-3-示意图-1"><a href="#Case1-3-示意图-1" class="headerlink" title="Case1.3 示意图"></a><strong>Case1.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251813539515702.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljurarvkj30wm08s3z7.jpg" alt="img"></a></p>
<h5 id="Case-2-x是”黑-黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色"><a href="#Case-2-x是”黑-黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色" class="headerlink" title="(Case 2) x是”黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色"></a><strong>(Case 2) x是”黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色</strong></h5><h6 id="2-1-现象说明"><a href="#2-1-现象说明" class="headerlink" title="2.1 现象说明"></a><strong>2.1 现象说明</strong></h6><p>x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</p>
<h6 id="2-2-处理策略"><a href="#2-2-处理策略" class="headerlink" title="2.2 处理策略"></a><strong>2.2 处理策略</strong></h6><p>(01) 将x的兄弟节点设为“红色”。<br>(02) 设置“x的父节点”为“新的x节点”。</p>
<p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   这个情况的处理思想：是将“x中多余的一个黑色属性上移(往根方向移动)”。 x是“黑+黑”节点，我们将x由“黑+黑”节点 变成 “黑”节点，多余的一个“黑”属性移到x的父节点中，即x的父节点多出了一个黑属性(若x的父节点原先是“黑”，则此时变成了“黑+黑”；若x的父节点原先时“红”，则此时变成了“红+黑”)。 此时，需要注意的是：所有经过x的分支中黑节点个数没变化；但是，所有经过x的兄弟节点的分支中黑色节点的个数增加了1(因为x的父节点多了一个黑色属性)！为了解决这个问题，我们需要将“所有经过x的兄弟节点的分支中黑色节点的个数减1”即可，那么就可以通过“将x的兄弟节点由黑色变成红色”来实现。<br>   经过上面的步骤(将x的兄弟节点设为红色)，多余的一个颜色属性(黑色)已经跑到x的父节点中。我们需要将x的父节点设为“新的x节点”进行处理。若“新的x节点”是“黑+红”，直接将“新的x节点”设为黑色，即可完全解决该问题；若“新的x节点”是“黑+黑”，则需要对“新的x节点”进行进一步处理。</p>
<h6 id="2-3-示意图"><a href="#2-3-示意图" class="headerlink" title="2.3 示意图"></a><strong>2.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251814572322069.jpg" target="_blank" rel="noopener"><strong><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljvz73cnj30wc08z3z9.jpg" alt="img"></strong></a></p>
<h5 id="Case-3-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的"><a href="#Case-3-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的" class="headerlink" title="(Case 3)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的"></a><strong>(Case 3)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的</strong></h5><h6 id="3-1-现象说明"><a href="#3-1-现象说明" class="headerlink" title="3.1 现象说明"></a><strong>3.1 现象说明</strong></h6><p>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</p>
<h6 id="3-2-处理策略"><a href="#3-2-处理策略" class="headerlink" title="3.2 处理策略"></a><strong>3.2 处理策略</strong></h6><p>(01) 将x兄弟节点的左孩子设为“黑色”。<br>(02) 将x兄弟节点设为“红色”。<br>(03) 对x的兄弟节点进行右旋。<br>(04) 右旋后，重新设置x的兄弟节点。</p>
<p>​    <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>​    我们处理“Case 3”的目的是为了将“Case 3”进行转换，转换成“Case 4”,从而进行进一步的处理。转换的方式是对x的兄弟节点进行右旋；为了保证右旋后，它仍然是红黑树，就需要在右旋前“将x的兄弟节点的左孩子设为黑色”，同时“将x的兄弟节点设为红色”；右旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p>
<h6 id="3-3-示意图"><a href="#3-3-示意图" class="headerlink" title="3.3 示意图"></a><strong>3.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251815496235531.jpg" target="_blank" rel="noopener"><strong><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljwiee5lj30y60ba3zb.jpg" alt="img"></strong></a></p>
<h5 id="Case-4-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色"><a href="#Case-4-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色" class="headerlink" title="(Case 4)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色"></a><strong>(Case 4)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色</strong></h5><h6 id="4-1-现象说明"><a href="#4-1-现象说明" class="headerlink" title="4.1 现象说明"></a><strong>4.1 现象说明</strong></h6><p>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</p>
<h6 id="4-2-处理策略"><a href="#4-2-处理策略" class="headerlink" title="4.2 处理策略"></a><strong>4.2 处理策略</strong></h6><p>(01) 将x父节点颜色 赋值给 x的兄弟节点。<br>(02) 将x父节点设为“黑色”。<br>(03) 将x兄弟节点的右子节设为“黑色”。<br>(04) 对x的父节点进行左旋。<br>(05) 设置“x”为“根节点”。</p>
<p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   我们处理“Case 4”的目的是：去掉x中额外的黑色，将x变成单独的黑色。处理的方式是“：进行颜色修改，然后对x的父节点进行左旋。下面，我们来分析是如何实现的。<br>   为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“兄弟节点的左孩子”为BLS(Brother’s Left Son)，“兄弟节点的右孩子”为BRS(Brother’s Right Son)，“父节点”为F(Father)。<br>   我们要对F进行左旋。但在左旋前，我们需要调换F和B的颜色，并设置BRS为黑色。为什么需要这里处理呢？因为左旋后，F和BLS是父子关系，而我们已知BL是红色，如果F是红色，则违背了“特性(4)”；为了解决这一问题，我们将“F设置为黑色”。 但是，F设置为黑色之后，为了保证满足“特性(5)”，即为了保证左旋之后：<br>   第一，“同时经过根节点和S的分支的黑色节点个数不变”。<br>       若满足“第一”，只需要S丢弃它多余的颜色即可。因为S的颜色是“黑+黑”，而左旋后“同时经过根节点和S的分支的黑色节点个数”增加了1；现在，只需将S由“黑+黑”变成单独的“黑”节点，即可满足“第一”。<br>   第二，“同时经过根节点和BLS的分支的黑色节点数不变”。<br>       若满足“第二”，只需要将“F的原始颜色”赋值给B即可。之前，我们已经将“F设置为黑色”(即，将B的颜色”黑色”，赋值给了F)。至此，我们算是调换了F和B的颜色。<br>   第三，“同时经过根节点和BRS的分支的黑色节点数不变”。<br>       在“第二”已经满足的情况下，若要满足“第三”，只需要将BRS设置为“黑色”即可。<br>经过，上面的处理之后。红黑树的特性全部得到的满足！接着，我们将x设为根节点，就可以跳出while循环(参考伪代码)；即完成了全部处理。</p>
<p>至此，我们就完成了Case 4的处理。理解Case 4的核心，是了解如何“去掉当前节点额外的黑色”。</p>
<h6 id="4-3-示意图"><a href="#4-3-示意图" class="headerlink" title="4.3 示意图"></a><strong>4.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251817189983393.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljxatt04j30v108z3z9.jpg" alt="img"></a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Shang Liang Liang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2021/11/17/5.2.2.%E7%BA%A2%E9%BB%91%E6%A0%91/">http://yoursite.com/2021/11/17/5.2.2.%E7%BA%A2%E9%BB%91%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">Shang Liang Liang's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Data-Structure/">Data Structure</a></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/008i3skNly1gwvtqvn6qgj30xc0iraac.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/11/17/5.2.3.%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91--%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"><img class="prev_cover" src="https://tva1.sinaimg.cn/large/008i3skNly1gwkue98fd3j30mx0cmgmm.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">5.2.3.最优二叉树--哈夫曼树</div></div></a></div><div class="next-post pull_right"><a href="/2021/11/17/5.2.1.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(AVL)/"><img class="next_cover" src="https://tva1.sinaimg.cn/large/008i3skNly1gwkue98fd3j30mx0cmgmm.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">5.2.1.平衡二叉树(AVL)</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/11/16/1.数据结构导读（升级版）/" title="1.数据结构导读升级版"><img class="relatedPosts_cover" src="https://tva1.sinaimg.cn/large/008i3skNly1gwkue98fd3j30mx0cmgmm.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-11-16</div><div class="relatedPosts_title">1.数据结构导读升级版</div></div></a></div><div class="relatedPosts_item"><a href="/2021/11/16/0.1.数据类型/" title="0.1.数据类型"><img class="relatedPosts_cover" src="https://tva1.sinaimg.cn/large/008i3skNly1gwkue98fd3j30mx0cmgmm.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-11-16</div><div class="relatedPosts_title">0.1.数据类型</div></div></a></div><div class="relatedPosts_item"><a href="/2021/11/16/2.1.时间复杂度(1) - 计算和比较/" title="2.1.时间复杂度(1) - 计算和比较"><img class="relatedPosts_cover" src="https://tva1.sinaimg.cn/large/008i3skNly1gwkue98fd3j30mx0cmgmm.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-11-16</div><div class="relatedPosts_title">2.1.时间复杂度(1) - 计算和比较</div></div></a></div><div class="relatedPosts_item"><a href="/2021/11/16/1.数据结构导读/" title="1.数据结构导读"><img class="relatedPosts_cover" src="https://tva1.sinaimg.cn/large/008i3skNly1gwkue98fd3j30mx0cmgmm.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-11-16</div><div class="relatedPosts_title">1.数据结构导读</div></div></a></div><div class="relatedPosts_item"><a href="/2021/11/16/2.2.时间复杂度(2) - 各数据结构时间复杂度和各数组排序算法时间复杂度/" title="2.2.时间复杂度(2) - 各数据结构时间复杂度和各数组排序算法时间复杂度"><img class="relatedPosts_cover" src="https://tva1.sinaimg.cn/large/008i3skNly1gwkue98fd3j30mx0cmgmm.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-11-16</div><div class="relatedPosts_title">2.2.时间复杂度(2) - 各数据结构时间复杂度和各数组排序算法时间复杂度</div></div></a></div><div class="relatedPosts_item"><a href="/2021/11/16/3.1.数组和链表(1)/" title="3.1.数组和链表(1)"><img class="relatedPosts_cover" src="https://tva1.sinaimg.cn/large/008i3skNly1gwkue98fd3j30mx0cmgmm.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-11-16</div><div class="relatedPosts_title">3.1.数组和链表(1)</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="disqus_thread"></div><script>var disqus_config = function () {
  this.page.url = 'http://yoursite.com/2021/11/17/5.2.2.%E7%BA%A2%E9%BB%91%E6%A0%91/';
  this.page.identifier = '2021/11/17/5.2.2.红黑树/';
  this.page.title = '5.2.2.红黑树';
};
(function() { 
  var d = document, s = d.createElement('script');
  s.src = 'https://jackshang.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();
</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Shang Liang Liang</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script><script>if (document.getElementsByClassName('mermaid').length) {
  loadScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js',function () {
    mermaid.initialize({
      theme: 'default',
  })
})
}</script></body></html>