<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MySQL | Shang Liang Liang's Blog</title><meta name="description" content="&#x3D;&#x3D;Q1:MySQL 的逻辑架构了解吗?&#x3D;&#x3D;第一层是服务器层，负责链接，授权，安全 第二层是核心服务层，负责查询解析，储存过程，触发器，视图。分析器，优化器，执行器。 第三层是存储引擎层，只负责数据提取。同层不通信，与上层通过API交流，不解析SQL Q2:谈一谈 MySQL 的读写锁读锁：共享锁。互不阻塞。 写锁：排它锁。阻塞其他读写锁。 写锁优先级比读锁高，可被插入在读锁队列前。读锁不能插入写"><meta name="keywords" content="MySQL"><meta name="author" content="Shang Liang Liang"><meta name="copyright" content="Shang Liang Liang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/logo.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="MySQL"><meta name="twitter:description" content="&#x3D;&#x3D;Q1:MySQL 的逻辑架构了解吗?&#x3D;&#x3D;第一层是服务器层，负责链接，授权，安全 第二层是核心服务层，负责查询解析，储存过程，触发器，视图。分析器，优化器，执行器。 第三层是存储引擎层，只负责数据提取。同层不通信，与上层通过API交流，不解析SQL Q2:谈一谈 MySQL 的读写锁读锁：共享锁。互不阻塞。 写锁：排它锁。阻塞其他读写锁。 写锁优先级比读锁高，可被插入在读锁队列前。读锁不能插入写"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gwvtpecmo8j30p00b4jrs.jpg"><meta property="og:type" content="article"><meta property="og:title" content="MySQL"><meta property="og:url" content="http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/MySQL/"><meta property="og:site_name" content="Shang Liang Liang's Blog"><meta property="og:description" content="&#x3D;&#x3D;Q1:MySQL 的逻辑架构了解吗?&#x3D;&#x3D;第一层是服务器层，负责链接，授权，安全 第二层是核心服务层，负责查询解析，储存过程，触发器，视图。分析器，优化器，执行器。 第三层是存储引擎层，只负责数据提取。同层不通信，与上层通过API交流，不解析SQL Q2:谈一谈 MySQL 的读写锁读锁：共享锁。互不阻塞。 写锁：排它锁。阻塞其他读写锁。 写锁优先级比读锁高，可被插入在读锁队列前。读锁不能插入写"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gwvtpecmo8j30p00b4jrs.jpg"><meta property="article:published_time" content="2021-11-29T02:40:39.000Z"><meta property="article:modified_time" content="2021-11-29T02:44:21.551Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/MySQL/"><link rel="prev" title="Redis" href="http://yoursite.com/2021/12/08/Java%E9%9D%A2%E8%AF%95/Redis/"><link rel="next" title="B树,B+树,B*树" href="http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/B%E6%A0%91,B+%E6%A0%91,B*%E6%A0%91/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?16c6948b730158e8efcea17a55c7ca6d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Shang Liang Liang","link":"链接: ","source":"来源: Shang Liang Liang's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"求知,好学","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: false,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Shang Liang Liang's Blog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">56</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Q1-MySQL-的逻辑架构了解吗"><span class="toc-text">&#x3D;&#x3D;Q1:MySQL 的逻辑架构了解吗?&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q2-谈一谈-MySQL-的读写锁"><span class="toc-text">Q2:谈一谈 MySQL 的读写锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q3-MySQL-的锁策略有什么"><span class="toc-text">&#x3D;&#x3D;Q3:MySQL 的锁策略有什么?&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q4-数据库死锁如何解决"><span class="toc-text">Q4:数据库死锁如何解决?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q5-事务是什么"><span class="toc-text">Q5:事务是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q6-事务有什么特性"><span class="toc-text">&#x3D;&#x3D;Q6:事务有什么特性?&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q7-MySQL-的隔离级别有哪些"><span class="toc-text">&#x3D;&#x3D;Q7:MySQL 的隔离级别有哪些?&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q8-MVCC-是什么"><span class="toc-text">&#x3D;&#x3D;Q8:MVCC 是什么?&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-9-谈一谈-InnoDB"><span class="toc-text">Q&#x3D;&#x3D;9:谈一谈 InnoDB&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q10-谈一谈-MyISAM"><span class="toc-text">Q10:谈一谈 MyISAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q11-谈一谈-Memory"><span class="toc-text">Q11:谈一谈 Memory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q12-查询执行流程是什么"><span class="toc-text">Q12:查询执行流程是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q13-VARCHAR-和-CHAR-的区别"><span class="toc-text">Q13:VARCHAR 和 CHAR 的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q14-DATETIME-和-TIMESTAMP-的区别"><span class="toc-text">Q14:DATETIME 和 TIMESTAMP 的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q15-数据类型有哪些优化策略"><span class="toc-text">Q15:数据类型有哪些优化策略?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q16-索引有什么作用"><span class="toc-text">&#x3D;&#x3D;Q16:索引有什么作用?&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q16-1索引的分类"><span class="toc-text">Q16.1索引的分类?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q17-谈一谈-MySQL-的-B-Tree-索引"><span class="toc-text">&#x3D;&#x3D;Q17:谈一谈 MySQL 的 B-Tree 索引&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q18-了解-Hash-索引吗"><span class="toc-text">Q18:了解 Hash 索引吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q19-什么是自适应哈希索引"><span class="toc-text">&#x3D;&#x3D;Q19:什么是自适应哈希索引?&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q20-什么是空间索引"><span class="toc-text">Q20 :什么是空间索引?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q21-什么是全文索引"><span class="toc-text">&#x3D;&#x3D;Q21:什么是全文索引?&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q22-什么是聚簇索引"><span class="toc-text">Q22:什么是聚簇索引?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q23-什么是覆盖索引"><span class="toc-text">Q23:什么是覆盖索引?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q24-你知道哪些索引使用原则-（索引调优）"><span class="toc-text">Q24:你知道哪些索引使用原则?（索引调优）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q25-索引失效的情况有哪些"><span class="toc-text">&#x3D;&#x3D;Q25:索引失效的情况有哪些?&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q26-如何定位低效-SQL"><span class="toc-text">Q26:如何定位低效 SQL?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q26-1-MySQL-问题排查都有哪些⼿手段"><span class="toc-text">&#x3D;&#x3D;Q26.1:MySQL 问题排查都有哪些⼿手段?&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q27-SHOW-PROFILE-的作用"><span class="toc-text">Q27:SHOW PROFILE 的作用?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q28-Trace-是干什么的"><span class="toc-text">Q28:Trace 是干什么的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q29-EXPLAIN-的字段有哪些，具有什么含义"><span class="toc-text">Q29:EXPLAIN 的字段有哪些，具有什么含义?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q30-有哪些优化-SQL-的策略"><span class="toc-text">&#x3D;&#x3D;Q30:有哪些优化 SQL 的策略?&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q31-MySQL-主从复制的作用"><span class="toc-text">&#x3D;&#x3D;Q31:MySQL 主从复制的作用?&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q32-MySQL-主从复制的步骤"><span class="toc-text">&#x3D;&#x3D;Q32:MySQL 主从复制的步骤?&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q32-1主从复制中涉及到哪三个线程"><span class="toc-text">&#x3D;&#x3D;Q32.1主从复制中涉及到哪三个线程?&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q33-数据库的常用范式："><span class="toc-text">Q33:数据库的常用范式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q34-Innodb存储引擎的执行过程："><span class="toc-text">Q34.Innodb存储引擎的执行过程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q35-读写分离"><span class="toc-text">&#x3D;&#x3D;Q35.读写分离&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q36-主键一般用自增ID还是UUID？"><span class="toc-text">Q36.主键一般用自增ID还是UUID？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q37-视图View："><span class="toc-text">Q37.视图View：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q38-触发器Trigger"><span class="toc-text">Q38.触发器Trigger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q39-游标Cursor"><span class="toc-text">Q39.游标Cursor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q40-最左前缀"><span class="toc-text">Q40.最左前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q41-谈谈你对水平切分和垂直切分的理理解"><span class="toc-text">Q41.谈谈你对水平切分和垂直切分的理理解?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q42-数据库并发策略"><span class="toc-text">&#x3D;&#x3D;Q42.数据库并发策略&#x3D;&#x3D;</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div class="post-bg" id="nav" style="background-image: url(https://tva1.sinaimg.cn/large/008i3skNly1gwvtpecmo8j30p00b4jrs.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Shang Liang Liang's Blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">MySQL</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-11-29 10:40:39"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-11-29</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-11-29 10:44:21"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-11-29</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">7k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 21 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h4 id="Q1-MySQL-的逻辑架构了解吗"><a href="#Q1-MySQL-的逻辑架构了解吗" class="headerlink" title="==Q1:MySQL 的逻辑架构了解吗?=="></a>==Q1:MySQL 的逻辑架构了解吗?==</h4><p>第一层是服务器层，负责链接，授权，安全</p>
<p>第二层是核心服务层，负责查询解析，储存过程，触发器，视图。分析器，优化器，执行器。</p>
<p>第三层是存储引擎层，只负责数据提取。同层不通信，与上层通过API交流，不解析SQL</p>
<h4 id="Q2-谈一谈-MySQL-的读写锁"><a href="#Q2-谈一谈-MySQL-的读写锁" class="headerlink" title="Q2:谈一谈 MySQL 的读写锁"></a>Q2:谈一谈 MySQL 的读写锁</h4><p>读锁：共享锁。互不阻塞。</p>
<p>写锁：排它锁。阻塞其他读写锁。</p>
<p>写锁优先级比读锁高，可被插入在读锁队列前。读锁不能插入写锁队列前。</p>
<h4 id="Q3-MySQL-的锁策略有什么"><a href="#Q3-MySQL-的锁策略有什么" class="headerlink" title="==Q3:MySQL 的锁策略有什么?=="></a>==Q3:MySQL 的锁策略有什么?==</h4><p><strong>表级锁</strong>：最大粒度的锁级别，发生锁冲突的概率最高，并发度最低，但开销小，加锁快，不会出现死锁；<br><strong>行级锁</strong>：最小粒度的所级别，发生锁冲突的概率最小，并发度最高，但开销大，加锁慢，会发生死锁；<br><strong>页级锁</strong>：锁粒度界于表级锁和行级锁之间，对表级锁和行级锁的折中，并发度一般。开销和加锁时间也界于表锁和行锁之间，会出现死锁；</p>
<p><strong>意向锁</strong>：当你要加表锁时，势必要先遍历该表的所有记录，判断是否有排他锁。这种遍历检查的方式显然是一种低效的方式，MySQL引入了意向锁，来检测表锁和行锁的冲突。，分为读意向锁（IS锁）和写意向锁（IX锁）。当事务要在记录上加上行锁时，则先在表上加上对应的意向锁。之后事务如果想进行锁表，只要先判断是否有意向锁存在，存在时则可快速返回该表不能启用表锁，否则就需要等待，提高效率。</p>
<h4 id="Q4-数据库死锁如何解决"><a href="#Q4-数据库死锁如何解决" class="headerlink" title="Q4:数据库死锁如何解决?"></a>Q4:数据库死锁如何解决?</h4><p>死锁：多个事务不同顺序锁定资源；多个事务锁定同个资源。</p>
<p>InnoDB自动检测死锁，并返回错误。</p>
<p>解决方法：InnoDB回滚最少行级排它锁事务 -&gt; 重新执行此事务</p>
<h4 id="Q5-事务是什么"><a href="#Q5-事务是什么" class="headerlink" title="Q5:事务是什么?"></a>Q5:事务是什么?</h4><p>一组原子性SQL语句。任何一条语句崩溃则全崩溃。事务执行要么全成功，要么全失败。</p>
<h4 id="Q6-事务有什么特性"><a href="#Q6-事务有什么特性" class="headerlink" title="==Q6:事务有什么特性?=="></a>==Q6:事务有什么特性?==</h4><p>原子性，一致性， 隔离性，持久性。</p>
<h4 id="Q7-MySQL-的隔离级别有哪些"><a href="#Q7-MySQL-的隔离级别有哪些" class="headerlink" title="==Q7:MySQL 的隔离级别有哪些?=="></a>==Q7:MySQL 的隔离级别有哪些?==</h4><p>未提交读 Read Uncommit：事务中的修改即使没有被提交，对其他事务也是可⻅的。被叫做脏读。还会导致不可重复度和幻读。</p>
<p>提交读 Read committed: 事务开始时只能看到已提交事务的修改。也叫不可重复读。</p>
<p>可重复度 Repeatable Read: MySQL默认隔离级别。保证一个事物中多次读取记录一致，解决了不可重复读。但无法解决幻读。用MVCC解决幻读。</p>
<p>可串行化 Serializable: 通过强制事物串行执行，解决幻读。但是给读取的每一行数据都加锁，导致超时和锁征用，现实很少用到。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwqiqd6hkyj30r0070jru.jpg" alt="img"></p>
<h4 id="Q8-MVCC-是什么"><a href="#Q8-MVCC-是什么" class="headerlink" title="==Q8:MVCC 是什么?=="></a>==Q8:MVCC 是什么?==</h4><p>多版本并发控制。大多情况下避免加锁，实现非阻塞读操作，写操作只锁必须行。</p>
<p>原理：每行记录保存两个列，储存系统版本号。每开始一个事务就递增版本号。事务开始时版本号作为事务版本号，与记录的版本号比较。</p>
<h4 id="Q-9-谈一谈-InnoDB"><a href="#Q-9-谈一谈-InnoDB" class="headerlink" title="Q==9:谈一谈 InnoDB=="></a>Q==9:谈一谈 InnoDB==</h4><p>InnoDB是MySQL默认事务引擎，用来处理大量短期事务，性能和崩溃自动回复较好</p>
<p>InnoDB数据结构存在表空间中，所有的表都保存在同一个数据文件中。不保存表的总行数。<strong>==InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。==</strong></p>
<p>InnoDB采用MVCC支持高并发，实现四个隔离级别。通过间隙锁解决幻读问题。</p>
<p>InnoDB使用聚簇索引，对主键查询性能高。但是二级索引必须包含主键列，导致主键过大时，整个索引也很大。所以表上索引很多的话，主键应该尽可能小。</p>
<p>InnoDB储存格式是平台独立的，可以跨平台迁移。</p>
<p>InnoDB内部做了优化，读磁盘的可预测性预读，自动创建读操作自适应哈希索引，加速插入操作的插入缓冲区。</p>
<p>5.6版本之后InnoDB存储引擎开始支持全文索引，5.7版本之后通过使用ngram插件开始支持中文。之前仅支持英文，因为是通过空格作为分词的分隔符，对于中文来说是不合适的。MySQL允许在char、varchar、text类型上建立全文索引。</p>
<h4 id="Q10-谈一谈-MyISAM"><a href="#Q10-谈一谈-MyISAM" class="headerlink" title="Q10:谈一谈 MyISAM"></a>Q10:谈一谈 MyISAM</h4><p>MySQL5.1之前的默认引擎，支持全文索引，压缩，空间函数。但是没有事务和行锁。最大缺陷是崩溃后无法完全恢复。</p>
<p>MyISAM 允许没有任何索引和主键的表存在，不支持外键。保存表的总行数。</p>
<p>MyISAM将表存在数据文件和索引文件，.myd,.myi。</p>
<p>MyISAM对整张表加锁，影响写入性能。</p>
<p>MyISAM表检查和修复操作会丢失数据。</p>
<p>设计简单，数据以紧密格式储存，但是表锁影响性能。</p>
<h4 id="Q11-谈一谈-Memory"><a href="#Q11-谈一谈-Memory" class="headerlink" title="Q11:谈一谈 Memory"></a>Q11:谈一谈 Memory</h4><p>Memory表：需要快速读取数据，不进行修改。重启后数据丢失也没关系。适合查找或映射表，中间数据。</p>
<p>所有数据储存在内存中，重启后只有表结构保留，数据丢失。</p>
<p>支持哈希索引，查询速度极快，使用表锁，因此并发写入效率低。不支持BLOB,TEXT类型。每行长度固定，Varchar变成char，造成内存空间的浪费。</p>
<h4 id="Q12-查询执行流程是什么"><a href="#Q12-查询执行流程是什么" class="headerlink" title="Q12:查询执行流程是什么?"></a>Q12:查询执行流程是什么?</h4><p>1.客户端发送一条查询给服务器。</p>
<p>2.服务器先检查查询缓存，命中缓存后返回查询结果，否则下一步</p>
<p>3.服务器解析SQL,预处理，由优化器生成执行计划。</p>
<p>4.根据执行计划，通过API调用存储引擎查询。</p>
<p>5.返回查询结果。</p>
<h4 id="Q13-VARCHAR-和-CHAR-的区别"><a href="#Q13-VARCHAR-和-CHAR-的区别" class="headerlink" title="Q13:VARCHAR 和 CHAR 的区别?"></a>Q13:VARCHAR 和 CHAR 的区别?</h4><p>Varchar 可变长度字符串，比char省空间，不会删除末尾空格，需要1，2个额外字节记录字符串长度。适合长字符串，列更新少，UTF-8复杂字符集的字符串。</p>
<p>Char固定长度，会删除末尾空格。适合短的列。适合经常更新的数据，因为不会产生碎片，如MD5。</p>
<h4 id="Q14-DATETIME-和-TIMESTAMP-的区别"><a href="#Q14-DATETIME-和-TIMESTAMP-的区别" class="headerlink" title="Q14:DATETIME 和 TIMESTAMP 的区别?"></a>Q14:DATETIME 和 TIMESTAMP 的区别?</h4><p>datetime储存范围广，1001~9999，精度为秒，不依赖时区，8字节储存空间。</p>
<p>timestamp和Unix时间戳相似，范围小，1970~2038，依赖时区，4字节储存空间。</p>
<h4 id="Q15-数据类型有哪些优化策略"><a href="#Q15-数据类型有哪些优化策略" class="headerlink" title="Q15:数据类型有哪些优化策略?"></a>Q15:数据类型有哪些优化策略?</h4><p>更小的通常更好</p>
<p>尽可能简单</p>
<p>尽量避免使用Null，索引列最好非空。</p>
<h4 id="Q16-索引有什么作用"><a href="#Q16-索引有什么作用" class="headerlink" title="==Q16:索引有什么作用?=="></a>==Q16:索引有什么作用?==</h4><p>索引也叫键，帮助存储引擎快速找到记录的数据结构。MySQL先在索引中找到对应的值，再根据匹配的索引记录找到对应的行。索引可以是一个或者多个列的值，当多个列时，列的顺序非常重要，因为MySQL只能使用索引的最左前缀。</p>
<p>索引大大减少了服务器要扫描的数据量。1.帮助服务器避免排序和临时表。2.将随机IO变成顺序IO。</p>
<p>小型表，适合全表搜索。中大型表，适合索引。特大型表索引代价增长，适合分区技术。</p>
<p>索引的缺点：</p>
<ul>
<li>当对表中的数据进行增加、删除和修改时，索引也要进行更新，维护的耗时随着数据量的增加而增加。</li>
<li>索引需要占用物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
</ul>
<h4 id="Q16-1索引的分类"><a href="#Q16-1索引的分类" class="headerlink" title="Q16.1索引的分类?"></a>Q16.1索引的分类?</h4><p>从数据结构⻆角度</p>
<ol>
<li>树索引 (O(log(n)))</li>
<li>Hash 索引</li>
</ol>
<p>从物理理存储⻆角度</p>
<ol>
<li>聚集索引(clustered index)</li>
<li>⾮非聚集索引(non-clustered index)</li>
</ol>
<p>从逻辑⻆角度</p>
<ol>
<li>普通索引 2. 唯⼀一索引 3. 主键索引 4. 联合索引 5. 全⽂文索引</li>
</ol>
<h4 id="Q17-谈一谈-MySQL-的-B-Tree-索引"><a href="#Q17-谈一谈-MySQL-的-B-Tree-索引" class="headerlink" title="==Q17:谈一谈 MySQL 的 B-Tree 索引=="></a>==Q17:谈一谈 MySQL 的 B-Tree 索引==</h4><p>InnoDB使用B+树。</p>
<p>B树所有值按照顺序储存，每个叶子节点到根的距离相同。</p>
<p>B树加快访问数据速度，因为不需要做全表扫描。是从根结点的索引开始进行搜索。</p>
<p>B-Tree索引的限制:<br>如果不是按照索引的最左列开始查找，则无法使用索引。<br>不能跳过索引中的列，例如索引为 (id,name,sex)，不能只使用 id 和 sex 而跳过 name。<br>如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引。</p>
<p>什么时候使用索引：</p>
<ol>
<li>经常出现在group by,order by和distinc关键字后面的字段</li>
<li>经常与其他表进行连接的表，在连接字段上应该建立索引</li>
<li>经常出现在Where子句中的字段</li>
<li>经常出现用作查询选择的字段</li>
</ol>
<h4 id="Q18-了解-Hash-索引吗"><a href="#Q18-了解-Hash-索引吗" class="headerlink" title="Q18:了解 Hash 索引吗?"></a>Q18:了解 Hash 索引吗?</h4><p>基于哈希表实现，只有精确匹配到所有的列才有效。对于每一行数据，存储引擎都会计算一个索引的hash码储存在索引中，同时在hash表中保存指向所有行的指针。所以hash索引查询非常快。</p>
<p>只有Memory引擎显示支持哈希索引，这也是Memory的默认搜索引擎。</p>
<p>缺点：1.数据不是按照索引值顺序排列的，无法支持排序。2.不支持部分索引匹配查找。3.只支持等值比较查询，不支持范围查找。</p>
<h4 id="Q19-什么是自适应哈希索引"><a href="#Q19-什么是自适应哈希索引" class="headerlink" title="==Q19:什么是自适应哈希索引?=="></a>==Q19:什么是自适应哈希索引?==</h4><p>是InnoDB的特殊功能，当某些索引值被引用十分频繁时，会在基于B+树索引之上创建一个hash索引，用来加快查询。这是一个完全的内部行为，用户无法控制和配置，有必要时可以关闭该功能。</p>
<h4 id="Q20-什么是空间索引"><a href="#Q20-什么是空间索引" class="headerlink" title="Q20 :什么是空间索引?"></a>Q20 :什么是空间索引?</h4><p>MyISAM表支持空间索引，储存地理数据。这类索引无需前缀查询。但是必须使用MySQL的GIS函数维护数据，MySQL对GIS支持并不完善，所以大部分人不会使用这个特性。</p>
<h4 id="Q21-什么是全文索引"><a href="#Q21-什么是全文索引" class="headerlink" title="==Q21:什么是全文索引?=="></a>==Q21:什么是全文索引?==</h4><p>如果希望通过关键字匹配进行查询，就需要基于相似度的查询，而不是精确的数值比较，全文索引就是为这种场景设计的。</p>
<p>MyISAM 的全文索引是一种特殊的 B-Tree 索引，一共有两层。第一层是所有关键字，然后对于每一个 关键字的第二层，包含的是一组相关的”文档指针”。</p>
<p>全文索引不会索引文档对象中的所有词语，它会根 据规则过滤掉一些词语，例如停用词列表中的词都不会被索引。</p>
<h4 id="Q22-什么是聚簇索引"><a href="#Q22-什么是聚簇索引" class="headerlink" title="Q22:什么是聚簇索引?"></a>Q22:什么是聚簇索引?</h4><p>InnoDB 的聚簇索引实际上在同一个结构中保存 了 B-Tree 索引和数据行。</p>
<p>当表有聚餐索引时，它的行数据实际上存放在索引的叶子⻚中，因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p>优点：1.相关数据存放在一起。2.数据访问快。3.使用覆盖扫描的查询可以直接使用叶子节点主键值。</p>
<p>缺点：1.IO密集。2.更新列代价高。3.表插入新行或主键更新导致页分裂，占用更多磁盘空间。4.数据不连续时，全表扫描可能很慢。</p>
<h4 id="Q23-什么是覆盖索引"><a href="#Q23-什么是覆盖索引" class="headerlink" title="Q23:什么是覆盖索引?"></a>Q23:什么是覆盖索引?</h4><p>覆盖索引指一个索引包含或覆盖了所有需要查询的字段的值，不再需要根据索引回表查询数据。覆盖索引必须要存储索引列的值，因此 MySQL 只能使用 B-Tree 索引做覆盖索引。</p>
<p>优点：1.索引条目远小于数据行大小，减少数据访问量。2.索引值顺序储存，较少IO. 3.InnoDB使用聚簇索引，在节点保存了行的主键值，如果二级主键能覆盖查询，避免了对主键索引的二次查询。</p>
<h4 id="Q24-你知道哪些索引使用原则-（索引调优）"><a href="#Q24-你知道哪些索引使用原则-（索引调优）" class="headerlink" title="Q24:你知道哪些索引使用原则?（索引调优）"></a>Q24:你知道哪些索引使用原则?（索引调优）</h4><p><strong>建立索引</strong>：对查询频次较高且数据量比较大的表建立索引。</p>
<p><strong>使用前缀索引</strong>： 对于 BLOB、TEXT 或很⻓的 VARCHAR 列必须使用前缀索引，MySQL 不允许索引这些列的完整⻓度。点是 MySQL 无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。</p>
<p><strong>选择合适的索引顺序</strong>：当不需要考虑排序和分组时，将选择性最高的列放在前面。索引的选择性是指不重复的索引值和数据表的记录总数之比，索引的选择性越高则查询效率越高，唯一索引的选择性是 1，因此也可以使用唯一索 引提升查询效率。</p>
<p><strong>删除无用索引</strong>：MySQL 允许在相同列上创建多个索引，了重复索 引和冗余索引，可能还会有一些服务器永远不用的索引，也应该考虑删除。</p>
<h4 id="Q25-索引失效的情况有哪些"><a href="#Q25-索引失效的情况有哪些" class="headerlink" title="==Q25:索引失效的情况有哪些?=="></a>==Q25:索引失效的情况有哪些?==</h4><p>1.<strong>如果索引列出现了隐式类型转换，则 MySQL 不会使用索引</strong>：WHERE 条件中字段类型为字符串，其值为数值，如果没有加引号那么 MySQL 不会使用索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">'a'</span> (<span class="hljs-string">'a'</span> <span class="hljs-built_in">char</span>(<span class="hljs-number">10</span>));<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-string">'a'</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">'a'</span>=<span class="hljs-string">"1"</span> <span class="hljs-comment">-- ⾛走索引</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-string">'a'</span><span class="hljs-keyword">WHERE</span> <span class="hljs-string">'a'</span>=<span class="hljs-number">1</span> <span class="hljs-comment">-- 不不⾛走索引，同样也是使⽤用了了函数运算</span><br></code></pre></td></tr></table></figure>

<p>2.<strong>如果 WHERE 条件中含有 OR，除非 OR 前使用了索引列而 OR 之后是非索引列，索引会失效。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> dname=<span class="hljs-string">'xxx'</span> <span class="hljs-keyword">or</span> loc=<span class="hljs-string">'xx'</span> <span class="hljs-keyword">or</span> deptno = <span class="hljs-number">45</span>;<br></code></pre></td></tr></table></figure>

<p>3.<strong>MySQL 不能在索引中执行 LIKE 操作。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-string">'manong'</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">`uname`</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%码农%'</span> <span class="hljs-comment">-- ⾛走索引 </span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-string">'manong'</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">`uname`</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">"%码农%"</span> <span class="hljs-comment">-- 不不⾛走索引</span><br></code></pre></td></tr></table></figure>

<p>4.<strong>如果查询中的列不是独立的，则 MySQL 不会使用索引。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">索引列列参与表达式计算:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-string">'sname'</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">'stu'</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">'age'</span> + <span class="hljs-number">10</span> = <span class="hljs-number">30</span>;<br>函数运算:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-string">'sname'</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">'stu'</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">LEFT</span>(<span class="hljs-string">'date'</span>,<span class="hljs-number">4</span>) &lt; <span class="hljs-number">1990</span>;<br></code></pre></td></tr></table></figure>

<p>5.<strong>对于多个范围条件查询，MySQL 无法使用第一个范围列后面的其他索引列.</strong></p>
<p>6.如果 MySQL 判断全表扫描比使用索引查询更快，则不会使用索引。</p>
<p>7.索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
<h4 id="Q26-如何定位低效-SQL"><a href="#Q26-如何定位低效-SQL" class="headerlink" title="Q26:如何定位低效 SQL?"></a>Q26:如何定位低效 SQL?</h4><p>方式一：一种是通过慢查询日志定位，可以通过慢查询日志定位那些已经执行完毕的 SQL 语句。</p>
<p>方式二：使用 SHOW PROCESSLIST 查询。查看当前 MySQL 正在进行的线程，包括线程的状态、是否锁表等，可以实 时查看 SQL 的执行情况，</p>
<h4 id="Q26-1-MySQL-问题排查都有哪些⼿手段"><a href="#Q26-1-MySQL-问题排查都有哪些⼿手段" class="headerlink" title="==Q26.1:MySQL 问题排查都有哪些⼿手段?=="></a>==Q26.1:MySQL 问题排查都有哪些⼿手段?==</h4><ol>
<li>使⽤用 show processlist 命令查看当前所有连接信息; </li>
<li>使⽤用 Explain 命令查询 SQL 语句句执⾏行行计划;</li>
<li>开启慢查询⽇日志，查看慢查询的 SQL。</li>
</ol>
<h4 id="Q27-SHOW-PROFILE-的作用"><a href="#Q27-SHOW-PROFILE-的作用" class="headerlink" title="Q27:SHOW PROFILE 的作用?"></a>Q27:SHOW PROFILE 的作用?</h4><p>可以分析 SQL 语句性能消耗，例如查询到 SQL 会执行多少时间，并显示 CPU、 内存使用量，执行过程中系统锁及表锁的花费时间等信息。</p>
<h4 id="Q28-Trace-是干什么的"><a href="#Q28-Trace-是干什么的" class="headerlink" title="Q28:Trace 是干什么的?"></a>Q28:Trace 是干什么的?</h4><p>从 MySQL5.6 开始，可以通过 trace 文件进一步获取优化器是是如何选择执行计划的，</p>
<h4 id="Q29-EXPLAIN-的字段有哪些，具有什么含义"><a href="#Q29-EXPLAIN-的字段有哪些，具有什么含义" class="headerlink" title="Q29:EXPLAIN 的字段有哪些，具有什么含义?"></a>Q29:EXPLAIN 的字段有哪些，具有什么含义?</h4><p>执行计划是 SQL 调优的一个重要依据，可以通过 EXPLAIN 命令查看 SQL 语句的执行计划，如果作用在 表上，那么该命令相当于 DESC。</p>
<p>重要的有id、type、key、key_len、rows、extra：</p>
<p>（1）id：id列可以理解为SQL执行顺序的标识，有几个select 就有几个id。</p>
<p>（2）select_type：查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询；</p>
<p>（4）type：访问类型，即MySQL决定如何查找表中的行。</p>
<p>（6）key：实际使用哪个索引来优化对该表的访问</p>
<p>（7）key_len：实际上用于优化查询的索引长度，即索引中使用的字节数。</p>
<p>（9）rows：根据表统计信息及索引选用情况，大致估算此处查询需要读取的行数，不是精确值。</p>
<h4 id="Q30-有哪些优化-SQL-的策略"><a href="#Q30-有哪些优化-SQL-的策略" class="headerlink" title="==Q30:有哪些优化 SQL 的策略?=="></a>==Q30:有哪些优化 SQL 的策略?==</h4><ol>
<li><p>优化 COUNT 查询：如果在 COUNT 中指定了列或列的表达式，则统计的就是这个表达式有值的结果数，而不是 NULL。不要使用count(*)</p>
</li>
<li><p>优化关联查询：确保 ON 或 USING 子句中的列上有索引，在创建索引时就要考虑到关联的顺序。</p>
</li>
<li><p>优化 GROUP BY</p>
</li>
<li><p>优化 LIMIT 分⻚ ：尽可能地使用覆盖索引扫描，而不是查询所有的列，然后根据需要做一次关联操作再返回所需的列。</p>
</li>
<li><p>优化 UNION 查询：MySQL 通过创建并填充临时表的方式来执行 UNION 查询，除非确实需要服务器消除重复的行，否则一 定要使用 UNION ALL，如果没有 ALL 关键字，MySQL 会给临时表加上 DISTINCT 选项，这会导致对整 个临时表的数据做唯一性检查，这样做的代价非常高。</p>
</li>
<li><p>优化 INSERT：需要对一张表插入很多行数据时，应该尽量使用一次性插入多个值的 INSERT 语句。</p>
</li>
</ol>
<h4 id="Q31-MySQL-主从复制的作用"><a href="#Q31-MySQL-主从复制的作用" class="headerlink" title="==Q31:MySQL 主从复制的作用?=="></a>==Q31:MySQL 主从复制的作用?==</h4><p>复制解决的基本问题是让一台服务器的数据与其他服务器保持同步，一台主库的数据可以同步到多台备库上，备库本身也可以被配置成另外一台服务器的主库。</p>
<p>MySQL 支持两种复制方式:基于行的复制和基于语句的复制，这两种方式都是通过在主库上记录二进制日志、在备库重放日志的方式来实现异步的数据复制。因此同一时刻备库的数据可能与主库存在不一致，并且无法包装主备之间的延迟。</p>
<p>主从复制的好处：</p>
<p>（1）读写分离，通过动态增加从服务器来提高数据库的性能，在主服务器上执行写入和更新，在从服务器上执行读功能。<br>（2）提高数据安全，因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份而不破坏主服务器相应数据。<br>（3）在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能</p>
<p>复制解决的问题:数据分布、负载均衡、备份、高可用性和故障切换、MySQL 升级测试</p>
<h4 id="Q32-MySQL-主从复制的步骤"><a href="#Q32-MySQL-主从复制的步骤" class="headerlink" title="==Q32:MySQL 主从复制的步骤?=="></a>==Q32:MySQL 主从复制的步骤?==</h4><p>1 在主库上把数据更改记录到二进制日志(binlog)中。</p>
<p>2 备库将主库的日志复制到自己的中继日志(relaylog)中。 </p>
<p>3 备库读取中继日志中的事件，将其重放到备库数据之上。</p>
<h4 id="Q32-1主从复制中涉及到哪三个线程"><a href="#Q32-1主从复制中涉及到哪三个线程" class="headerlink" title="==Q32.1主从复制中涉及到哪三个线程?=="></a>==Q32.1主从复制中涉及到哪三个线程?==</h4><p>主要涉及三个线程:binlog 线程、I/O 线程和 SQL 线程。</p>
<ol>
<li>binlog 线程 :负责将主服务器器上的数据更更改写⼊入⼆二进制⽇日志(Binary log)中。</li>
<li>I/O 线程 :负责从主服务器器上读取⼆二进制⽇日志，并写⼊入从服务器器的􏰀放⽇日志(Relay log)中。 </li>
<li>SQL 线程 :负责读取重放⽇日志并重放其中的 SQL 语句句</li>
</ol>
<h4 id="Q33-数据库的常用范式："><a href="#Q33-数据库的常用范式：" class="headerlink" title="Q33:数据库的常用范式："></a>Q33:<strong>数据库的常用范式：</strong></h4><p>第一范式的目标是确保每列的原子性:列都是不可再分.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr8zklmvnj31aw0akdhw.jpg" alt="image-20211125114430603"></p>
<p>第二范式要求每个表只描述一 件事情。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr8ztcp15j30zu0ds76c.jpg" alt="image-20211125114444882"></p>
<p>第三范式定义是表中的列不存在对非主键列的传递依赖。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr903prb8j31as0jqgon.jpg" alt="image-20211125114501217"></p>
<h4 id="Q34-Innodb存储引擎的执行过程："><a href="#Q34-Innodb存储引擎的执行过程：" class="headerlink" title="Q34.Innodb存储引擎的执行过程："></a>Q34.Innodb存储引擎的执行过程：</h4><p>（1）首先MySQL执行器根据 执行计划 调用存储引擎的API查询数据<br>（2）存储引擎先从缓存池buffer pool中查询数据，如果没有就会去磁盘中查询，如果查询到了就将其放到缓存池中<br>（3）在数据加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中<br>（4）innodb 会在 Buffer Pool 中执行更新操作<br>（5）更新后的数据会记录在 redo log buffer 中<br>（6）提交事务在提交的同时会做以下三件事<br>（7）（第一件事）将redo log buffer中的数据刷入到redo log文件中<br>（8）（第二件事）将本次操作记录写入到 bin log文件中<br>（9）（第三件事）将bin log文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记<br>（10）使用一个后台线程，它会在某个时机将我们Buffer Pool中的更新后的数据刷到 MySQL 数据库中，这样就将内存和数据库的数据保持统一了</p>
<h4 id="Q35-读写分离"><a href="#Q35-读写分离" class="headerlink" title="==Q35.读写分离=="></a>==Q35.读写分离==</h4><p>读写分离解决的是，数据库的写操作，影响了查询的效率，适用于读远大于写的场景。读写分离的实现基础是主从复制，主数据库负责处理写操作（当然也可以执行读操作），从数据库负责处理读操作，不能执行写操作。</p>
<h4 id="Q36-主键一般用自增ID还是UUID？"><a href="#Q36-主键一般用自增ID还是UUID？" class="headerlink" title="Q36.主键一般用自增ID还是UUID？"></a>Q36.<strong>主键一般用自增ID还是UUID？</strong></h4><p>使用自增ID的好处：</p>
<blockquote>
<p>字段长度较 UUID 会小很多。<br>数据库自动编号，按顺序存放，利于检索<br>无需担心主键重复问题</p>
</blockquote>
<p>使用自增ID的缺点：</p>
<blockquote>
<p>因为是自增，在某些业务场景下，容易被其他人查到业务量。<br>发生数据迁移时，或者表合并时会非常麻烦<br>在高并发的场景下，竞争自增锁会降低数据库的吞吐能力</p>
</blockquote>
<p>使用UUID的优点：</p>
<blockquote>
<p>唯一标识，不用考虑重复问题，在数据拆分、合并时也能达到全局的唯一性。<br>可以在应用层生成，提高数据库的吞吐能力。<br>无需担心业务量泄露的问题。</p>
</blockquote>
<p>使用UUID的缺点：</p>
<blockquote>
<p>因为UUID是随机生成的，所以会发生随机IO，影响插入速度，并且会造成硬盘的使用率较低。<br>UUID占用空间较大，建立的索引越多，造成的影响越大。<br>UUID之间比较大小较自增ID慢不少，影响查询速度。</p>
</blockquote>
<h4 id="Q37-视图View："><a href="#Q37-视图View：" class="headerlink" title="Q37.视图View："></a>Q37.视图View：</h4><p>视图是从一个或者多个表（或视图）导出的表，其内容由查询定义。视图是一个虚拟表，数据库中只存储视图的定义，不存储视图对应的数据，在对视图的数据进行操作时，系统根据视图的定义去操作相应的基本表。</p>
<p>（1）视图的优点：<br>简化了操作，把经常使用的数据定义为视图<br>安全性，用户只能查询和修改能看到的数据<br>逻辑上的独立性，屏蔽了真实表的结构带来的影响</p>
<p>（2）视图的缺点：<br>性能差，数据库必须把对视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也要把它变成一个复杂的结合体，需要花费一定的时间。</p>
<h4 id="Q38-触发器Trigger"><a href="#Q38-触发器Trigger" class="headerlink" title="Q38.触发器Trigger"></a>Q38.触发器Trigger</h4><p>触发器是与表有关的数据库对象，当触发器所在表上出现指定事件并满足定义条件的时候，将执行触发器中定义的语句集合。</p>
<h4 id="Q39-游标Cursor"><a href="#Q39-游标Cursor" class="headerlink" title="Q39.游标Cursor"></a>Q39.游标Cursor</h4><p>游标，就是游动的标识，可以充当指针的作用，使用游标可以遍历查询数据库返回的结果集中的所有记录，但是每次只能提取一条记录，即每次只能指向并取出一行的数据，以便进行相应的操作。</p>
<h4 id="Q40-最左前缀"><a href="#Q40-最左前缀" class="headerlink" title="Q40.最左前缀"></a>Q40.最左前缀</h4><p>下⾯面举例例对其进⾏行行说明:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">1. 一个 2 列列的索引 (name, age)，对 (name)、(name, age) 上建⽴立了了索引;<br>2. 一个 3 列列的索引 (name, age, sex)，对 (name)、(name, age)、(name, age, sex) 上建⽴立了了索引<br></code></pre></td></tr></table></figure>

<p>1、 B+ 树的数据项是复合的数据结构，⽐比如:(name, age, sex) 的时候，B+ 树是按照从左到右的顺序来建⽴立搜索 树的，⽐比如:当(⼩小明, 22, 男)这样的数据来检索的时候，B+ 树会优先⽐比较 name 来确定下⼀一步的所搜⽅方向，如果 name 相同再依次⽐比较 age 和 sex，最后得到检索的数据。但当 (22, 男) 这样没有 name 的数据来的时候，B+ 树 就不不知道第⼀一步该查哪个节点，因为建⽴立搜索树的时候 name 就是第⼀一个⽐比较因⼦子，必须要先根据 name 来搜索 才能知道下⼀一步去哪⾥里里查询。<br>2、 当 (⼩小明, 男) 这样的数据来检索时，B+ 树可以⽤用 name 来指定搜索⽅方向，但下⼀一个字段 age 的缺失，所以只能 把名字等于⼩小明的数据都找到，然后再匹配性别是男的数据了了， 这个是⾮非常􏰀要的性质，即索引的最左匹配特性。</p>
<h4 id="Q41-谈谈你对水平切分和垂直切分的理理解"><a href="#Q41-谈谈你对水平切分和垂直切分的理理解" class="headerlink" title="Q41.谈谈你对水平切分和垂直切分的理理解?"></a>Q41.谈谈你对水平切分和垂直切分的理理解?</h4><p><strong>⽔平切分</strong><br>是将同一个表中的记录拆分到多个结构相同的表中。当⼀个表的数据不断增多时，⽔平切分是必然的选择，它可以将数据分布到集群的不同节点上，从⽽缓存单个数据库的压力。<br><strong>垂直切分</strong><br>垂直切分是将⼀张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使⽤用的列切分到不同的表中。例如:将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p>
<h4 id="Q42-数据库并发策略"><a href="#Q42-数据库并发策略" class="headerlink" title="==Q42.数据库并发策略=="></a>==Q42.数据库并发策略==</h4><p>发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。</p>
<p><strong>乐观锁</strong><br>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据;悲观锁就刚好相反，觉得自 己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度;时间 戳就是不加锁，通过时间戳来控制并发出现的问题。</p>
<p><strong>悲观锁</strong><br>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加 锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数 据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允 许其他用户访问那部分数据。</p>
<p><strong>时间戳</strong><br>时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字 段也读出来，当写回去的时候，把该字段加 1，提交之前 ，跟数据库的该字段比较一次，如果比数 据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量，</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Shang Liang Liang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/MySQL/">http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/MySQL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">Shang Liang Liang's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/e6c9d24ely1h1f0euk1knj207305eaa5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/12/08/Java%E9%9D%A2%E8%AF%95/Redis/"><img class="prev_cover" src="https://tva1.sinaimg.cn/large/008i3skNly1gx6apfw4m6j31900u0jsp.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis</div></div></a></div><div class="next-post pull_right"><a href="/2021/11/29/Java%E9%9D%A2%E8%AF%95/B%E6%A0%91,B+%E6%A0%91,B*%E6%A0%91/"><img class="next_cover" src="https://tva1.sinaimg.cn/large/008i3skNly1gwkue98fd3j30mx0cmgmm.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">B树,B+树,B*树</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="disqus_thread"></div><script>var disqus_config = function () {
  this.page.url = 'http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/MySQL/';
  this.page.identifier = '2021/11/29/Java面试/MySQL/';
  this.page.title = 'MySQL';
};
(function() { 
  var d = document, s = d.createElement('script');
  s.src = 'https://jackshang.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();
</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By Shang Liang Liang</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script><script>if (document.getElementsByClassName('mermaid').length) {
  loadScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js',function () {
    mermaid.initialize({
      theme: 'default',
  })
})
}</script></body></html>