<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java基础 | Shang Liang Liang's Blog</title><meta name="description" content="https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6844904127059738631#heading-35 https:&#x2F;&#x2F;thinkwon.blog.csdn.net&#x2F;article&#x2F;details&#x2F;104390612 Java基础Java概述&#x3D;&#x3D;jdk1.5之后的三大版本&#x3D;&#x3D; Java SE，标准版。支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。 Java"><meta name="author" content="Shang Liang Liang"><meta name="copyright" content="Shang Liang Liang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/logo.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java基础"><meta name="twitter:description" content="https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6844904127059738631#heading-35 https:&#x2F;&#x2F;thinkwon.blog.csdn.net&#x2F;article&#x2F;details&#x2F;104390612 Java基础Java概述&#x3D;&#x3D;jdk1.5之后的三大版本&#x3D;&#x3D; Java SE，标准版。支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。 Java"><meta name="twitter:image" content="https://source.unsplash.com/random/800*600"><meta property="og:type" content="article"><meta property="og:title" content="Java基础"><meta property="og:url" content="http://yoursite.com/2021/12/21/Java%E9%9D%A2%E8%AF%95/1.0%20Java%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="Shang Liang Liang's Blog"><meta property="og:description" content="https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6844904127059738631#heading-35 https:&#x2F;&#x2F;thinkwon.blog.csdn.net&#x2F;article&#x2F;details&#x2F;104390612 Java基础Java概述&#x3D;&#x3D;jdk1.5之后的三大版本&#x3D;&#x3D; Java SE，标准版。支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。 Java"><meta property="og:image" content="https://source.unsplash.com/random/800*600"><meta property="article:published_time" content="2021-12-21T02:22:00.000Z"><meta property="article:modified_time" content="2022-02-21T00:25:32.889Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://yoursite.com/2021/12/21/Java%E9%9D%A2%E8%AF%95/1.0%20Java%E5%9F%BA%E7%A1%80/"><link rel="next" title="Redis" href="http://yoursite.com/2021/12/08/Java%E9%9D%A2%E8%AF%95/Redis/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?16c6948b730158e8efcea17a55c7ca6d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Shang Liang Liang","link":"链接: ","source":"来源: Shang Liang Liang's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: false,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Shang Liang Liang's Blog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">47</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java基础"><span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java概述"><span class="toc-text">Java概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk1-5之后的三大版本"><span class="toc-text">&#x3D;&#x3D;jdk1.5之后的三大版本&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jdk和Jre和JVM的区别"><span class="toc-text">&#x3D;&#x3D;Jdk和Jre和JVM的区别&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java语言有哪些特点"><span class="toc-text">Java语言有哪些特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是字节码？采用字节码的最大好处是什么"><span class="toc-text">&#x3D;&#x3D;什么是字节码？采用字节码的最大好处是什么&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Java程序的主类？应用程序和小程序的主类有何不同？"><span class="toc-text">什么是Java程序的主类？应用程序和小程序的主类有何不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java应用程序与小程序之间有那些差别？"><span class="toc-text">Java应用程序与小程序之间有那些差别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java和C-的区别"><span class="toc-text">Java和C++的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Oracle-JDK-和-OpenJDK-的对比"><span class="toc-text">&#x3D;&#x3D;Oracle JDK 和 OpenJDK 的对比&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础语法"><span class="toc-text">基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型"><span class="toc-text">&#x3D;&#x3D;数据类型&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java有哪些数据类型"><span class="toc-text">&#x3D;&#x3D;Java有哪些数据类型&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自动装箱与拆箱"><span class="toc-text">&#x3D;&#x3D;自动装箱与拆箱&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Integer-a-127-与-Integer-b-127相等吗"><span class="toc-text">&#x3D;&#x3D;Integer a&#x3D; 127 与 Integer b &#x3D; 127相等吗&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上"><span class="toc-text">&#x3D;&#x3D;switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用最有效率的方法计算-2-乘以-8"><span class="toc-text">用最有效率的方法计算 2 乘以 8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少"><span class="toc-text">Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#float-f-3-4-是否正确"><span class="toc-text">float f&#x3D;3.4;是否正确</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><span class="toc-text">short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编码"><span class="toc-text">编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java语言采用何种编码方案？有何特点？"><span class="toc-text">Java语言采用何种编码方案？有何特点？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问修饰符"><span class="toc-text">&#x3D;&#x3D;访问修饰符&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运算符"><span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#amp-和-amp-amp-的区别"><span class="toc-text">&#x3D;&#x3D;&amp;和&amp;&amp;的区别&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关键字"><span class="toc-text">关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-有没有-goto"><span class="toc-text">Java 有没有 goto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final-有什么用？"><span class="toc-text">&#x3D;&#x3D;final 有什么用？&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final-finally-finalize区别"><span class="toc-text">&#x3D;&#x3D;final finally finalize区别&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this关键字的用法"><span class="toc-text">this关键字的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super关键字的用法"><span class="toc-text">super关键字的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this与super的区别"><span class="toc-text">this与super的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static存在的主要意义"><span class="toc-text">&#x3D;&#x3D;static存在的主要意义&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static的独特之处"><span class="toc-text">static的独特之处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static应用场景"><span class="toc-text">static应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象概述"><span class="toc-text">面向对象概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#面向对象和面向过程的区别"><span class="toc-text">&#x3D;&#x3D;面向对象和面向过程的区别&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象三大特性"><span class="toc-text">&#x3D;&#x3D;面向对象三大特性&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#面向对象的特征有哪些方面"><span class="toc-text">面向对象的特征有哪些方面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java语言是如何实现多态的？"><span class="toc-text">Java语言是如何实现多态的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面向对象五大基本原则是什么（可选）"><span class="toc-text">面向对象五大基本原则是什么（可选）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Bean"><span class="toc-text">Java Bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java注解"><span class="toc-text">Java注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类与接口"><span class="toc-text">类与接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#抽象类和接口的对比"><span class="toc-text">&#x3D;&#x3D;抽象类和接口的对比&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#普通类和抽象类有哪些区别？"><span class="toc-text">普通类和抽象类有哪些区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#抽象类能使用-final-修饰吗？"><span class="toc-text">抽象类能使用 final 修饰吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建一个对象用什么关键字？对象实例与对象引用有何不同？"><span class="toc-text">创建一个对象用什么关键字？对象实例与对象引用有何不同？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量与方法"><span class="toc-text">变量与方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#成员变量与局部变量的区别有哪些"><span class="toc-text">成员变量与局部变量的区别有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造方法有哪些特性？"><span class="toc-text">&#x3D;&#x3D;构造方法有哪些特性？&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在Java中定义一个不做事且没有参数的构造方法的作用"><span class="toc-text">&#x3D;&#x3D;在Java中定义一个不做事且没有参数的构造方法的作用&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"><span class="toc-text">一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写与重载"><span class="toc-text">&#x3D;&#x3D;重写与重载&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#构造器（constructor）是否可被重写（override）"><span class="toc-text">&#x3D;&#x3D;构造器（constructor）是否可被重写（override）&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><span class="toc-text">重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象相等判断"><span class="toc-text">对象相等判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#和-equals-的区别是什么"><span class="toc-text">&#x3D;&#x3D;&#x3D;&#x3D; 和 equals 的区别是什么&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashCode-与-equals-重要"><span class="toc-text">&#x3D;&#x3D;hashCode 与 equals (重要)&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象的相等与指向他们的引用相等，两者有什么不同？"><span class="toc-text">对象的相等与指向他们的引用相等，两者有什么不同？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的克隆"><span class="toc-text">&#x3D;&#x3D;对象的克隆&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么要克隆？"><span class="toc-text">&#x3D;&#x3D;为什么要克隆？&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#浅拷贝深拷贝的区别？"><span class="toc-text">&#x3D;&#x3D;浅拷贝深拷贝的区别？&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#浅复制（浅克隆）"><span class="toc-text">浅复制（浅克隆）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#深复制（深克隆）"><span class="toc-text">深复制（深克隆）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何实现克隆？"><span class="toc-text">&#x3D;&#x3D;如何实现克隆？&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#值传递"><span class="toc-text">值传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"><span class="toc-text">当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么-Java-中只有值传递"><span class="toc-text">&#x3D;&#x3D;为什么 Java 中只有值传递&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#值传递和引用传递有什么区别"><span class="toc-text">值传递和引用传递有什么区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java包"><span class="toc-text">Java包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-中常用的包有哪些"><span class="toc-text">JDK 中常用的包有哪些</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO流"><span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-中-IO-流分为几种"><span class="toc-text">java 中 IO 流分为几种?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO-NIO-AIO-有什么区别"><span class="toc-text">&#x3D;&#x3D;BIO,NIO,AIO 有什么区别?&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Files的常用方法都有哪些？"><span class="toc-text">Files的常用方法都有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型与反射"><span class="toc-text">泛型与反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-的泛型是如何工作的-什么是类型擦除"><span class="toc-text">Java 的泛型是如何工作的 ? 什么是类型擦除 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是泛型中的限定通配符和非限定通配符"><span class="toc-text">什么是泛型中的限定通配符和非限定通配符 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List-lt-extends-T-gt-和-List-lt-super-T-gt-之间有什么区别"><span class="toc-text">List&lt;? extends T&gt; 和 List &lt;? super T&gt; 之间有什么区别 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是反射机制？"><span class="toc-text">什么是反射机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反射机制优缺点"><span class="toc-text">&#x3D;&#x3D;反射机制优缺点&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反射机制的应用场景有哪些？"><span class="toc-text">反射机制的应用场景有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java获取反射的三种方法"><span class="toc-text">Java获取反射的三种方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java字符串"><span class="toc-text">Java字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是字符串常量池？"><span class="toc-text">什么是字符串常量池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String有哪些特性"><span class="toc-text">String有哪些特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-str-”i”与-String-str-new-String-“i”-一样吗？"><span class="toc-text">&#x3D;&#x3D;String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-s-new-String-“xyz”-创建了几个字符串对象"><span class="toc-text">String s &#x3D; new String(“xyz”);创建了几个字符串对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何将字符串反转？"><span class="toc-text">&#x3D;&#x3D;如何将字符串反转？&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组有没有-length-方法？String-有没有-length-方法"><span class="toc-text">数组有没有 length()方法？String 有没有 length()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-类的常用方法都有那些？"><span class="toc-text">&#x3D;&#x3D;String 类的常用方法都有那些？&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在使用-HashMap-的时候，用-String-做-key-有什么好处？"><span class="toc-text">在使用 HashMap 的时候，用 String 做 key 有什么好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String和StringBuffer、StringBuilder的区别是什么？"><span class="toc-text">&#x3D;&#x3D;String和StringBuffer、StringBuilder的区别是什么？&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java日期类"><span class="toc-text">Java日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Date类"><span class="toc-text">Date类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-util-Date"><span class="toc-text">java.util.Date</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java-sql-Date"><span class="toc-text">java.sql.Date</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java-sql-Time"><span class="toc-text">java.sql.Time</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java-sql-Timestamp"><span class="toc-text">java.sql.Timestamp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DateFormat类"><span class="toc-text">DateFormat类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-Calendar类"><span class="toc-text">java.util.Calendar类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-8-之前的时间操作"><span class="toc-text">JDK 8 之前的时间操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Instant时间戳（Java-8，线程安全）"><span class="toc-text">Instant时间戳（Java 8，线程安全）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-time-LocalDate（Java-8，线程安全）"><span class="toc-text">java.time.LocalDate（Java 8，线程安全）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-time-LocalTime（Java-8，线程安全）"><span class="toc-text">java.time.LocalTime（Java 8，线程安全）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-time-LocalDateTime（Java-8，线程安全）"><span class="toc-text">java.time.LocalDateTime（Java 8，线程安全）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DateTimeFormatter类"><span class="toc-text">DateTimeFormatter类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何优雅地计算两个时间的相隔时间？"><span class="toc-text">如何优雅地计算两个时间的相隔时间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何优雅地计算两个日期的相隔日期？"><span class="toc-text">如何优雅地计算两个日期的相隔日期？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何比较两个时间（Date）的大小？"><span class="toc-text">如何比较两个时间（Date）的大小？</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div class="post-bg" id="nav" style="background-image: url(https://source.unsplash.com/random/800*600)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Shang Liang Liang's Blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Java基础</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-12-21 10:22:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-12-21</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-02-21 08:25:32"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2022-02-21</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">13.1k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 44 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p><a href="https://juejin.cn/post/6844904127059738631#heading-35" target="_blank" rel="noopener">https://juejin.cn/post/6844904127059738631#heading-35</a></p>
<p><a href="https://thinkwon.blog.csdn.net/article/details/104390612" target="_blank" rel="noopener">https://thinkwon.blog.csdn.net/article/details/104390612</a></p>
<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h2><h3 id="jdk1-5之后的三大版本"><a href="#jdk1-5之后的三大版本" class="headerlink" title="==jdk1.5之后的三大版本=="></a>==jdk1.5之后的三大版本==</h3><ul>
<li>Java SE，标准版。支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。</li>
<li>Java EE，企业版。提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE</li>
<li>Java ME，微型版。在移动设备和嵌入式设备上运行的应用程序提供一个健壮且灵活的环境。应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</li>
</ul>
<h3 id="Jdk和Jre和JVM的区别"><a href="#Jdk和Jre和JVM的区别" class="headerlink" title="==Jdk和Jre和JVM的区别=="></a>==Jdk和Jre和JVM的区别==</h3><p><strong>JVM</strong><br>Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p>
<p><strong>JRE</strong></p>
<p>包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p>
<p><strong>JDK</strong> </p>
<p>提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxc2cfso1dj30o60eqgn9.jpg" alt="img"></p>
<h3 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h3><ol>
<li>简单易学（Java语言的语法与C语言和C++语言很接近）</li>
<li>面向对象（封装，继承，多态）</li>
<li>平台无关性（Java虚拟机实现平台无关性）</li>
<li>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</li>
<li>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</li>
<li>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</li>
<li>安全性好</li>
</ol>
<h3 id="什么是字节码？采用字节码的最大好处是什么"><a href="#什么是字节码？采用字节码的最大好处是什么" class="headerlink" title="==什么是字节码？采用字节码的最大好处是什么=="></a>==什么是字节码？采用字节码的最大好处是什么==</h3><ul>
<li><p><strong>字节码</strong>：</p>
<p>Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
</li>
<li><p><strong>采用字节码的好处</strong>：</p>
<ol>
<li>在一定程度上解决了传统解释型语言执行效率低的问题，所以Java程序运行时比较高效。</li>
<li>保留了解释型语言可移植的特点，由于字节码并不专对一种特定的机器，因此，无须重新编译便可在多种不同的计算机上运行。</li>
</ol>
</li>
<li><p><strong>java中的编译器和解释器</strong>：</p>
<p>Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。</p>
<p>Java源代码—&gt;编译器—&gt;jvm可执行的Java字节码(即虚拟指令)—&gt;jvm—&gt;jvm中解释器—-&gt;机器可执行的二进制机器码—&gt;程序运行。</p>
</li>
</ul>
<h3 id="什么是Java程序的主类？应用程序和小程序的主类有何不同？"><a href="#什么是Java程序的主类？应用程序和小程序的主类有何不同？" class="headerlink" title="什么是Java程序的主类？应用程序和小程序的主类有何不同？"></a>什么是Java程序的主类？应用程序和小程序的主类有何不同？</h3><p>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p>
<h3 id="Java应用程序与小程序之间有那些差别？"><a href="#Java应用程序与小程序之间有那些差别？" class="headerlink" title="Java应用程序与小程序之间有那些差别？"></a>Java应用程序与小程序之间有那些差别？</h3><p>简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。</p>
<h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li>
<li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li>
</ul>
<h3 id="Oracle-JDK-和-OpenJDK-的对比"><a href="#Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="==Oracle JDK 和 OpenJDK 的对比=="></a>==Oracle JDK 和 OpenJDK 的对比==</h3><ol>
<li>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；</li>
<li>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；</li>
<li>Oracle JDK 比 OpenJDK 更稳定。</li>
<li>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；</li>
<li>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>
<li>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</li>
</ol>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="==数据类型=="></a>==数据类型==</h3><h4 id="Java有哪些数据类型"><a href="#Java有哪些数据类型" class="headerlink" title="==Java有哪些数据类型=="></a>==Java有哪些数据类型==</h4><ul>
<li>基本数据类型<ul>
<li>数值型<ul>
<li>整数类型(byte,short,int,long)</li>
<li>浮点类型(float,double)</li>
</ul>
</li>
<li>字符型(char)</li>
<li>布尔型(boolean)</li>
</ul>
</li>
<li>引用数据类型<ul>
<li>类(class)</li>
<li>接口(interface)</li>
<li>数组([])</li>
</ul>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxc2s4j5myj30w50ab41r.jpg" alt="img"></p>
<h4 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="==自动装箱与拆箱=="></a>==自动装箱与拆箱==</h4><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>Java 为每个原始类型提供了包装类型：</p>
<ul>
<li>原始类型: boolean，char，byte，short，int，long，float，double</li>
<li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li>
</ul>
<h4 id="Integer-a-127-与-Integer-b-127相等吗"><a href="#Integer-a-127-与-Integer-b-127相等吗" class="headerlink" title="==Integer a= 127 与 Integer b = 127相等吗=="></a>==Integer a= 127 与 Integer b = 127相等吗==</h4><ul>
<li>对于对象引用类型：==比较的是对象的内存地址。</li>
<li>对于基本数据类型：==比较的是值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer a = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">3</span>);<br>    Integer b = <span class="hljs-number">3</span>;  <span class="hljs-comment">// 将3自动装箱成Integer类型</span><br>    <span class="hljs-keyword">int</span> c = <span class="hljs-number">3</span>;<br>    System.out.println(a == b); <span class="hljs-comment">// false 两个引用没有引用同一对象</span><br>    System.out.println(a == c); <span class="hljs-comment">// true a自动拆箱成int类型再和c比较</span><br>    System.out.println(b == c); <span class="hljs-comment">// true b自动拆箱成int类型再和c比较</span><br>		<span class="hljs-comment">// 如果整型自变量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，</span><br>    <span class="hljs-comment">// 超过范围 a1==b1的结果是false</span><br>    Integer a1 = <span class="hljs-number">128</span>;<br>    Integer b1 = <span class="hljs-number">128</span>;<br>    System.out.println(a1 == b1); <span class="hljs-comment">// false</span><br><br>    Integer a2 = <span class="hljs-number">127</span>;<br>    Integer b2 = <span class="hljs-number">127</span>;<br>    System.out.println(a2 == b2); <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上"><a href="#switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上" class="headerlink" title="==switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上=="></a>==switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上==</h4><p>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。<br>从 Java 5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，<br>从 Java 7 开始，expr 还可以是字符串（String），<br>但是长整型（long）在目前所有的版本中都是不可以的。</p>
<h4 id="用最有效率的方法计算-2-乘以-8"><a href="#用最有效率的方法计算-2-乘以-8" class="headerlink" title="用最有效率的方法计算 2 乘以 8"></a>用最有效率的方法计算 2 乘以 8</h4><p>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）</p>
<h4 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少？Math.round(-11.5)等于多少"></a>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</h4><p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。<strong>四舍五入的原理是在参数上加 0.5 然后进行下取整。</strong></p>
<h4 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f=3.4;是否正确"></a>float f=3.4;是否正确</h4><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。</p>
<h4 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗"></a>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</h4><ul>
<li><p>对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。</p>
</li>
<li><p>而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</p>
</li>
</ul>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="Java语言采用何种编码方案？有何特点？"><a href="#Java语言采用何种编码方案？有何特点？" class="headerlink" title="Java语言采用何种编码方案？有何特点？"></a>Java语言采用何种编码方案？有何特点？</h4><p>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="==访问修饰符=="></a>==访问修饰符==</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxc34k3rdkj30eg03xweu.jpg" alt="img"></p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="==&amp;和&amp;&amp;的区别=="></a>==&amp;和&amp;&amp;的区别==</h4><ul>
<li>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</li>
<li>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</li>
</ul>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="Java-有没有-goto"><a href="#Java-有没有-goto" class="headerlink" title="Java 有没有 goto"></a>Java 有没有 goto</h4><p>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p>
<h4 id="final-有什么用？"><a href="#final-有什么用？" class="headerlink" title="==final 有什么用？=="></a>==final 有什么用？==</h4><ul>
<li>被final修饰的类不可以被继承</li>
<li>被final修饰的方法不可以被重写</li>
<li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的。</li>
</ul>
<h4 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="headerlink" title="==final finally finalize区别=="></a>==final finally finalize区别==</h4><ul>
<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表 示该变量是一个常量不能被重新赋值。</li>
<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块 中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li>
<li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调 用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。</li>
</ul>
<h4 id="this关键字的用法"><a href="#this关键字的用法" class="headerlink" title="this关键字的用法"></a>this关键字的用法</h4><ul>
<li><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p>
</li>
<li><p>this的用法在java中大体可以分为3种：</p>
<ol>
<li>普通的直接引用，this相当于是指向当前对象本身。</li>
<li>形参与成员名字重名，用this来区分：</li>
<li>引用本类的构造函数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(name);<span class="hljs-comment">// 这里</span><br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="super关键字的用法"><a href="#super关键字的用法" class="headerlink" title="super关键字的用法"></a>super关键字的用法</h4><ul>
<li>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</li>
<li>super也有三种用法：<ol>
<li>普通的直接引用.</li>
<li>子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分.</li>
<li>引用父类构造函数</li>
</ol>
</li>
</ul>
<h4 id="this与super的区别"><a href="#this与super的区别" class="headerlink" title="this与super的区别"></a>this与super的区别</h4><ul>
<li>super()和this()均需放在构造方法内第一行。</li>
<li>尽管可以用this调用一个构造器，但却不能调用两个。</li>
<li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li>
<li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li>
<li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li>
</ul>
<h4 id="static存在的主要意义"><a href="#static存在的主要意义" class="headerlink" title="==static存在的主要意义=="></a>==static存在的主要意义==</h4><ul>
<li>static的主要意义是在于创建独立于具体对象的域变量或者方法。<strong>以致于即使没有创建对象，也能使用属性和调用方法</strong>！</li>
<li>static关键字还有一个比较关键的作用就是 <strong>用来形成静态代码块以优化程序性能</strong>。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</li>
<li>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</li>
</ul>
<h4 id="static的独特之处"><a href="#static的独特之处" class="headerlink" title="static的独特之处"></a>static的独特之处</h4><ol>
<li>被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法<strong>不属于任何一个实例对象，而是被类的实例对象所共享</strong>。</li>
<li>在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</li>
<li>static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的。</li>
<li>被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</li>
</ol>
<h4 id="static应用场景"><a href="#static应用场景" class="headerlink" title="static应用场景"></a>static应用场景</h4><p>1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部类】 5、静态导包</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h3><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="==面向对象和面向过程的区别=="></a>==面向对象和面向过程的区别==</h4><p><strong>面向过程</strong>：</p>
<ul>
<li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li>
<li>缺点：没有面向对象易维护、易复用、易扩展</li>
</ul>
<p><strong>面向对象</strong>：</p>
<ul>
<li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li>
<li>缺点：性能比面向过程低</li>
</ul>
<h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="==面向对象三大特性=="></a>==面向对象三大特性==</h3><h4 id="面向对象的特征有哪些方面"><a href="#面向对象的特征有哪些方面" class="headerlink" title="面向对象的特征有哪些方面"></a>面向对象的特征有哪些方面</h4><ul>
<li><p><strong>封装</strong>把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
</li>
<li><p><strong>继承</strong>是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p>  关于继承如下 3 点请记住：</p>
<ul>
<li>子类拥有父类非 private 的属性和方法。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ul>
</li>
<li><p><strong>多态</strong>：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
</li>
</ul>
<h4 id="Java语言是如何实现多态的？"><a href="#Java语言是如何实现多态的？" class="headerlink" title="Java语言是如何实现多态的？"></a>Java语言是如何实现多态的？</h4><ul>
<li>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</li>
</ul>
<p><strong>多态的实现</strong></p>
<ul>
<li>Java实现多态有三个必要条件：继承、重写、向上转型。<ul>
<li>继承：在多态中必须存在有继承关系的子类和父类。</li>
<li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>
<li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li>
</ul>
</li>
</ul>
<h4 id="面向对象五大基本原则是什么（可选）"><a href="#面向对象五大基本原则是什么（可选）" class="headerlink" title="面向对象五大基本原则是什么（可选）"></a>面向对象五大基本原则是什么（可选）</h4><ol>
<li><strong>单一职责原则</strong>SRP(Single Responsibility Principle)<br> 类的功能要单一，不能包罗万象，跟杂货铺似的。</li>
<li><strong>开放封闭原则</strong>OCP(Open－Close Principle)<br> 一个模块对于拓展是开放的，对于修改是封闭的。</li>
<li><strong>里式替换原则</strong>LSP(the Liskov Substitution Principle LSP)<br> 子类可以替换父类出现在父类能够出现的任何地方。</li>
<li><strong>依赖倒置原则</strong>DIP(the Dependency Inversion Principle DIP)<br> 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</li>
<li><strong>接口分离原则</strong>ISP(the Interface Segregation Principle ISP)<br> 设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</li>
</ol>
<h3 id="Java-Bean"><a href="#Java-Bean" class="headerlink" title="Java Bean"></a>Java Bean</h3><p>参考：<a href="https://www.zhihu.com/question/19773379，https://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680" target="_blank" rel="noopener">https://www.zhihu.com/question/19773379，https://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680</a></p>
<p>简单来说：一种规范，表达实体和信息的规范，便于封装重用</p>
<p>1、所有属性为private</p>
<p>2、提供默认构造方法</p>
<p>3、提供getter和setter</p>
<p>4、实现serializable接口</p>
<h3 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h3><p><a href="https://www.runoob.com/w3cnote/java-annotation.html，" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/java-annotation.html，</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265102413966176" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1265102413966176</a></p>
<p><a href="https://blog.csdn.net/javazejian/article/details/71860633" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/71860633</a></p>
<p><a href="https://www.jianshu.com/p/5cac4cb9be54" target="_blank" rel="noopener">https://www.jianshu.com/p/5cac4cb9be54</a></p>
<p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p>
<p><strong>注解的作用</strong></p>
<ul>
<li><strong>格式检查：</strong>告诉编译器信息，比如被@Override标记的方法如果不是父类的某个方法，IDE会报错；</li>
<li><strong>减少配置：</strong>运行时动态处理，得到注解信息，实现代替配置文件的功能；</li>
<li><strong>减少重复工作：</strong>比如第三方框架xUtils，通过注解@ViewInject减少对findViewById的调用，类似的还有（JUnit、ActiveAndroid等）；</li>
</ul>
<h3 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h3><h4 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="==抽象类和接口的对比=="></a>==抽象类和接口的对比==</h4><p><strong>相同点</strong></p>
<ul>
<li>接口和抽象类都不能实例化</li>
<li>都位于继承的顶端，用于被其他实现或继承</li>
<li>都包含抽象方法，其子类都必须覆写这些抽象方法</li>
</ul>
<p><strong>不同点</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>声明</td>
<td>抽象类使用abstract关键字声明</td>
<td>接口使用interface关键字声明</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td>
<td>子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象类中的方法可以是任意访问修饰符</td>
<td>接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td>
</tr>
<tr>
<td>多继承</td>
<td>一个类最多只能继承一个抽象类</td>
<td>一个类可以实现多个接口</td>
</tr>
<tr>
<td>字段声明</td>
<td>抽象类的字段声明可以是任意的</td>
<td>接口的字段默认都是 static 和 final 的</td>
</tr>
</tbody></table>
<p><strong>备注</strong>：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p>
<h4 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h4><ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
<h4 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h4><ul>
<li>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承。</li>
</ul>
<h4 id="创建一个对象用什么关键字？对象实例与对象引用有何不同？"><a href="#创建一个对象用什么关键字？对象实例与对象引用有何不同？" class="headerlink" title="创建一个对象用什么关键字？对象实例与对象引用有何不同？"></a>创建一个对象用什么关键字？对象实例与对象引用有何不同？</h4><ul>
<li>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</li>
</ul>
<h3 id="变量与方法"><a href="#变量与方法" class="headerlink" title="变量与方法"></a>变量与方法</h3><h4 id="成员变量与局部变量的区别有哪些"><a href="#成员变量与局部变量的区别有哪些" class="headerlink" title="成员变量与局部变量的区别有哪些"></a>成员变量与局部变量的区别有哪些</h4><p><strong>变量存储位置</strong></p>
<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。</li>
<li>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</li>
</ul>
<h4 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="==构造方法有哪些特性？=="></a>==构造方法有哪些特性？==</h4><ul>
<li>名字与类名相同；</li>
<li>没有返回值，但不能用void声明构造函数；</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ul>
<h4 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="==在Java中定义一个不做事且没有参数的构造方法的作用=="></a>==在Java中定义一个不做事且没有参数的构造方法的作用==</h4><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p>
<h4 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</h4><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p>
<h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="==重写与重载=="></a>==重写与重载==</h3><p>参考：<a href="https://www.runoob.com/java/java-override-overload.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-override-overload.html</a></p>
<h4 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="==构造器（constructor）是否可被重写（override）=="></a>==构造器（constructor）是否可被重写（override）==</h4><p>构造器不能被继承，因此不能被重写，但可以被重载。</p>
<h4 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h4><ul>
<li>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</li>
<li>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</li>
<li>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">区别点</th>
<th align="left">重载方法</th>
<th align="left">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">参数列表</td>
<td align="left">必须修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">返回类型</td>
<td align="left">可以修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">可以修改</td>
<td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td align="left">访问</td>
<td align="left">可以修改</td>
<td align="left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody></table>
<h3 id="对象相等判断"><a href="#对象相等判断" class="headerlink" title="对象相等判断"></a>对象相等判断</h3><h4 id="和-equals-的区别是什么"><a href="#和-equals-的区别是什么" class="headerlink" title="==== 和 equals 的区别是什么=="></a>==== 和 equals 的区别是什么==</h4><ul>
<li><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</p>
</li>
<li><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<ul>
<li><p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</p>
</li>
<li><p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>
</li>
<li><p>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</p>
</li>
<li><p>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String a = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"ab"</span>); <span class="hljs-comment">// a 为一个引用</span><br>        String b = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"ab"</span>); <span class="hljs-comment">// b为另一个引用,对象的内容一样</span><br>        String aa = <span class="hljs-string">"ab"</span>; <span class="hljs-comment">// 放在常量池中</span><br>        String bb = <span class="hljs-string">"ab"</span>; <span class="hljs-comment">// 从常量池中查找</span><br>        <span class="hljs-keyword">if</span> (aa == bb) <span class="hljs-comment">// true</span><br>            System.out.println(<span class="hljs-string">"aa==bb"</span>);<br>        <span class="hljs-keyword">if</span> (a == b) <span class="hljs-comment">// false，非同一对象</span><br>            System.out.println(<span class="hljs-string">"a==b"</span>);<br>        <span class="hljs-keyword">if</span> (a.equals(b)) <span class="hljs-comment">// true</span><br>            System.out.println(<span class="hljs-string">"aEQb"</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">42</span> == <span class="hljs-number">42.0</span>) &#123; <span class="hljs-comment">// true</span><br>            System.out.println(<span class="hljs-string">"true"</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="hashCode-与-equals-重要"><a href="#hashCode-与-equals-重要" class="headerlink" title="==hashCode 与 equals (重要)=="></a>==hashCode 与 equals (重要)==</h4><p><strong>hashCode()介绍</strong></p>
<p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p>
<p><strong>为什么要有 hashCode</strong></p>
<p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p><strong>hashCode()与equals()的相关规定</strong></p>
<ul>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等，对两个对象分别调用equals方法都返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
</ul>
<p>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</p>
<h4 id="对象的相等与指向他们的引用相等，两者有什么不同？"><a href="#对象的相等与指向他们的引用相等，两者有什么不同？" class="headerlink" title="对象的相等与指向他们的引用相等，两者有什么不同？"></a>对象的相等与指向他们的引用相等，两者有什么不同？</h4><ul>
<li>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。</li>
</ul>
<h3 id="对象的克隆"><a href="#对象的克隆" class="headerlink" title="==对象的克隆=="></a>==对象的克隆==</h3><p>参考：<a href="https://www.cnblogs.com/qian123/p/5710533.html" target="_blank" rel="noopener">https://www.cnblogs.com/qian123/p/5710533.html</a></p>
<h4 id="为什么要克隆？"><a href="#为什么要克隆？" class="headerlink" title="==为什么要克隆？=="></a>==为什么要克隆？==</h4><ul>
<li><p>克隆的对象可能包含一些已经修改过的属性，而new出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠clone方法了。那么我把这个对象的临时属性一个一个的赋值给我新new的对象不也行嘛？可以是可以，但是一来麻烦不说，二来，大家通过上面的源码都发现了clone是一个native方法，就是快啊，在底层实现的。</p>
</li>
<li><p>提个醒，我们常见的Object a=new Object();Object b;b=a;这种形式的代码复制的是引用，即对象在内存中的地址，a和b对象仍然指向了同一个对象。而通过clone方法赋值的对象跟原来的对象时同时独立存在的。</p>
</li>
</ul>
<h4 id="浅拷贝深拷贝的区别？"><a href="#浅拷贝深拷贝的区别？" class="headerlink" title="==浅拷贝深拷贝的区别？=="></a>==浅拷贝深拷贝的区别？==</h4><ul>
<li>在Java语言中，数据类型分为值类型（基本数据类型）和引用类型，值类型包括int、double、byte、boolean、char等简单数据类型，引用类型包括类、接口、数组等复杂类型。浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制。不可变引用数据类型（String）的数据可以被浅拷贝。</li>
</ul>
<h5 id="浅复制（浅克隆）"><a href="#浅复制（浅克隆）" class="headerlink" title="浅复制（浅克隆）"></a>浅复制（浅克隆）</h5><ul>
<li><p>实现 Cloneable 接⼝并重写 Object 类中的 clone() ⽅法;（浅拷贝）</p>
</li>
<li><p>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。</p>
</li>
<li><p>换言之，<strong>浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。</strong></p>
</li>
</ul>
<h5 id="深复制（深克隆）"><a href="#深复制（深克隆）" class="headerlink" title="深复制（深克隆）"></a>深复制（深克隆）</h5><ul>
<li><p>实现 Serializable 接⼝，通过对象的序列化和反序列化实现克隆（深拷贝）</p>
</li>
<li><p>被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。</p>
</li>
<li><p>那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。</p>
</li>
<li><p>换言之，<strong>深复制把要复制的对象所引用的对象都复制了一遍</strong>。</p>
</li>
</ul>
<h4 id="如何实现克隆？"><a href="#如何实现克隆？" class="headerlink" title="==如何实现克隆？=="></a>==如何实现克隆？==</h4><ul>
<li><strong>浅克隆：</strong></li>
</ul>
<ol>
<li><p>被复制的类需要实现Clonenable接口（不实现的话在调用clone方法会抛出CloneNotSupportedException异常)， 该接口为标记接口(不含任何方法)</p>
</li>
<li><p>覆盖clone()方法，访问修饰符设为public。方法中调用super.clone()方法得到需要的复制对象。（native为本地方法)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;  <br>  <br>		... getter(),setter()...<br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;  <br>        Student stu = <span class="hljs-keyword">null</span>;  <br>        <span class="hljs-keyword">try</span>&#123;  <br>            stu = (Student)<span class="hljs-keyword">super</span>.clone();  <br>        &#125;<span class="hljs-keyword">catch</span>(CloneNotSupportedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> stu;  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;  <br>			  Student stu1 = <span class="hljs-keyword">new</span> Student();  <br>        stu1.setNumber(<span class="hljs-number">12345</span>);  <br>        Student stu2 = (Student)stu1.clone();  <br>          <br>        System.out.println(<span class="hljs-string">"学生1:"</span> + stu1.getNumber());  <br>        System.out.println(<span class="hljs-string">"学生2:"</span> + stu2.getNumber());  <br>          <br>        stu2.setNumber(<span class="hljs-number">54321</span>);  <br>      <br>        System.out.println(<span class="hljs-string">"学生1:"</span> + stu1.getNumber());  <br>        System.out.println(<span class="hljs-string">"学生2:"</span> + stu2.getNumber()); <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">学生<span class="hljs-number">1</span>:<span class="hljs-number">12345</span>  学生<span class="hljs-number">2</span>:<span class="hljs-number">12345</span>  学生<span class="hljs-number">1</span>:<span class="hljs-number">12345</span>  学生<span class="hljs-number">2</span>:<span class="hljs-number">54321</span><br></code></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(stu1 == stu2); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>



<ul>
<li><strong>深克隆：</strong></li>
</ul>
<ol>
<li><p>实现深克隆，可以通过序列化(Serialization)方式来实现。</p>
</li>
<li><p>序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。需要注意的是能够实现序列化的对象其类必须实现Serializable接口，否则无法实现序列化操作。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;  <br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;  <br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;  <br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;  <br><span class="hljs-keyword">import</span> java.io.Serializable;  <br><span class="hljs-comment">//利用序列化来做深复制  </span><br><span class="hljs-comment">//深clone  </span><br>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeepCloneTest</span>  <br></span>&#123;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception  <br>    </span>&#123;  <br>        <span class="hljs-comment">// teacher对象将不被clone出来的Student对象共享.  </span><br>        Teacher teacher = <span class="hljs-keyword">new</span> Teacher();  <br>        teacher.setAge(<span class="hljs-number">40</span>);  <br>        teacher.setName(<span class="hljs-string">"Teacher zhang"</span>);  <br>  <br>        Student student1 = <span class="hljs-keyword">new</span> Student();  <br>        student1.setAge(<span class="hljs-number">20</span>);  <br>        student1.setName(<span class="hljs-string">"zhangsan"</span>);  <br>        student1.setTeacher(teacher);  <br>  <br>        <span class="hljs-comment">// 复制出来一个对象student2  </span><br>        Student student2 = (Student) student1.deepCopy();  <br>        System.out.println(student2.getAge());  <br>        System.out.println(student2.getName());  <br>  <br>        System.out.println(<span class="hljs-string">"~~~~~~~~~~~~~~~~~~~~~~"</span>);  <br>        System.out.println(student1.getTeacher().getAge());  <br>        System.out.println(student1.getTeacher().getName());  <br>  <br>        <span class="hljs-comment">// 修改student2的引用对象  </span><br>        student2.getTeacher().setAge(<span class="hljs-number">50</span>);  <br>        student2.getTeacher().setName(<span class="hljs-string">"Teacher Li"</span>);  <br>  <br>        System.out.println(<span class="hljs-string">"~~~~~~~~~~~~~~~~~~~~~~"</span>);  <br>        System.out.println(student1.getTeacher().getAge());  <br>        System.out.println(student1.getTeacher().getName());  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>  <br></span>&#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">8834559347461591191L</span>;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;  <br>    <span class="hljs-keyword">public</span> String name;  <br>  	... getter(),setter()...<br>&#125;  <br>  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>  <br></span>&#123;  <br>  <br>    <span class="hljs-comment">// serialVersionUID  </span><br>    <span class="hljs-comment">// 如果你的对象序列化后存到硬盘上面后，可是后来你却更改了类的field(增加或减少或改名)，当你</span><br>    <span class="hljs-comment">// 反序列化时，就会出现Exception的，这样就会造成不兼容性的问题。  </span><br>    <span class="hljs-comment">// 但当serialVersionUID相同时，它就会将不一样的field以type的</span><br>    <span class="hljs-comment">// 缺省值赋值(如int型的是0,String型的是null等)，这个可以避开不兼容性的问题。</span><br>    <span class="hljs-comment">// 所以最好给serialVersionUID赋值  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7991552226614088458L</span>;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;  <br>    <span class="hljs-keyword">public</span> String name;  <br>    <span class="hljs-keyword">public</span> Teacher teacher;  <br>  <br>		... getter(),setter()...<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">deepCopy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception  <br>    </span>&#123;  <br>        <span class="hljs-comment">// 将该对象序列化成流,因为写在流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。</span><br>        <span class="hljs-comment">// 所以利用这个特性可以实现对象的深拷贝。  </span><br>        ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();  <br>  <br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);  <br>  <br>        oos.writeObject(<span class="hljs-keyword">this</span>);  <br>  <br>        <span class="hljs-comment">// 将流序列化成对象  </span><br>        ByteArrayInputStream bis = <span class="hljs-keyword">new</span> ByteArrayInputStream(bos.toByteArray());  <br>  <br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis);  <br>  <br>        <span class="hljs-keyword">return</span> ois.readObject();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">20</span>  <span class="hljs-string"></span><br><span class="hljs-attr">zhangsan</span>  <span class="hljs-string"></span><br><span class="hljs-meta">~~~~~~~~~~~~~~~~~~~~~~</span>  <span class="hljs-string"></span><br><span class="hljs-attr">40</span>  <span class="hljs-string"></span><br><span class="hljs-attr">Teacher</span> <span class="hljs-string">zhang  </span><br><span class="hljs-meta">~~~~~~~~~~~~~~~~~~~~~~</span>  <span class="hljs-string"></span><br><span class="hljs-attr">40</span>  <span class="hljs-string"></span><br><span class="hljs-attr">Teacher</span> <span class="hljs-string">zhang</span><br></code></pre></td></tr></table></figure>



<h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><h4 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</h4><p>是值传递。<strong>Java 语言的方法调用只支持参数的值传递</strong>。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</p>
<h4 id="为什么-Java-中只有值传递"><a href="#为什么-Java-中只有值传递" class="headerlink" title="==为什么 Java 中只有值传递=="></a>==为什么 Java 中只有值传递==</h4><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p>
<p><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p>
<ul>
<li>例子1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> num2 = <span class="hljs-number">20</span>;<br><br>    swap(num1, num2);<br><br>    System.out.println(<span class="hljs-string">"num1 = "</span> + num1);<br>    System.out.println(<span class="hljs-string">"num2 = "</span> + num2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> temp = a;<br>    a = b;<br>    b = temp;<br><br>    System.out.println(<span class="hljs-string">"a = "</span> + a);<br>    System.out.println(<span class="hljs-string">"b = "</span> + b);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">a = <span class="hljs-number">20</span> b = <span class="hljs-number">10</span> num1 = <span class="hljs-number">10</span> num2 = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure>

<p>通过上面例子，我们已经知道了<strong>==一个方法不能修改一个基本数据类型的参数==</strong>，而对象引用作为参数就不一样，请看例子2.</p>
<p>解析</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxccp9mgroj30dg0atmxb.jpg" alt="在这里插入图片描述"></p>
<ul>
<li>例子2</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>    change(arr);<br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;<br>    <span class="hljs-comment">// 将数组的第一个元素变为0</span><br>    array[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>

<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>
<p>解析</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxccpqctb7j30fw08nweh.jpg" alt="在这里插入图片描述"></p>
<ul>
<li>例子3</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        Student s1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小张"</span>);<br>        Student s2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小李"</span>);<br>        Test.swap(s1, s2);<br>        System.out.println(<span class="hljs-string">"s1:"</span> + s1.getName());<br>        System.out.println(<span class="hljs-string">"s2:"</span> + s2.getName());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Student x, Student y)</span> </span>&#123;<br>        Student temp = x;<br>        x = y;<br>        y = temp;<br>        System.out.println(<span class="hljs-string">"x:"</span> + x.getName());<br>        System.out.println(<span class="hljs-string">"y:"</span> + y.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x:小李 y:小张 s1:小张 s2:小李<br></code></pre></td></tr></table></figure>

<ul>
<li>解析：</li>
<li>交换之前：</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxccqtrbssj30iv09ogls.jpg" alt="在这里插入图片描述"></p>
<ul>
<li>交换之后：</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxccqsy2inj30iv09ot8w.jpg" alt="在这里插入图片描述"></p>
<p>通过上面两张图可以很清晰的看出：<code>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</code></p>
<h4 id="值传递和引用传递有什么区别"><a href="#值传递和引用传递有什么区别" class="headerlink" title="值传递和引用传递有什么区别"></a>值传递和引用传递有什么区别</h4><ul>
<li>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</li>
<li>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）</li>
</ul>
<h3 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h3><h4 id="JDK-中常用的包有哪些"><a href="#JDK-中常用的包有哪些" class="headerlink" title="JDK 中常用的包有哪些"></a>JDK 中常用的包有哪些</h4><ul>
<li>java.lang：这个是系统的基础类；</li>
<li>java.io：这里面是所有输入输出有关的类，比如文件操作等；</li>
<li>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；</li>
<li>java.net：这里面是与网络有关的类；</li>
<li>java.util：这个是系统辅助类，特别是集合类；</li>
<li>java.sql：这个是数据库操作的类。</li>
</ul>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>详情见 1.2  JavaIO</p>
<h3 id="java-中-IO-流分为几种"><a href="#java-中-IO-流分为几种" class="headerlink" title="java 中 IO 流分为几种?"></a>java 中 IO 流分为几种?</h3><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<blockquote>
<p>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p>
<p>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxce6h0r4jj30k00evwfg.jpg" alt="img"></p>
<h3 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="==BIO,NIO,AIO 有什么区别?=="></a>==BIO,NIO,AIO 有什么区别?==</h3><ul>
<li>简答<ul>
<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li>
</ul>
</li>
</ul>
<h3 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h3><ul>
<li>Files. exists()：检测文件路径是否存在。</li>
<li>Files. createFile()：创建文件。</li>
<li>Files. createDirectory()：创建文件夹。</li>
<li>Files. delete()：删除一个文件或目录。</li>
<li>Files. copy()：复制文件。</li>
<li>Files. move()：移动文件。</li>
<li>Files. size()：查看文件个数。</li>
<li>Files. read()：读取文件。</li>
<li>Files. write()：写入文件。</li>
</ul>
<h2 id="泛型与反射"><a href="#泛型与反射" class="headerlink" title="泛型与反射"></a>泛型与反射</h2><h3 id="Java-的泛型是如何工作的-什么是类型擦除"><a href="#Java-的泛型是如何工作的-什么是类型擦除" class="headerlink" title="Java 的泛型是如何工作的 ? 什么是类型擦除 ?"></a>Java 的泛型是如何工作的 ? 什么是类型擦除 ?</h3><p>泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运⾏时不存在任何类型相关的信息。例如:List<String> 在运行时仅⽤一个 List 来表示。这样做的目的，是确保能和 Java 5 之前的版本开发⼆进制类库进行兼容。</p>
<p>类型擦除:泛型信息只存在于代码编译阶段，在进⼊ JVM 之前，与泛型相关的信息会被擦除掉。在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 &lt; T &gt; 则会被转译成普通的 Object 类型，如果指定了上限如 &lt; T extends String &gt; 则类型参数就被替换成类型上限。</p>
<p><strong>补充</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br></code></pre></td></tr></table></figure>

<p>1、两个 String 其实只有第一个起作用，后⾯一个没什么卵用，只不过 JDK7 才开始⽀支持<code>List&lt;String&gt;list = new ArrayList&lt;&gt;</code> 这种写法。<br>2、第⼀个 String 就是告诉编译器，List 中存储的是 String 对象，也就是起类型检查的作用，之后编译器会擦除泛型占位符，以保证兼容以前的代码。</p>
<h3 id="什么是泛型中的限定通配符和非限定通配符"><a href="#什么是泛型中的限定通配符和非限定通配符" class="headerlink" title="什么是泛型中的限定通配符和非限定通配符 ?"></a>什么是泛型中的限定通配符和非限定通配符 ?</h3><p>限定通配符对类型进行了限制。有两种限定通配符，一种是&lt; ? extends T &gt; 它通过确保类型必须是 T 的子类来设定类型的上界，另一种是&lt; ? super T &gt;它通过确保类型必须是 T 的⽗类来设定类型的下界。泛型类型必须⽤限定内的类型来进行初始化，否则会导致编译错误。另⼀⽅面 &lt; ? &gt; 表示了非限定通配符，因为 &lt; ? &gt; 可以⽤任意类型来替代。</p>
<h3 id="List-lt-extends-T-gt-和-List-lt-super-T-gt-之间有什么区别"><a href="#List-lt-extends-T-gt-和-List-lt-super-T-gt-之间有什么区别" class="headerlink" title="List&lt;? extends T&gt; 和 List &lt;? super T&gt; 之间有什么区别 ?"></a>List&lt;? extends T&gt; 和 List &lt;? super T&gt; 之间有什么区别 ?</h3><p>这两个 List 的声明都是限定通配符的例子，List&lt; ? extends T &gt; 可以接受任何继承⾃ T 的类型的 List，而List &lt; ? super T &gt; 可以接受任何 T 的⽗类构成的 List。例如 List&lt; ? extends Number &gt; 可以接受 List&lt; Integer &gt; 或 List&lt; Float &gt; 。<br>Array 不支持泛型，要⽤List 代替 Array，因为 List 可以提供编译器的类型安全保证，⽽Array却不能。</p>
<h3 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a>什么是反射机制？</h3><ul>
<li>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</li>
<li>静态编译和动态编译<ul>
<li>静态编译：在编译时确定类型，绑定对象</li>
<li>动态编译：运行时确定类型，绑定对象</li>
</ul>
</li>
</ul>
<h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="==反射机制优缺点=="></a>==反射机制优缺点==</h3><ul>
<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>
<li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li>
</ul>
<h3 id="反射机制的应用场景有哪些？"><a href="#反射机制的应用场景有哪些？" class="headerlink" title="反射机制的应用场景有哪些？"></a>反射机制的应用场景有哪些？</h3><ul>
<li><p>反射是框架设计的灵魂。如Spring/Hibernate 动态代理设计模式也采用了反射机制</p>
</li>
<li><p>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。</p>
</li>
</ul>
<blockquote>
<p>Spring 通过 XML 配置模式装载 Bean 的过程：</p>
<p>1) 将程序内所有 XML 或 Properties 配置文件加载入内存中;<br>2) Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;<br>3) 使用反射机制，根据这个字符串获得某个类的Class实例;<br>4) 动态配置实例的属性</p>
</blockquote>
<h3 id="Java获取反射的三种方法"><a href="#Java获取反射的三种方法" class="headerlink" title="Java获取反射的三种方法"></a>Java获取反射的三种方法</h3><p>1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> sex;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> score;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Get</span> </span>&#123;<br>    <span class="hljs-comment">//获取反射机制三种方式</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        <span class="hljs-comment">//方式一(通过建立对象)</span><br>        Student stu = <span class="hljs-keyword">new</span> Student();<br>        Class classobj1 = stu.getClass();<br>        System.out.println(classobj1.getName());<br>        <span class="hljs-comment">//方式二（所在通过路径-相对路径）</span><br>        Class classobj2 = Class.forName(<span class="hljs-string">"fanshe.Student"</span>);<br>        System.out.println(classobj2.getName());<br>        <span class="hljs-comment">//方式三（通过类名）</span><br>        Class classobj3 = Student<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;<br>        System.out.println(classobj3.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Java字符串"><a href="#Java字符串" class="headerlink" title="Java字符串"></a>Java字符串</h2><h3 id="什么是字符串常量池？"><a href="#什么是字符串常量池？" class="headerlink" title="什么是字符串常量池？"></a>什么是字符串常量池？</h3><ul>
<li>字符串常量池位于<strong>堆内存</strong>中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</li>
</ul>
<h3 id="String有哪些特性"><a href="#String有哪些特性" class="headerlink" title="String有哪些特性"></a>String有哪些特性</h3><ul>
<li>不变性：String 是只读字符串，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</li>
<li>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</li>
<li>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li>
</ul>
<h3 id="String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="==String str=”i”与 String str=new String(“i”)一样吗？=="></a>==String str=”i”与 String str=new String(“i”)一样吗？==</h3><ul>
<li>不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</li>
</ul>
<h3 id="String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="String s = new String(“xyz”);创建了几个字符串对象"></a>String s = new String(“xyz”);创建了几个字符串对象</h3><ul>
<li>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</li>
</ul>
<h3 id="如何将字符串反转？"><a href="#如何将字符串反转？" class="headerlink" title="==如何将字符串反转？=="></a>==如何将字符串反转？==</h3><ul>
<li>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// StringBuffer reverse</span><br>StringBuffer stringBuffer = <span class="hljs-keyword">new</span> StringBuffer();<br>stringBuffer.append(<span class="hljs-string">"abcdefg"</span>);<br>System.out.println(stringBuffer.reverse()); <span class="hljs-comment">// gfedcba</span><br><span class="hljs-comment">// StringBuilder reverse</span><br>StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>stringBuilder.append(<span class="hljs-string">"abcdefg"</span>);<br>System.out.println(stringBuilder.reverse()); <span class="hljs-comment">// gfedcba</span><br></code></pre></td></tr></table></figure>

<h3 id="数组有没有-length-方法？String-有没有-length-方法"><a href="#数组有没有-length-方法？String-有没有-length-方法" class="headerlink" title="数组有没有 length()方法？String 有没有 length()方法"></a>数组有没有 length()方法？String 有没有 length()方法</h3><ul>
<li>数组没有 length()方法 ，有 length 的属性。String 有 length()方法。</li>
</ul>
<h3 id="String-类的常用方法都有那些？"><a href="#String-类的常用方法都有那些？" class="headerlink" title="==String 类的常用方法都有那些？=="></a>==String 类的常用方法都有那些？==</h3><ul>
<li>indexOf()：返回指定字符的索引。</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
<h3 id="在使用-HashMap-的时候，用-String-做-key-有什么好处？"><a href="#在使用-HashMap-的时候，用-String-做-key-有什么好处？" class="headerlink" title="在使用 HashMap 的时候，用 String 做 key 有什么好处？"></a>在使用 HashMap 的时候，用 String 做 key 有什么好处？</h3><ul>
<li>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</li>
</ul>
<h3 id="String和StringBuffer、StringBuilder的区别是什么？"><a href="#String和StringBuffer、StringBuilder的区别是什么？" class="headerlink" title="==String和StringBuffer、StringBuilder的区别是什么？=="></a>==String和StringBuffer、StringBuilder的区别是什么？==</h3><table>
<thead>
<tr>
<th>可变性</th>
<th>String 不可变<br />StringBuilder可变<br />StringBuffer可变</th>
</tr>
</thead>
<tbody><tr>
<td>线程安全性</td>
<td>String 安全<br />StringBuilder不安全<br />StringBuffer安全（加了同步锁Synchronized）</td>
</tr>
<tr>
<td>性能</td>
<td>StringBuilder &gt; StringBuffer &gt; String</td>
</tr>
</tbody></table>
<p><strong>对于三者使用的总结</strong></p>
<ul>
<li>如果要操作少量的数据用 = String</li>
<li>单线程操作字符串缓冲区下操作大量数据 = StringBuilder</li>
<li>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</li>
</ul>
<h2 id="Java日期类"><a href="#Java日期类" class="headerlink" title="Java日期类"></a>Java日期类</h2><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><h4 id="java-util-Date"><a href="#java-util-Date" class="headerlink" title="java.util.Date"></a>java.util.Date</h4><ul>
<li>两个构造函数；1. 无参构造。 2.提供毫秒数（时间戳）构造。</li>
<li>包含有年月日时分秒，精确到毫秒级别。从1970-01-01开始的毫秒数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">java.util.Date<br><span class="hljs-comment">// 语句</span><br>Date date = <span class="hljs-keyword">new</span> Date();<br>System.out.println(date);<br><br><span class="hljs-comment">//输出结果</span><br>Sat Feb <span class="hljs-number">03</span> <span class="hljs-number">14</span>:<span class="hljs-number">48</span>:<span class="hljs-number">47</span> CST <span class="hljs-number">2018</span><br></code></pre></td></tr></table></figure>

<ul>
<li>线程不安全</li>
<li>时间比较，before(),after().</li>
</ul>
<h4 id="java-sql-Date"><a href="#java-sql-Date" class="headerlink" title="java.sql.Date"></a>java.sql.Date</h4><ul>
<li>包含年月日，时分秒都被设置为0，之所以这样设计是为了适应SQL中的<code>DATE</code>类型。</li>
<li>注意，虽然说这个类是使用年月日的，但是初始化的时候，需要一个long类型的参数，这个参数代表着January 1, 1970, 00:00:00 GMT到某个时间的毫秒数。如果是当前时间的话，可以用System.currentTimeMillis()或者new Date().getTime()获取。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 语句</span><br>java.sql.Date sqlDate = <span class="hljs-keyword">new</span> java.sql.Date(System.currentTimeMillis());<br>System.out.println(sqlDate);<br><br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-number">2018</span>-<span class="hljs-number">02</span>-<span class="hljs-number">03</span><br></code></pre></td></tr></table></figure>

<h4 id="java-sql-Time"><a href="#java-sql-Time" class="headerlink" title="java.sql.Time"></a>java.sql.Time</h4><ul>
<li>包含时分秒，这个也是为了SQL中的<code>TIME</code>类型而出现的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 语句</span><br>Time time = <span class="hljs-keyword">new</span> Time(System.currentTimeMillis());<br>System.out.println(time);<br><br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-number">15</span>:<span class="hljs-number">07</span>:<span class="hljs-number">35</span><br></code></pre></td></tr></table></figure>

<h4 id="java-sql-Timestamp"><a href="#java-sql-Timestamp" class="headerlink" title="java.sql.Timestamp"></a>java.sql.Timestamp</h4><ul>
<li>时间戳，适配于SQL中的<code>TIMESTAMP</code>类型而出现的，精确到纳秒级别。</li>
</ul>
<h3 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h3><ul>
<li>非线程安全</li>
<li>SimpleDateFormat类：时间转字符串format()，字符串转时间parse()。</li>
<li>保证 SimpleDateFormat 线程安全的方式如下：<ul>
<li>使用 Synchronized，在需要时间格式化的操作使用 Synchronized 关键字进行包装，保证线程堵塞格式化；</li>
<li>手动加锁，把需要格式化时间的代码，写到加锁部分，相对 Synchronized 来说，编码效率更低，性能略好，代码风险较大（风险在于不要忘记在操作的最后，手动释放锁）；</li>
<li>使用 JDK 8 的 DateTimeFormatter 替代 SimpleDateFormat。</li>
</ul>
</li>
</ul>
<h3 id="java-util-Calendar类"><a href="#java-util-Calendar类" class="headerlink" title="java.util.Calendar类"></a>java.util.Calendar类</h3><ul>
<li>日历类，这个类大多被用于获取时间的特殊属性，比如说获取某个时间对象的年份、月份、星期等</li>
</ul>
<h3 id="JDK-8-之前的时间操作"><a href="#JDK-8-之前的时间操作" class="headerlink" title="JDK 8 之前的时间操作"></a><strong>JDK 8 之前的时间操作</strong></h3><p><strong>1 获取时间</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Date date = <span class="hljs-keyword">new</span> Date();<br>System.out.println(date);<br>Calendar calendar = Calendar.getInstance();<br>Date time = calendar.getTime();<br>System.out.println(time);<br></code></pre></td></tr></table></figure>

<p><strong>2 获取时间戳</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> ts = <span class="hljs-keyword">new</span> Date().getTime();<br>System.out.println(ts);<br><span class="hljs-keyword">long</span> ts2 = System.currentTimeMillis();<br>System.out.println(ts2);<br><span class="hljs-keyword">long</span> ts3 = Calendar.getInstance().getTimeInMillis();<br>System.out.println(ts3);<br></code></pre></td></tr></table></figure>

<p><strong>3 格式化时间</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">SimpleDateFormat sf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);<br>System.out.println(sf.format(<span class="hljs-keyword">new</span> Date()));  <span class="hljs-comment">// output:2019-08-16 21:46:22</span><br></code></pre></td></tr></table></figure>

<p><strong>4 时间转换</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">SimpleDateFormat sf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);<br><span class="hljs-comment">// String 转 Date</span><br>String str = <span class="hljs-string">"2019-10-10 10:10:10"</span>;<br>System.out.println(sf.parse(str));<br><span class="hljs-comment">//时间戳的字符串 转 DateString ts</span><br>String = <span class="hljs-string">"1556788591462"</span>;<br><span class="hljs-comment">// import java.sql</span><br>Timestamp ts = <span class="hljs-keyword">new</span> Timestamp(Long.parseLong(tsString)); <span class="hljs-comment">// 时间戳的字符串转 Date</span><br>System.out.println(sf.format(ts));<br></code></pre></td></tr></table></figure>

<p><strong>5 获得昨天此刻时间</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Calendar calendar = Calendar.getInstance();<br>calendar.add(Calendar.DATE, -<span class="hljs-number">1</span>);<br>System.out.println(calendar.getTime());<br></code></pre></td></tr></table></figure>



<h3 id="Instant时间戳（Java-8，线程安全）"><a href="#Instant时间戳（Java-8，线程安全）" class="headerlink" title="Instant时间戳（Java 8，线程安全）"></a>Instant时间戳（Java 8，线程安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> milli = Instant.now().toEpochMilli(); <span class="hljs-comment">// 获取当前时间戳（精确到毫秒）</span><br><span class="hljs-keyword">long</span> second = Instant.now().getEpochSecond(); <span class="hljs-comment">// 获取当前时间戳（精确到秒）</span><br>System.out.println(milli);  <span class="hljs-comment">// output:1565932435792</span><br>System.out.println(second); <span class="hljs-comment">// output:1565932435</span><br></code></pre></td></tr></table></figure>

<p><code>Instant</code>类一般不单独使用，比较常见的用法就是在新老日期键进行转换。Java 8为旧日期类型全部添加了<code>toInstant()</code>方法，可以将日期转换为<code>Instant</code>实例，然后将<code>Instant</code>实例转换为新日期类型。反过来也是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//旧日期转换为新日期</span><br>Date date = <span class="hljs-keyword">new</span> Date();<br>LocalDateTime dateTime = LocalDateTime.ofInstant(date.toInstant(), ZoneId.of(<span class="hljs-string">"Asia/Shanghai"</span>));<br>System.out.println(dateTime);<br><span class="hljs-comment">//新日期转换为旧日期</span><br>Date now = Date.from(Instant.now());<br>System.out.println(now);<br></code></pre></td></tr></table></figure>

<h3 id="java-time-LocalDate（Java-8，线程安全）"><a href="#java-time-LocalDate（Java-8，线程安全）" class="headerlink" title="java.time.LocalDate（Java 8，线程安全）"></a>java.time.LocalDate（Java 8，线程安全）</h3><ul>
<li>只包含日期，不包含时间，不可变类，且线程安全。</li>
<li>经常被用于展示<code>year-month-day,day-of-year,day-of-week,week-of-year</code>等格式的信息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDate localDate = LocalDate.now();<br><span class="hljs-comment">// 获取当天是几号</span><br><span class="hljs-keyword">int</span> dayOfMonth = localDate.getDayOfMonth();<br><span class="hljs-comment">// 获取当天是星期几</span><br>DayOfWeek dayOfWeek = localDate.getDayOfWeek();<br><span class="hljs-comment">// 获取本月的第一天</span><br>LocalDate firstDayOfMonth = localDate.with(TemporalAdjusters.firstDayOfMonth());<br><span class="hljs-comment">// 取本月最后一天</span><br>LocalDate lastDayOfThisMonth = localDate.with(TemporalAdjusters.lastDayOfMonth());<br></code></pre></td></tr></table></figure>

<h3 id="java-time-LocalTime（Java-8，线程安全）"><a href="#java-time-LocalTime（Java-8，线程安全）" class="headerlink" title="java.time.LocalTime（Java 8，线程安全）"></a>java.time.LocalTime（Java 8，线程安全）</h3><ul>
<li>只包含时间，不包含日期，不可变类，且线程安全。</li>
<li>常被用于展示<code>hour-minute-second</code>格式的信息。可以对时间进行加减等操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 样例</span><br>LocalTime localTime = LocalTime.now();<br><span class="hljs-comment">// 获取当前的小时</span><br><span class="hljs-keyword">int</span> hour = localTime.getHour();<br>System.out.println(hour);<br><span class="hljs-comment">// 小时数加1</span><br>LocalTime addTwoHours = localTime.plusHours(<span class="hljs-number">2L</span>);<br>System.out.println(addTwoHours.getHour());<br><br><span class="hljs-comment">// 结果</span><br><span class="hljs-number">16</span><br><span class="hljs-number">18</span><br></code></pre></td></tr></table></figure>

<h3 id="java-time-LocalDateTime（Java-8，线程安全）"><a href="#java-time-LocalDateTime（Java-8，线程安全）" class="headerlink" title="java.time.LocalDateTime（Java 8，线程安全）"></a>java.time.LocalDateTime（Java 8，线程安全）</h3><ul>
<li>既包含了时间又包含了日期，精确到纳秒级别，不可变类，且线程安全。</li>
<li>操作时间中的年月日时分秒并且可以获取其中的属性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDateTime localDateTime = LocalDateTime.now();<br><span class="hljs-comment">// 获取年</span><br><span class="hljs-keyword">int</span> year = localDateTime.getYear();<br><span class="hljs-comment">// 获取小时</span><br><span class="hljs-keyword">int</span> hour = localDateTime.getHour();<br><span class="hljs-comment">// 增加一年</span><br>LocalDateTime addOneYear = localDateTime.plusYears(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<h3 id="DateTimeFormatter类"><a href="#DateTimeFormatter类" class="headerlink" title="DateTimeFormatter类"></a>DateTimeFormatter类</h3><p><strong>时间格式化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 时间格式化①</span><br>DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);<br>String timeFormat = dateTimeFormatter.format(LocalDateTime.now());<br>System.out.println(timeFormat);  <span class="hljs-comment">// output:2019-08-16 21:15:43</span><br><span class="hljs-comment">// 时间格式化②</span><br>String timeFormat2 = LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>));<br>System.out.println(timeFormat2);    <span class="hljs-comment">// output:2019-08-16 21:17:48</span><br></code></pre></td></tr></table></figure>

<p><strong>时间转换</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String timeStr = <span class="hljs-string">"2019-10-10 06:06:06"</span>;<br>LocalDateTime dateTime = LocalDateTime.parse(timeStr,DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>));<br>System.out.println(dateTime);<br></code></pre></td></tr></table></figure>

<h3 id="如何优雅地计算两个时间的相隔时间？"><a href="#如何优雅地计算两个时间的相隔时间？" class="headerlink" title="如何优雅地计算两个时间的相隔时间？"></a><strong>如何优雅地计算两个时间的相隔时间？</strong></h3><p>答：JDK 8 中可以使用 Duration 类来优雅地计算两个时间的相隔时间，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDateTime dt1 = LocalDateTime.now();<br>LocalDateTime dt2 = dt1.plusSeconds(<span class="hljs-number">60</span>);<br>Duration duration = Duration.between(dt1, dt2);<br>System.out.println(duration.getSeconds());  <span class="hljs-comment">// output:60</span><br></code></pre></td></tr></table></figure>

<h3 id="如何优雅地计算两个日期的相隔日期？"><a href="#如何优雅地计算两个日期的相隔日期？" class="headerlink" title="如何优雅地计算两个日期的相隔日期？"></a><strong>如何优雅地计算两个日期的相隔日期？</strong></h3><p>答：JDK 8 中可以使用 Period 类来优雅地计算两个日期的相隔日期，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDate d1 = LocalDate.now();<br>LocalDate d2 = d1.plusDays(<span class="hljs-number">2</span>);<br>Period period = Period.between(d1, d2);<br>System.out.println(period.getDays());   <span class="hljs-comment">//output:2</span><br></code></pre></td></tr></table></figure>

<h3 id="如何比较两个时间（Date）的大小？"><a href="#如何比较两个时间（Date）的大小？" class="headerlink" title="如何比较两个时间（Date）的大小？"></a><strong>如何比较两个时间（Date）的大小？</strong></h3><p>时间比较有以下三种方式：</p>
<ul>
<li>获取两个时间的时间戳，得到两个 long 类型的变量，两个变量相减，通过结果的正负值来判断大小；</li>
<li>通过 Date 自带的 before()、after()、equals() 等方法比较，代码示例 date1.before(date2)；</li>
<li>通过 compareTo() 方法比较，代码示例：date1.compareTo(date2)，返回值 -1 表示前一个时间比后一个时间小，0 表示两个时间相等，1 表示前一个时间大于后一个时间。</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Shang Liang Liang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2021/12/21/Java%E9%9D%A2%E8%AF%95/1.0%20Java%E5%9F%BA%E7%A1%80/">http://yoursite.com/2021/12/21/Java%E9%9D%A2%E8%AF%95/1.0%20Java%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">Shang Liang Liang's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://source.unsplash.com/random/800*600" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2021/12/08/Java%E9%9D%A2%E8%AF%95/Redis/"><img class="next_cover" src="https://tva1.sinaimg.cn/large/008i3skNly1gx6apfw4m6j31900u0jsp.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="disqus_thread"></div><script>var disqus_config = function () {
  this.page.url = 'http://yoursite.com/2021/12/21/Java%E9%9D%A2%E8%AF%95/1.0%20Java%E5%9F%BA%E7%A1%80/';
  this.page.identifier = '2021/12/21/Java面试/1.0 Java基础/';
  this.page.title = 'Java基础';
};
(function() { 
  var d = document, s = d.createElement('script');
  s.src = 'https://jackshang.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();
</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By Shang Liang Liang</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script><script>if (document.getElementsByClassName('mermaid').length) {
  loadScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js',function () {
    mermaid.initialize({
      theme: 'default',
  })
})
}</script></body></html>