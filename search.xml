<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>8.2.哈希冲突与解决(拉链法,线性探测法)</title>
      <link href="/2021/11/22/8.2.%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E4%B8%8E%E8%A7%A3%E5%86%B3(%E6%8B%89%E9%93%BE%E6%B3%95,%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95)/"/>
      <url>/2021/11/22/8.2.%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E4%B8%8E%E8%A7%A3%E5%86%B3(%E6%8B%89%E9%93%BE%E6%B3%95,%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95)/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希冲突与解决-拉链法-线性探测法"><a href="#哈希冲突与解决-拉链法-线性探测法" class="headerlink" title="哈希冲突与解决(拉链法,线性探测法)"></a>哈希冲突与解决(拉链法,线性探测法)</h1><p>参考：<a href="https://blog.csdn.net/u012124438/article/details/78230478" target="_blank" rel="noopener">https://blog.csdn.net/u012124438/article/details/78230478</a></p><h2 id="1-线性探测-vs-拉链法"><a href="#1-线性探测-vs-拉链法" class="headerlink" title="1. 线性探测 vs 拉链法"></a>1. 线性探测 vs 拉链法</h2><p>开放寻址法和链表法。这两种冲突解决办法在实际的软件开发中都非常常用。比如，LinkedHashMap 就采用了链表法解决冲突，ThreadLocalMap 是通过线性探测的开放寻址法来解决冲突。那你知道，这两种冲突解决方法各有什么优势和劣势，又各自适用哪些场景吗？</p><p><strong>（1）开放寻址法优缺点</strong></p><ul><li>开放寻址法优点：<ul><li>散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。</li><li>数组实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没那么容易。你可不要小看序列化，很多场合都会用到的。</li></ul></li><li>开放寻址法缺点：<ul><li>用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。</li><li>在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。</li><li>装载因子的上限不能太大，导致这种方法比链表法更浪费内存空间。</li></ul></li></ul><p><strong>总结：</strong> <strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法。</strong>这也是 ThreadLocalMap 使用开放寻址法解决散列冲突的原因。</p><p><strong>（2）拉链法优缺点</strong></p><ul><li>拉链法优点：<ul><li>首先，链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。</li><li>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</li><li>可以将链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。</li></ul></li><li>拉链法缺点：<ul><li>链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。但如果我们存储的是大对象，此时存储对象远远大于指针大小（4 byte 或 8 byte），那链表中指针的内存消耗在大对象面前就可以忽略了。</li><li>因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。</li></ul></li></ul><p><strong>总结：</strong> <strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表。</strong>而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.1.哈希表(散列表)</title>
      <link href="/2021/11/22/8.1.%E5%93%88%E5%B8%8C%E8%A1%A8(%E6%95%A3%E5%88%97%E8%A1%A8)/"/>
      <url>/2021/11/22/8.1.%E5%93%88%E5%B8%8C%E8%A1%A8(%E6%95%A3%E5%88%97%E8%A1%A8)/</url>
      
        <content type="html"><![CDATA[<h1 id="散列表-哈希表"><a href="#散列表-哈希表" class="headerlink" title="散列表(哈希表)"></a><strong>散列表(哈希表)</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>散列表也叫哈希表，是一种通过键值对直接访问数据的机构。<strong>借助散列函数对数组进行扩展，利用的是数组支持按照下标随机访问元素的特性。</strong>散列表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。散列函数有 MD5、SHA、CRC 等哈希算法。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmuu8vpaxj31200eodh1.jpg" alt="image-20211121163245049"></p><p>散列表的实现最关键的就是散列函数的定义和选择。</p><h2 id="2-散列函数"><a href="#2-散列函数" class="headerlink" title="2. 散列函数"></a>2. 散列函数</h2><p>什么才是好的散列函数：</p><ul><li><strong>散列函数的设计不能太复杂</strong>。过于复杂的散列函数，势必会占用更多 CPU，也就间接的影响到散列表的性能。</li><li><strong>散列函数生成的值要尽可能随机并且均匀分布</strong>。这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</li></ul><p><strong>一般常用的有以下几种散列函数：</strong></p><h3 id="2-1-直接定址法"><a href="#2-1-直接定址法" class="headerlink" title="2.1 直接定址法"></a>2.1 直接定址法</h3><blockquote><p>取关键字或关键字的某个线性函数值为散列地址。</p><p>关键码本身和地址之间存在某个线性函数关系时，散列函数取为关键码的线性函数，即：<code>hash(key) = a * key + b</code>（a、b 均为常数）。</p><p>这样的散列函数优点就是简单、均匀，也不会产生冲突，但问题是这需要事先知道关键字的分布情况，适合査找表较小且连续的情况。由于这样的限制，<strong>在现实应用中虽然简单，但却并不常用</strong>。</p></blockquote><h3 id="2-2-余数法"><a href="#2-2-余数法" class="headerlink" title="2.2 余数法"></a>2.2 <strong>余数法</strong></h3><blockquote><p>通过选择适当的正整数 p，按计算公式 <code>hash(K) = K % p</code> 来计算关键码 K 的散列地址。这种方法计算最简单，也不需根据全部关键码的分布情况研究如何从中析取数据，<strong>最常用</strong>。这种方式也可以在用过其他方法后再使用。该函数对 p 的选择很重要，一般取素数或者直接用 n。</p></blockquote><h3 id="2-3-平方取中法"><a href="#2-3-平方取中法" class="headerlink" title="2.3 平方取中法"></a>2.3 平方取中法</h3><blockquote><p>当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</p><p>将关键码 K 平方，取 K^2 中间几位作为其散列地址 hash(K) 的值。</p><p>假如有以下关键字序列 {421，423，436}，平方之后的结果为 {177241，178929，190096}，那么可以取 {72，89，00} 作为 Hash 地址。</p></blockquote><h3 id="2-4-随机数法"><a href="#2-4-随机数法" class="headerlink" title="2.4 随机数法"></a>2.4 随机数法</h3><blockquote><p>采用随机函数作为散列函数 <code>hash(Key) = random(Key)</code>，其中 random 为随机函数。<strong>当关键码长度不等时，采用该方法较恰当。</strong></p></blockquote><h3 id="2-5-数字分析法："><a href="#2-5-数字分析法：" class="headerlink" title="2.5 数字分析法："></a><strong>2.5 数字分析法</strong>：</h3><blockquote><p>通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。 </p></blockquote><h2 id="3-散列冲突"><a href="#3-散列冲突" class="headerlink" title="3. 散列冲突"></a><strong>3. 散列冲突</strong></h2><p>确定好散列函数之后，通过某个<code>key</code>值的确会得到一个唯一的<code>value</code>地址。但是却会出现一些特殊情况。<strong>即通过不同的<code>key</code>值可能会访问到同一个地址，这个现象称之为冲突。</strong></p><p>冲突在发生之后，当在对不同的<code>key</code>值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。</p><p>常用的冲突处理方式有很多，常用的包括以下几种：</p><h3 id="3-1-开放地址法（也叫开放寻址法）："><a href="#3-1-开放地址法（也叫开放寻址法）：" class="headerlink" title="3.1 开放地址法（也叫开放寻址法）："></a><strong>3.1 开放地址法</strong>（也叫开放寻址法）：</h3><p>如果出现了散列冲突，就重新探测一个空闲位置。根据重新探测的方式，又可以分为线性探测、二次探测、双重哈希三种。</p><ul><li><strong>线性探测(Linear Probing)</strong>：从发生冲突位置依次往后查找空闲位置。线性探测会导致数据集中到某一块区域。</li><li><strong>二次探测(Quadratic probing)</strong>：如果说线性探测每次探测的步长是 1，即线性探测的下标序列就是 hash(key) + 0，hash(key) + 1，hash(key) + 2……。而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key) + 02，hash(key) + 12，hash(key) + 22……。</li><li><strong>双重哈希(Double hashing)</strong>：前面的两种探测方式都只使用一个散列函数，而双重哈希则会使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。这种方式的缺点是时间增加了。 </li></ul><h3 id="3-2-链地址法："><a href="#3-2-链地址法：" class="headerlink" title="3.2 链地址法："></a><strong>3.2 链地址法</strong>：</h3><p>链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。使用链表将所有散列值相同的元素我们都放到相同槽位对应的链表中。当然，这个链表可能为简单链表，也可能是红黑树，如 HahMap。</p><p>==<strong>目前比较常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的</strong>==。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmuussdnij314k0l640l.jpg" alt="image-20211121163316703"></p><p>左侧数组的每个成员包括一个指针，指向一个链表的头。每发生一个冲突的数据，就将该数据作为链表的节点链接到链表尾部。这样一来，就可以保证冲突的数据能够区分并顺利访问。</p><p>考虑到链表过长造成的问题，还可以<strong>使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性</strong>。</p><h3 id="3-3-公共溢出区："><a href="#3-3-公共溢出区：" class="headerlink" title="3.3 公共溢出区："></a><strong>3.3 公共溢出区</strong>：</h3><p>这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。很少用。</p><p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子来表示空位的多少。<strong>装载因子（load factor）</strong>的计算公式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">散列表的装载因子 &#x3D; 表中的元素个数 &#x2F; 散列表的长度<br></code></pre></td></tr></table></figure><p>实例参考： <a href="https://www.jianshu.com/p/a89e9487a06c" target="_blank" rel="noopener">https://www.jianshu.com/p/a89e9487a06c</a></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.6.图的最短路径(Djkstra, Floyd)</title>
      <link href="/2021/11/22/7.6.%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(Djkstra,%20Floyd)/"/>
      <url>/2021/11/22/7.6.%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(Djkstra,%20Floyd)/</url>
      
        <content type="html"><![CDATA[<h1 id="最短路径-Djkstra-Floyd"><a href="#最短路径-Djkstra-Floyd" class="headerlink" title="最短路径(Djkstra, Floyd)"></a>最短路径(Djkstra, Floyd)</h1><h2 id="迪杰斯特拉算法介绍"><a href="#迪杰斯特拉算法介绍" class="headerlink" title="迪杰斯特拉算法介绍"></a><strong>迪杰斯特拉算法介绍</strong></h2><p>Dijkstra算法功能：给出<strong>加权连通图</strong>中一个顶点，称之为起点，找出起点到其它所有顶点之间的最短距离。</p><p>它的主要特点是以起始点为中心向外层层扩展(BFS广度优先搜索思想)，直到扩展到终点为止。</p><p><strong>基本思想</strong></p><p>   通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。</p><p>   此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。</p><p>   初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。</p><p><strong>操作步骤</strong></p><p><strong>(1)</strong> 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。</p><p><strong>(2)</strong> 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。</p><p><strong>(3)</strong> 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。</p><p><strong>(4)</strong> 重复步骤(2)和(3)，直到遍历完所有顶点。</p><p>单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。</p><h2 id="迪杰斯特拉算法图解"><a href="#迪杰斯特拉算法图解" class="headerlink" title="迪杰斯特拉算法图解"></a><strong>迪杰斯特拉算法图解</strong></h2><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/dijkstra/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwo7enm7kmj30aj07et8v.jpg" alt="img"></a></p><p>以上图G4为例，来对迪杰斯特拉进行算法演示(以第4个顶点D为起点)。(B的权重有错误)</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/dijkstra/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwo7eo046pj30jz184jw8.jpg" alt="img"></a></p><p><strong>初始状态</strong>：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！<br><strong>第1步</strong>：将顶点D加入到S中。<br>  此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。   注:C(3)表示C到起点D的距离是3。</p><p><strong>第2步</strong>：将顶点C加入到S中。<br>  上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。<br>  此时，S={D(0),C(3)}, U={A(∞),B(23),E(4),F(9),G(∞)}。</p><p><strong>第3步</strong>：将顶点E加入到S中。<br>  上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。<br>  此时，S={D(0),C(3),E(4)}, U={A(∞),B(23),F(6),G(12)}。</p><p><strong>第4步</strong>：将顶点F加入到S中。<br>  此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。</p><p><strong>第5步</strong>：将顶点G加入到S中。<br>  此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。</p><p><strong>第6步</strong>：将顶点B加入到S中。<br>  此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。</p><p><strong>第7步</strong>：将顶点A加入到S中。<br>  此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。</p><p>此时，起点D到各个顶点的最短距离就计算出来了：<strong>A(22) B(13) C(3) D(0) E(4) F(6) G(12)</strong>。</p><h2 id="迪杰斯特拉算法的代码说明"><a href="#迪杰斯特拉算法的代码说明" class="headerlink" title="迪杰斯特拉算法的代码说明"></a><strong>迪杰斯特拉算法的代码说明</strong></h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mEdgNum;        <span class="hljs-comment">// 边的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = Integer.MAX_VALUE;   <span class="hljs-comment">// 最大值</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-迪杰斯特拉算法"><a href="#2-迪杰斯特拉算法" class="headerlink" title="2. 迪杰斯特拉算法"></a><strong>2. 迪杰斯特拉算法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * Dijkstra最短路径。<br> * 即，统计图中"顶点vs"到其它各个顶点的最短路径。<br> *<br> * 参数说明：<br> *       vs -- 起始顶点(start vertex)。即计算"顶点vs"到其它顶点的最短路径。<br> *     prev -- 前驱顶点数组。即，prev[i]的值是"顶点vs"到"顶点i"的最短路径所经历的全部顶点中，位于"顶点i"之前的那个顶点。<br> *     dist -- 长度数组。即，dist[i]是"顶点vs"到"顶点i"的最短路径的长度。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vs, <span class="hljs-keyword">int</span>[] prev, <span class="hljs-keyword">int</span>[] dist)</span> </span>&#123;<br>    <span class="hljs-comment">// flag[i]=true表示"顶点vs"到"顶点i"的最短路径已成功获取</span><br>    <span class="hljs-keyword">boolean</span>[] flag = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[mVexs.length];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        flag[i] = <span class="hljs-keyword">false</span>;          <span class="hljs-comment">// 顶点i的最短路径还没获取到。</span><br>        prev[i] = <span class="hljs-number">0</span>;              <span class="hljs-comment">// 顶点i的前驱顶点为0。</span><br>        dist[i] = mMatrix[vs][i];  <span class="hljs-comment">// 顶点i的最短路径为"顶点vs"到"顶点i"的权。</span><br>    &#125;<br><br>    <span class="hljs-comment">// 对"顶点vs"自身进行初始化</span><br>    flag[vs] = <span class="hljs-keyword">true</span>;<br>    dist[vs] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 遍历mVexs.length-1次；每次找出一个顶点的最短路径。</span><br>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; mVexs.length; i++) &#123;<br>        <span class="hljs-comment">// 寻找当前最小的路径；</span><br>        <span class="hljs-comment">// 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。</span><br>        <span class="hljs-keyword">int</span> min = INF;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (flag[j]==<span class="hljs-keyword">false</span> &amp;&amp; dist[j]&lt;min) &#123;<br>                min = dist[j];<br>                k = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 标记"顶点k"为已经获取到最短路径</span><br>        flag[k] = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// 修正当前最短路径和前驱顶点</span><br>        <span class="hljs-comment">// 即，当已经"顶点k的最短路径"之后，更新"未获取最短路径的顶点的最短路径和前驱顶点"。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++) &#123;<br>            <span class="hljs-keyword">int</span> tmp = (mMatrix[k][j]==INF ? INF : (min + mMatrix[k][j]));<br>            <span class="hljs-keyword">if</span> (flag[j]==<span class="hljs-keyword">false</span> &amp;&amp; (tmp&lt;dist[j]) ) &#123;<br>                dist[j] = tmp;<br>                prev[j] = k;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印dijkstra最短路径的结果</span><br>    System.out.printf(<span class="hljs-string">"dijkstra(%c): \n"</span>, mVexs[vs]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; mVexs.length; i++)<br>        System.out.printf(<span class="hljs-string">"  shortest(%c, %c)=%d\n"</span>, mVexs[vs], mVexs[i], dist[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="弗洛伊德算法介绍"><a href="#弗洛伊德算法介绍" class="headerlink" title="弗洛伊德算法介绍"></a><strong>弗洛伊德算法介绍</strong></h2><p><strong>基本思想</strong></p><p>   通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入一个矩阵S，矩阵S中的元素a[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。</p><p>   假设图G中顶点个数为N，则需要对矩阵S进行N次更新。初始时，矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。 接下来开始，对矩阵S进行N次更新。第1次更新时，如果”a[i][j]的距离” &gt; “a[i][0]+a[0][j]”(a[i][0]+a[0][j]表示”i与j之间经过第1个顶点的距离”)，则更新a[i][j]为”a[i][0]+a[0][j]”。 同理，第k次更新时，如果”a[i][j]的距离” &gt; “a[i][k]+a[k][j]”，则更新a[i][j]为”a[i][k]+a[k][j]”。更新N次之后，操作完成！</p><p>   单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。</p><p>   <strong>与Djkstra比较：</strong>最后的邻接矩阵包含以任意顶点喂起点的最短路径。</p><h2 id="弗洛伊德算法图解"><a href="#弗洛伊德算法图解" class="headerlink" title="弗洛伊德算法图解"></a><strong>弗洛伊德算法图解</strong></h2><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/floyd/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwo7sofmklj30rc08fmy6.jpg" alt="img"></a></p><p>以上图G4为例，来对弗洛伊德进行算法演示。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/floyd/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwo7sqfkq5j30rv1r17d3.jpg" alt="img"></a></p><p><strong>初始状态</strong>：S是记录各个顶点间最短路径的矩阵。<br><strong>第1步</strong>：初始化S。<br>  矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。实际上，就是将图的原始矩阵复制到S中。<br>  注:a[i][j]表示矩阵S中顶点i(第i个顶点)到顶点j(第j个顶点)的距离。</p><p><strong>第2步</strong>：以顶点A(第1个顶点)为中介点，若a[i][j] &gt; a[i][0]+a[0][j]，则设置a[i][j]=a[i][0]+a[0][j]。<br>  以顶点a[1]<a href="http://i.cnblogs.com/即顶点B和顶点G之间的距离为例" target="_blank" rel="noopener">6</a>，上一步操作之后，a[1][6]=∞；而将A作为中介点时，(B,A)=12，(A,G)=14，因此B和G之间的距离可以更新为26。</p><p>同理，依次将顶点B,C,D,E,F,G作为中介点，并更新a[i][j]的大小。</p><h2 id="弗洛伊德算法的代码说明"><a href="#弗洛伊德算法的代码说明" class="headerlink" title="弗洛伊德算法的代码说明"></a><strong>弗洛伊德算法的代码说明</strong></h2><h3 id="1-基本定义-1"><a href="#1-基本定义-1" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mEdgNum;        <span class="hljs-comment">// 边的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = Integer.MAX_VALUE;   <span class="hljs-comment">// 最大值</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-弗洛伊德算法"><a href="#2-弗洛伊德算法" class="headerlink" title="2. 弗洛伊德算法"></a><strong>2. 弗洛伊德算法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * floyd最短路径。<br> * 即，统计图中各个顶点间的最短路径。<br> *<br> * 参数说明：<br> *     path -- 路径。path[i][j]=k表示，"顶点i"到"顶点j"的最短路径会经过顶点k。<br> *     dist -- 长度数组。即，dist[i][j]=sum表示，"顶点i"到"顶点j"的最短路径的长度是sum。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] path, <span class="hljs-keyword">int</span>[][] dist)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++) &#123;<br>            dist[i][j] = mMatrix[i][j];    <span class="hljs-comment">// "顶点i"到"顶点j"的路径长度为"i到j的权值"。</span><br>            path[i][j] = j;                <span class="hljs-comment">// "顶点i"到"顶点j"的最短路径是经过顶点j。</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算最短路径</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; mVexs.length; k++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++) &#123;<br><br>                <span class="hljs-comment">// 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]和path[i][j]</span><br>                <span class="hljs-keyword">int</span> tmp = (dist[i][k]==INF || dist[k][j]==INF) ? INF : (dist[i][k] + dist[k][j]);<br>                <span class="hljs-keyword">if</span> (dist[i][j] &gt; tmp) &#123;<br>                    <span class="hljs-comment">// "i到j最短路径"对应的值设，为更小的一个(即经过k)</span><br>                    dist[i][j] = tmp;<br>                    <span class="hljs-comment">// "i到j最短路径"对应的路径，经过k</span><br>                    path[i][j] = path[i][k];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印floyd最短路径的结果</span><br>    System.out.printf(<span class="hljs-string">"floyd: \n"</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++)<br>            System.out.printf(<span class="hljs-string">"%2d  "</span>, dist[i][j]);<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.5.图的最小生成树(Prime, Kruskal)</title>
      <link href="/2021/11/22/7.5.%E5%9B%BE%E7%9A%84%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91(Prime,%20Kruskal)/"/>
      <url>/2021/11/22/7.5.%E5%9B%BE%E7%9A%84%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91(Prime,%20Kruskal)/</url>
      
        <content type="html"><![CDATA[<h1 id="最小生成树-Prime-Kruskal"><a href="#最小生成树-Prime-Kruskal" class="headerlink" title="最小生成树(Prime, Kruskal)"></a>最小生成树(Prime, Kruskal)</h1><h2 id="最小生成树概念"><a href="#最小生成树概念" class="headerlink" title="最小生成树概念"></a><strong>最小生成树概念</strong></h2><p>在含有n个顶点的连通图中选择n-1条边，构成一棵极小连通子图，并使该连通子图中n-1条边上权值之和达到最小，则称其为连通网的最小生成树。<br><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn1aw8x2lj30aj07et8v.jpg" alt="img"></a></p><p>例如，对于如上图G4所示的连通网可以有多棵权值总和不相同的生成树。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn1awqlhsj30vj07et9l.jpg" alt="img"></a></p><h1 id="克鲁斯卡尔-Kruskal-算法"><a href="#克鲁斯卡尔-Kruskal-算法" class="headerlink" title="克鲁斯卡尔(Kruskal)算法"></a><strong>克鲁斯卡尔(Kruskal)算法</strong></h1><p>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。</p><p><strong>基本思想</strong>：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。<br><strong>具体做法</strong>：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。</p><h2 id="克鲁斯卡尔算法图解"><a href="#克鲁斯卡尔算法图解" class="headerlink" title="克鲁斯卡尔算法图解"></a><strong>克鲁斯卡尔算法图解</strong></h2><p>以上图G4为例，来对克鲁斯卡尔进行演示(假设，用数组R保存最小生成树结果)。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/03.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn1rekeu5j30do11u0vb.jpg" alt="img"></a></p><p><strong>第1步</strong>：将边&lt;E,F&gt;加入R中。<br>  边&lt;E,F&gt;的权值最小，因此将它加入到最小生成树结果R中。<br><strong>第2步</strong>：将边&lt;C,D&gt;加入R中。<br>  上一步操作之后，边&lt;C,D&gt;的权值最小，因此将它加入到最小生成树结果R中。<br><strong>第3步</strong>：将边&lt;D,E&gt;加入R中。<br>  上一步操作之后，边&lt;D,E&gt;的权值最小，因此将它加入到最小生成树结果R中。<br><strong>第4步</strong>：将边&lt;B,F&gt;加入R中。<br>  上一步操作之后，边&lt;C,E&gt;的权值最小，但&lt;C,E&gt;会和已有的边构成回路；因此，跳过边&lt;C,E&gt;。同理，跳过边&lt;C,F&gt;。将边&lt;B,F&gt;加入到最小生成树结果R中。<br><strong>第5步</strong>：将边&lt;E,G&gt;加入R中。<br>  上一步操作之后，边&lt;E,G&gt;的权值最小，因此将它加入到最小生成树结果R中。<br><strong>第6步</strong>：将边&lt;A,B&gt;加入R中。<br>  上一步操作之后，边&lt;F,G&gt;的权值最小，但&lt;F,G&gt;会和已有的边构成回路；因此，跳过边&lt;F,G&gt;。同理，跳过边&lt;B,C&gt;。将边&lt;A,B&gt;加入到最小生成树结果R中。</p><p>此时，最小生成树构造完成！它包括的边依次是：<strong>&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;</strong>。</p><h2 id="克鲁斯卡尔算法分析"><a href="#克鲁斯卡尔算法分析" class="headerlink" title="克鲁斯卡尔算法分析"></a><strong>克鲁斯卡尔算法分析</strong></h2><p>根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题：<br><strong>问题一</strong> 对图的所有边按照权值大小进行排序。<br><strong>问题二</strong> 将边添加到最小生成树中时，怎么样判断是否形成了回路。</p><p>问题一很好解决，采用排序算法进行排序即可。</p><p>问题二处理方式是：<strong>==记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”(<em>关于这一点，后面会通过图片给出说明</em>)。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。==</strong> 以下图来进行说明：</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/04.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn1y7epmpj30aj06c74g.jpg" alt="img"></a></p><p>在将&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt;加入到最小生成树R中之后，这几条边的顶点就都有了终点：</p><blockquote><p><strong>(01)</strong> C的终点是F。<br><strong>(02)</strong> D的终点是F。<br><strong>(03)</strong> E的终点是F。<br><strong>(04)</strong> F的终点是F。</p></blockquote><p>关于终点，就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是”与它连通的最大顶点”。 因此，接下来，虽然&lt;C,E&gt;是权值最小的边。但是C和E的重点都是F，即它们的终点相同，因此，将&lt;C,E&gt;加入最小生成树的话，会形成回路。这就是判断回路的方式。</p><h2 id="克鲁斯卡尔算法的代码说明"><a href="#克鲁斯卡尔算法的代码说明" class="headerlink" title="克鲁斯卡尔算法的代码说明"></a><strong>克鲁斯卡尔算法的代码说明</strong></h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><p>EData是邻接矩阵边对应的结构体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 边的结构体</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EData</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> start; <span class="hljs-comment">// 边的起点</span><br>    <span class="hljs-keyword">char</span> end;   <span class="hljs-comment">// 边的终点</span><br>    <span class="hljs-keyword">int</span> weight; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EData</span><span class="hljs-params">(<span class="hljs-keyword">char</span> start, <span class="hljs-keyword">char</span> end, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.start = start;<br>        <span class="hljs-keyword">this</span>.end = end;<br>        <span class="hljs-keyword">this</span>.weight = weight;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mEdgNum;        <span class="hljs-comment">// 边的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = Integer.MAX_VALUE;   <span class="hljs-comment">// 最大值</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-克鲁斯卡尔算法"><a href="#2-克鲁斯卡尔算法" class="headerlink" title="2. 克鲁斯卡尔算法"></a><strong>2. 克鲁斯卡尔算法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 克鲁斯卡尔（Kruskal)最小生成树<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;                      <span class="hljs-comment">// rets数组的索引</span><br>    <span class="hljs-keyword">int</span>[] vends = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[mEdgNum];     <span class="hljs-comment">// 用于保存"已有最小生成树"中每个顶点在该最小树中的终点。</span><br>    EData[] rets = <span class="hljs-keyword">new</span> EData[mEdgNum];  <span class="hljs-comment">// 结果数组，保存kruskal最小生成树的边</span><br>    EData[] edges;                      <span class="hljs-comment">// 图对应的所有边</span><br><br>    <span class="hljs-comment">// 获取"图中所有的边"</span><br>    edges = getEdges();<br>    <span class="hljs-comment">// 将边按照"权"的大小进行排序(从小到大)</span><br>    sortEdges(edges, mEdgNum);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;mEdgNum; i++) &#123;<br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i].start);      <span class="hljs-comment">// 获取第i条边的"起点"的序号</span><br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i].end);        <span class="hljs-comment">// 获取第i条边的"终点"的序号</span><br><br>        <span class="hljs-keyword">int</span> m = getEnd(vends, p1);                 <span class="hljs-comment">// 获取p1在"已有的最小生成树"中的终点</span><br>        <span class="hljs-keyword">int</span> n = getEnd(vends, p2);                 <span class="hljs-comment">// 获取p2在"已有的最小生成树"中的终点</span><br>        <span class="hljs-comment">// 如果m!=n，意味着"边i"与"已经添加到最小生成树中的顶点"没有形成环路</span><br>        <span class="hljs-keyword">if</span> (m != n) &#123;<br>            vends[m] = n;                       <span class="hljs-comment">// 设置m在"已有的最小生成树"中的终点为n</span><br>            rets[index++] = edges[i];           <span class="hljs-comment">// 保存结果</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 统计并打印"kruskal最小生成树"的信息</span><br>    <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>        length += rets[i].weight;<br>    System.out.printf(<span class="hljs-string">"Kruskal=%d: "</span>, length);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>        System.out.printf(<span class="hljs-string">"(%c,%c) "</span>, rets[i].start, rets[i].end);<br>    System.out.printf(<span class="hljs-string">"\n"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="普里姆-Prim-算法"><a href="#普里姆-Prim-算法" class="headerlink" title="普里姆(Prim)算法"></a>普里姆(Prim)算法</h1><p>普里姆(Prim)算法，是用来求加权连通图的最小生成树的算法。</p><p><strong>基本思想</strong><br>对于图G而言，V是所有顶点的集合；现在，设置两个新的集合U和T，其中U用于存放G的最小生成树中的顶点，T存放G的最小生成树中的边。 从所有uЄU，vЄ(V-U) (V-U表示出去U的所有顶点)的边中选取权值最小的边(u, v)，将顶点v加入集合U中，将边(u, v)加入集合T中，如此不断重复，直到U=V为止，最小生成树构造完毕，这时集合T中包含了最小生成树中的所有边。</p><h2 id="普里姆算法图解"><a href="#普里姆算法图解" class="headerlink" title="普里姆算法图解"></a><strong>普里姆算法图解</strong></h2><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/prim/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn3kzc05yj30aj07et8v.jpg" alt="img"></a></p><p>以上图G4为例，来对普里姆进行演示(从第一个顶点A开始通过普里姆算法生成最小生成树)。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/prim/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn3l4fltij30eq184jv3.jpg" alt="img"></a></p><p><strong>初始状态</strong>：V是所有顶点的集合，即V={A,B,C,D,E,F,G}；U和T都是空！<br><strong>第1步</strong>：将顶点A加入到U中。<br>  此时，U={A}。<br><strong>第2步</strong>：将顶点B加入到U中。<br>  上一步操作之后，U={A}, V-U={B,C,D,E,F,G}；因此，边(A,B)的权值最小。将顶点B添加到U中；此时，U={A,B}。<br><strong>第3步</strong>：将顶点F加入到U中。<br>  上一步操作之后，U={A,B}, V-U={C,D,E,F,G}；因此，边(B,F)的权值最小。将顶点F添加到U中；此时，U={A,B,F}。<br><strong>第4步</strong>：将顶点E加入到U中。<br>  上一步操作之后，U={A,B,F}, V-U={C,D,E,G}；因此，边(F,E)的权值最小。将顶点E添加到U中；此时，U={A,B,F,E}。<br><strong>第5步</strong>：将顶点D加入到U中。<br>  上一步操作之后，U={A,B,F,E}, V-U={C,D,G}；因此，边(E,D)的权值最小。将顶点D添加到U中；此时，U={A,B,F,E,D}。<br><strong>第6步</strong>：将顶点C加入到U中。<br>  上一步操作之后，U={A,B,F,E,D}, V-U={C,G}；因此，边(D,C)的权值最小。将顶点C添加到U中；此时，U={A,B,F,E,D,C}。<br><strong>第7步</strong>：将顶点G加入到U中。<br>  上一步操作之后，U={A,B,F,E,D,C}, V-U={G}；因此，边(F,G)的权值最小。将顶点G添加到U中；此时，U=V。</p><p>此时，最小生成树构造完成！它包括的顶点依次是：<strong>A B F E D C G</strong>。</p><h2 id="普里姆算法的代码说明"><a href="#普里姆算法的代码说明" class="headerlink" title="普里姆算法的代码说明"></a><strong>普里姆算法的代码说明</strong></h2><h3 id="1-基本定义-1"><a href="#1-基本定义-1" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = Integer.MAX_VALUE;   <span class="hljs-comment">// 最大值</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-普里姆算法"><a href="#2-普里姆算法" class="headerlink" title="2. 普里姆算法"></a><strong>2. 普里姆算法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * prim最小生成树<br> *<br> * 参数说明：<br> *   start -- 从图中的第start个元素开始，生成最小树<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num = mVexs.length;         <span class="hljs-comment">// 顶点个数</span><br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;                    <span class="hljs-comment">// prim最小树的索引，即prims数组的索引</span><br>    <span class="hljs-keyword">char</span>[] prims  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[num];  <span class="hljs-comment">// prim最小树的结果数组</span><br>    <span class="hljs-keyword">int</span>[] weights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num];   <span class="hljs-comment">// 顶点间边的权值</span><br><br>    <span class="hljs-comment">// prim最小生成树中第一个数是"图中第start个顶点"，因为是从start开始的。</span><br>    prims[index++] = mVexs[start];<br><br>    <span class="hljs-comment">// 初始化"顶点的权值数组"，</span><br>    <span class="hljs-comment">// 将每个顶点的权值初始化为"第start个顶点"到"该顶点"的权值。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++ )<br>        weights[i] = mMatrix[start][i];<br>    <span class="hljs-comment">// 将第start个顶点的权值初始化为0。</span><br>    <span class="hljs-comment">// 可以理解为"第start个顶点到它自身的距离为0"。</span><br>    weights[start] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>        <span class="hljs-comment">// 由于从start开始的，因此不需要再对第start个顶点进行处理。</span><br>        <span class="hljs-keyword">if</span>(start == i)<br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> min = INF;<br>        <span class="hljs-comment">// 在未被加入到最小生成树的顶点中，找出权值最小的顶点。</span><br>        <span class="hljs-keyword">while</span> (j &lt; num) &#123;<br>            <span class="hljs-comment">// 若weights[j]=0，意味着"第j个节点已经被排序过"(或者说已经加入了最小生成树中)。</span><br>            <span class="hljs-keyword">if</span> (weights[j] != <span class="hljs-number">0</span> &amp;&amp; weights[j] &lt; min) &#123;<br>                min = weights[j];<br>                k = j;<br>            &#125;<br>            j++;<br>        &#125;<br><br>        <span class="hljs-comment">// 经过上面的处理后，在未被加入到最小生成树的顶点中，权值最小的顶点是第k个顶点。</span><br>        <span class="hljs-comment">// 将第k个顶点加入到最小生成树的结果数组中</span><br>        prims[index++] = mVexs[k];<br>        <span class="hljs-comment">// 将"第k个顶点的权值"标记为0，意味着第k个顶点已经排序过了(或者说已经加入了最小树结果中)。</span><br>        weights[k] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 当第k个顶点被加入到最小生成树的结果数组中之后，更新其它顶点的权值。</span><br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span> ; j &lt; num; j++) &#123;<br>            <span class="hljs-comment">// 当第j个节点没有被处理，并且需要更新时才被更新。</span><br>            <span class="hljs-keyword">if</span> (weights[j] != <span class="hljs-number">0</span> &amp;&amp; mMatrix[k][j] &lt; weights[j])<br>                weights[j] = mMatrix[k][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算最小生成树的权值</span><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; index; i++) &#123;<br>        <span class="hljs-keyword">int</span> min = INF;<br>        <span class="hljs-comment">// 获取prims[i]在mMatrix中的位置</span><br>        <span class="hljs-keyword">int</span> n = getPosition(prims[i]);<br>        <span class="hljs-comment">// 在vexs[0...i]中，找出到j的权值最小的顶点。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">int</span> m = getPosition(prims[j]);<br>            <span class="hljs-keyword">if</span> (mMatrix[m][n]&lt;min)<br>                min = mMatrix[m][n];<br>        &#125;<br>        sum += min;<br>    &#125;<br>    <span class="hljs-comment">// 打印最小生成树</span><br>    System.out.printf(<span class="hljs-string">"PRIM(%c)=%d: "</span>, mVexs[start], sum);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>        System.out.printf(<span class="hljs-string">"%c "</span>, prims[i]);<br>    System.out.printf(<span class="hljs-string">"\n"</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.4.图的拓扑排序</title>
      <link href="/2021/11/22/7.4.%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/11/22/7.4.%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h1><h2 id="一、拓扑排序"><a href="#一、拓扑排序" class="headerlink" title="一、拓扑排序"></a>一、拓扑排序</h2><h3 id="1-拓扑排序介绍"><a href="#1-拓扑排序介绍" class="headerlink" title="1. 拓扑排序介绍"></a><strong>1. 拓扑排序介绍</strong></h3><p>拓扑排序(Topological Order)是指，将一个<strong>有向无环图</strong>(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的线性序列。</p><p>拓扑排序通常用来“排序”具有依赖关系的任务。比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边 表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。</p><p>如果AOV网络有n个顶点，e条边，在拓扑排序的过程中，搜索入度为零的顶点所需的时间是O(n)。在正常情况下，每个顶点进一次栈，出一次栈，所需时间O(n)。每个顶点入度减1的运算共执行了e次。所以总的时间复杂为O(n+e)。</p><h3 id="2-拓扑排序的算法图解"><a href="#2-拓扑排序的算法图解" class="headerlink" title="2. 拓扑排序的算法图解"></a><strong>2. 拓扑排序的算法图解</strong></h3><p>拓扑排序算法的基本步骤：</p><blockquote><p><strong>1.</strong> 构造一个队列Q(queue) 和 拓扑排序的结果队列T(topological)；<br><strong>2.</strong> 把所有没有依赖顶点的节点放入Q；<br><strong>3.</strong> 当Q还有顶点的时候，执行下面步骤：<br><strong>3.1</strong> 从Q中取出一个顶点n(将n从Q中删掉)，并放入T(将n加入到结果集中)；<br><strong>3.2</strong> 对n每一个邻接点m(n是起点，m是终点)；<br><strong>3.2.1</strong> 去掉边&lt;n,m&gt;;<br><strong>3.2.2</strong> 如果m没有依赖顶点，则把m放入Q;<br><em>注：顶点A没有依赖顶点，是指不存在以A为终点的边。</em></p></blockquote><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/topsort/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmtodh85wj308f08ywek.jpg" alt="img"></a></p><p>以上图为例，来对拓扑排序进行演示。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/topsort/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmtonrt51j30aj0tfaax.jpg" alt="img"></a></p><p><strong>第1步</strong>：将B和C加入到排序结果中。<br>  顶点B和顶点C都是没有依赖顶点，因此将C和C加入到结果集T中。假设ABCDEFG按顺序存储，因此先访问B，再访问C。访问B之后，去掉边&lt;B,A&gt;和&lt;B,D&gt;，并将A和D加入到队列Q中。同样的，去掉边&lt;C,F&gt;和&lt;C,G&gt;，并将F和G加入到Q中。<br>  (01) 将B加入到排序结果中，然后去掉边&lt;B,A&gt;和&lt;B,D&gt;；此时，由于A和D没有依赖顶点，因此并将A和D加入到队列Q中。<br>  (02) 将C加入到排序结果中，然后去掉边&lt;C,F&gt;和&lt;C,G&gt;；此时，由于F有依赖顶点D，G有依赖顶点A，因此不对F和G进行处理。<br><strong>第2步</strong>：将A,D依次加入到排序结果中。<br>  第1步访问之后，A,D都是没有依赖顶点的，根据存储顺序，先访问A，然后访问D。访问之后，删除顶点A和顶点D的出边。<br><strong>第3步</strong>：将E,F,G依次加入到排序结果中。</p><p>因此访问顺序是：<strong>B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; F -&gt; G</strong></p><h3 id="3-拓扑排序的代码"><a href="#3-拓扑排序的代码" class="headerlink" title="3. 拓扑排序的代码"></a><strong>3. 拓扑排序的代码</strong></h3><h4 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h4><p>拓扑排序是对有向无环图的排序。下面以邻接表实现的有向图来对拓扑排序进行说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListDG</span> </span>&#123;<br>    <span class="hljs-comment">// 邻接表中表对应的链表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ENode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ivex;       <span class="hljs-comment">// 该边所指向的顶点的位置</span><br>        ENode nextEdge; <span class="hljs-comment">// 指向下一条弧的指针</span><br>    &#125;<br><br>    <span class="hljs-comment">// 邻接表中表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VNode</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> data;          <span class="hljs-comment">// 顶点信息</span><br>        ENode firstEdge;    <span class="hljs-comment">// 指向第一条依附该顶点的弧</span><br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> VNode[] mVexs;  <span class="hljs-comment">// 顶点数组</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>(1)</strong> ListDG是邻接表对应的结构体。 mVexs则是保存顶点信息的一维数组。<br><strong>(2)</strong> VNode是邻接表顶点对应的结构体。 data是顶点所包含的数据，而firstEdge是该顶点所包含链表的表头指针。<br><strong>(3)</strong> ENode是邻接表顶点所包含的链表的节点对应的结构体。 ivex是该节点所对应的顶点在vexs中的索引，而nextEdge是指向下一个节点的。</p><h4 id="2-拓扑排序"><a href="#2-拓扑排序" class="headerlink" title="2. 拓扑排序"></a><strong>2. 拓扑排序</strong></h4><p>说明：<br><strong>(1)</strong> queue的作用就是用来存储没有依赖顶点的顶点。它与前面所说的Q相对应。<br><strong>(2)</strong> tops的作用就是用来存储排序结果。它与前面所说的T相对应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 拓扑排序<br> *<br> * 返回值：<br> *     -1 -- 失败(由于内存不足等原因导致)<br> *      0 -- 成功排序，并输入结果<br> *      1 -- 失败(该有向图是有环的)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">topologicalSort</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> num = mVexs.size();<br>    <span class="hljs-keyword">int</span>[] ins;               <span class="hljs-comment">// 入度数组</span><br>    <span class="hljs-keyword">char</span>[] tops;             <span class="hljs-comment">// 拓扑排序结果数组，记录每个节点的排序后的序号。</span><br>    Queue&lt;Integer&gt; queue;    <span class="hljs-comment">// 辅组队列</span><br><br>    ins   = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num];<br>    tops  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[num];<br>    queue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br><br>    <span class="hljs-comment">// 统计每个顶点的入度数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br><br>        ENode node = mVexs.get(i).firstEdge; <span class="hljs-comment">//获取以该顶点为起点的出边队列</span><br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>            ins[node.ivex]++;<br>            node = node.nextEdge;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将所有入度为0的顶点入队列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i ++)<br>        <span class="hljs-keyword">if</span>(ins[i] == <span class="hljs-number">0</span>)<br>            queue.offer(i);                 <span class="hljs-comment">// 入队列</span><br><br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;              <span class="hljs-comment">// 队列非空</span><br>        <span class="hljs-keyword">int</span> j = queue.poll().intValue();    <span class="hljs-comment">// 出队列。j是顶点的序号</span><br>        tops[index++] = mVexs.get(j).data;  <span class="hljs-comment">// 将该顶点添加到tops中，tops是排序结果</span><br>        ENode node = mVexs.get(j).firstEdge;<span class="hljs-comment">// 获取以该顶点为起点的出边队列</span><br><br>        <span class="hljs-comment">// 将与"node"关联的节点的入度减1；</span><br>        <span class="hljs-comment">// 若减1之后，该节点的入度为0；则将该节点添加到队列中。</span><br>        <span class="hljs-keyword">while</span>(node != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 将节点(序号为node.ivex)的入度减1。</span><br>            ins[node.ivex]--;<br>            <span class="hljs-comment">// 若节点的入度为0，则将其"入队列"</span><br>            <span class="hljs-keyword">if</span>( ins[node.ivex] == <span class="hljs-number">0</span>)<br>                queue.offer(node.ivex);    <span class="hljs-comment">// 入队列</span><br><br>            node = node.nextEdge;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(index != num) &#123;<br>        System.out.printf(<span class="hljs-string">"Graph has a cycle\n"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印拓扑排序结果</span><br>    System.out.printf(<span class="hljs-string">"== TopSort: "</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i ++)<br>        System.out.printf(<span class="hljs-string">"%c "</span>, tops[i]);<br>    System.out.printf(<span class="hljs-string">"\n"</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3.图的遍历(DFS,BFS)</title>
      <link href="/2021/11/22/7.3.%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86(DFS,BFS)/"/>
      <url>/2021/11/22/7.3.%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86(DFS,BFS)/</url>
      
        <content type="html"><![CDATA[<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a><strong>图的遍历</strong></h1><h2 id="一、深度优先搜索-Depth-First-Search-DFS"><a href="#一、深度优先搜索-Depth-First-Search-DFS" class="headerlink" title="一、深度优先搜索(Depth First Search, DFS)"></a>一、深度优先搜索(Depth First Search, DFS)</h2><h3 id="1-深度优先搜索介绍"><a href="#1-深度优先搜索介绍" class="headerlink" title="1. 深度优先搜索介绍"></a><strong>1. 深度优先搜索介绍</strong></h3><p>图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。</p><p>它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>显然，深度优先搜索是一个递归的过程。</p><h3 id="2-深度优先搜索图解"><a href="#2-深度优先搜索图解" class="headerlink" title="2. 深度优先搜索图解"></a><strong>2. 深度优先搜索图解</strong></h3><h4 id="2-1-无向图的深度优先搜索"><a href="#2-1-无向图的深度优先搜索" class="headerlink" title="2.1 无向图的深度优先搜索"></a><strong>2.1 无向图的深度优先搜索</strong></h4><p>下面以”无向图”为例，来对深度优先搜索进行演示。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmlnfvwp5j30bl08f74e.jpg" alt="img"></a></p><p>对上面的图G1进行深度优先遍历，从顶点A开始。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmlngl8zqj30c409h0t0.jpg" alt="img"></a></p><p><strong>第1步</strong>：访问A。<br><strong>第2步</strong>：访问(A的邻接点)C。<br>  在第1步访问A之后，接下来应该访问的是A的邻接点，即”C,D,F”中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在”D和F”的前面，因此，先访问C。<br><strong>第3步</strong>：访问(C的邻接点)B。<br>  在第2步访问C之后，接下来应该访问C的邻接点，即”B和D”中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。<br><strong>第4步</strong>：访问(C的邻接点)D。<br>  在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。<br><strong>第5步</strong>：访问(A的邻接点)F。<br>  前面已经访问了A，并且访问完了”A的邻接点B的所有邻接点(包括递归的邻接点在内)”；因此，此时返回到访问A的另一个邻接点F。<br><strong>第6步</strong>：访问(F的邻接点)G。<br><strong>第7步</strong>：访问(G的邻接点)E。</p><p>因此访问顺序是：<strong>A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E</strong></p><h4 id="2-2-有向图的深度优先搜索"><a href="#2-2-有向图的深度优先搜索" class="headerlink" title="2.2 有向图的深度优先搜索"></a><strong>2.2 有向图的深度优先搜索</strong></h4><p>下面以”有向图”为例，来对深度优先搜索进行演示。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/03.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmlpwnltaj308f08yt8t.jpg" alt="img"></a></p><p>对上面的图G2进行深度优先遍历，从顶点A开始。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/04.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmlpy4gxuj308f0a0wer.jpg" alt="img"></a></p><p><strong>第1步</strong>：访问A。<br><strong>第2步</strong>：访问B。<br>  在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。<br><strong>第3步</strong>：访问C。<br>  在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。<br><strong>第4步</strong>：访问E。<br>  接下来访问C的出边的另一个顶点，即顶点E。<br><strong>第5步</strong>：访问D。<br>  接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。<br><strong>第6步</strong>：访问F。<br>  接下应该回溯”访问A的出边的另一个顶点F”。<br><strong>第7步</strong>：访问G。</p><p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G</strong></p><h4 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><p><strong>邻接矩阵的深度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接矩阵的深度优先遍历</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 深度优先遍历</span><br><span class="hljs-keyword">boolean</span>[] beTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.vertices];<br><span class="hljs-comment">// 保存顶点的遍历状态，默认为false</span><br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>System.out.print(<span class="hljs-string">"深度优先遍历结果："</span>);<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList.get(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">this</span>.dfs(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, beTraversed);<br>System.out.println();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">boolean</span>[] beTraversed)</span> </span>&#123;<br><span class="hljs-comment">// 遍历x的第y个邻接点</span><br><span class="hljs-keyword">while</span> (y &lt; <span class="hljs-keyword">this</span>.vertices) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.edgeMatrix[x][y] != <span class="hljs-number">0</span> &amp;&amp; !beTraversed[y]) &#123;<br>beTraversed[y] = <span class="hljs-keyword">true</span>;<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList.get(y));<br><span class="hljs-keyword">this</span>.dfs(y, <span class="hljs-number">0</span>, beTraversed); <span class="hljs-comment">// 从y的第0个邻接点开始深度优先遍历</span><br>&#125;<br>y++;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>邻接表的深度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接表的深度优先遍历</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 深度优先遍历</span><br><span class="hljs-keyword">boolean</span>[] beTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.vertices];<br><span class="hljs-comment">// 保存顶点的遍历状态，默认为false</span><br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>System.out.print(<span class="hljs-string">"深度优先遍历结果："</span>);<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList[<span class="hljs-number">0</span>].data);<br><span class="hljs-keyword">this</span>.dfs(<span class="hljs-number">0</span>, beTraversed);<br>System.out.println();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">boolean</span>[] beTraversed)</span> </span>&#123;<br><span class="hljs-comment">// 从第i个顶点开始深度优先遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j : <span class="hljs-keyword">this</span>.vertexList[i].adj) &#123;<br><span class="hljs-keyword">if</span> (!beTraversed[j]) &#123;<br>beTraversed[j] = <span class="hljs-keyword">true</span>;<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList[j].data);<br><span class="hljs-keyword">this</span>.dfs(j, beTraversed);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自己构造邻接表的深度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bean.algorithm.graph;<br> <br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DFSGraph</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> V; <span class="hljs-comment">// 定义结点（vertices）</span><br> <br><span class="hljs-comment">// 图的邻接表表示（ Adjacency List）</span><br><span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; adj[];<br> <br><span class="hljs-comment">// 构造图的构造方法</span><br>DFSGraph(<span class="hljs-keyword">int</span> v) &#123;<br>V = v;<br>adj = <span class="hljs-keyword">new</span> LinkedList[v];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i)<br>adj[i] = <span class="hljs-keyword">new</span> LinkedList();<br>&#125;<br> <br><span class="hljs-comment">// 向图中添加边</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>adj[v].add(w); <br>&#125;<br> <br><span class="hljs-comment">// DFS算法工具</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFSUtil</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">boolean</span> visited[])</span> </span>&#123;<br><span class="hljs-comment">// 标记当前结点为已访问（visited）并输出</span><br>visited[v] = <span class="hljs-keyword">true</span>;<br>System.out.print(v + <span class="hljs-string">" "</span>);<br> <br><span class="hljs-comment">// 访问当前的结点的所有邻接结点</span><br>Iterator&lt;Integer&gt; i = adj[v].listIterator();<br><span class="hljs-keyword">while</span> (i.hasNext()) &#123;<br><span class="hljs-keyword">int</span> n = i.next();<br><span class="hljs-keyword">if</span> (!visited[n])<br>DFSUtil(n, visited);<br>&#125;<br>&#125;<br> <br><span class="hljs-comment">// DFS traversal. 用来回溯调用 DFSUtil()工具</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br><span class="hljs-comment">// 标记所有节点为未访问状态（ not visited），设置初始值为false。</span><br><span class="hljs-keyword">boolean</span> visited[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[V];<br> <br><span class="hljs-comment">// 回溯 DFS traversal</span><br>DFSUtil(v, visited);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>DFSGraph g = <span class="hljs-keyword">new</span> DFSGraph(<span class="hljs-number">4</span>);<br> <br>g.addEdge(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>g.addEdge(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>g.addEdge(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>g.addEdge(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>g.addEdge(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>g.addEdge(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br> <br>System.out.println(<span class="hljs-string">"下面是DFS搜索结果 "</span> + <span class="hljs-string">"(从2号结点开始)"</span>);<br> <br>g.DFS(<span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、广度优先搜索-Breadth-First-Search-BFS"><a href="#二、广度优先搜索-Breadth-First-Search-BFS" class="headerlink" title="二、广度优先搜索(Breadth First Search, BFS)"></a><strong>二、广度优先搜索(Breadth First Search, BFS)</strong></h2><h3 id="1-广度优先搜索介绍"><a href="#1-广度优先搜索介绍" class="headerlink" title="1. 广度优先搜索介绍"></a><strong>1. 广度优先搜索介绍</strong></h3><p>广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。</p><p>它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。</p><h3 id="2-广度优先搜索图解"><a href="#2-广度优先搜索图解" class="headerlink" title="2. 广度优先搜索图解"></a><strong>2. 广度优先搜索图解</strong></h3><h4 id="2-1-无向图的广度优先搜索"><a href="#2-1-无向图的广度优先搜索" class="headerlink" title="2.1 无向图的广度优先搜索"></a><strong>2.1 无向图的广度优先搜索</strong></h4><p>下面以”无向图”为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/05.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmltsvygcj30eq0e7dge.jpg" alt="img"></a></p><p><strong>第1步</strong>：访问A。<br><strong>第2步</strong>：依次访问C,D,F。<br>  在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在”D和F”的前面，因此，先访问C。再访问完C之后，再依次访问D,F。<br><strong>第3步</strong>：依次访问B,G。<br>  在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。<br><strong>第4步</strong>：访问E。<br>  在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。</p><p>因此访问顺序是：<strong>A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E</strong></p><h4 id="2-2-有向图的广度优先搜索"><a href="#2-2-有向图的广度优先搜索" class="headerlink" title="2.2 有向图的广度优先搜索"></a><strong>2.2 有向图的广度优先搜索</strong></h4><p>下面以”有向图”为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/06.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmluvpt0jj30fs0cnq3k.jpg" alt="img"></a></p><p><strong>第1步</strong>：访问A。<br><strong>第2步</strong>：访问B。<br><strong>第3步</strong>：依次访问C,E,F。<br>  在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。<br><strong>第4步</strong>：依次访问D,G。<br>  在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。</p><p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G</strong></p><h4 id="2-3-代码实现-1"><a href="#2-3-代码实现-1" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><p><strong>邻接矩阵的广度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接矩阵的广度优先遍历</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 宽度优先遍历</span><br><span class="hljs-keyword">boolean</span>[] beTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.vertices];<br><span class="hljs-comment">// 保存顶点的遍历状态，默认为false</span><br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>Queue queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>queue.offer(<span class="hljs-number">0</span>);<br><br>System.out.print(<span class="hljs-string">"宽度优先遍历："</span>);<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br><span class="hljs-keyword">int</span> index = queue.poll();<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList.get(index));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.vertices; i++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.edgeMatrix[index][i] != <span class="hljs-number">0</span> &amp;&amp; !beTraversed[i]) &#123;<br><span class="hljs-comment">// 找出所有没有访问过的邻接点</span><br>beTraversed[i] = <span class="hljs-keyword">true</span>;<br>queue.offer(i);<br>&#125;<br>&#125;<br>&#125;<br>System.out.println();<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>邻接表的广度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接表的广度优先遍历</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 宽度优先遍历</span><br><span class="hljs-keyword">boolean</span>[] beTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.vertices];<br><span class="hljs-comment">// 保存顶点的遍历状态，默认为false</span><br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>Queue queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>queue.offer(<span class="hljs-number">0</span>);<br><br>System.out.print(<span class="hljs-string">"宽度优先遍历："</span>);<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br><span class="hljs-keyword">int</span> index = queue.poll();<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList[index].data);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : <span class="hljs-keyword">this</span>.vertexList[index].adj) &#123;<br><span class="hljs-comment">// 所有未被访问过的邻接点入队</span><br><span class="hljs-keyword">if</span> (!beTraversed[i]) &#123;<br>beTraversed[i] = <span class="hljs-keyword">true</span>;<br>queue.offer(i);<br>&#125;<br>&#125;<br>&#125;<br>System.out.println();<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2.图的概念和储存结构</title>
      <link href="/2021/11/22/7.2.%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>/2021/11/22/7.2.%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="图-graph"><a href="#图-graph" class="headerlink" title="图(graph)"></a>图(graph)</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-图的定义"><a href="#1-图的定义" class="headerlink" title="1. 图的定义"></a><strong>1. 图的定义</strong></h3><p>定义：图(graph)是由一些点(vertex)和这些点之间的连线(edge)所组成的；其中，点通常被成为”顶点(vertex)”，而点与点之间的连线则被成为”边或弧”(edege)。通常记为，G=(V,E)。</p><h3 id="2-图的种类"><a href="#2-图的种类" class="headerlink" title="2. 图的种类"></a><strong>2. 图的种类</strong></h3><p>根据边是否有方向，将图可以划分为：<strong>无向图</strong>和<strong>有向图</strong></p><h4 id="2-1-无向图"><a href="#2-1-无向图" class="headerlink" title="2.1 无向图"></a><strong>2.1 无向图</strong></h4><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmg3skx7zj308f08fjrg.jpg" alt="img"></a></p><p>上面的图G0是无向图，无向图的所有的边都是不区分方向的。G0=(V1,{E1})。其中，</p><p><strong>(1)</strong> V1={A,B,C,D,E,F}。 V1表示由”A,B,C,D,E,F”几个顶点组成的集合。<br><strong>(2)</strong> E1={(A,B),(A,C),(B,C),(B,E),(B,F),(C,F), (C,D),(E,F),(C,E)}。 E1是由边(A,B),边(A,C)…等等组成的集合。其中，(A,C)表示由顶点A和顶点C连接成的边。</p><p><strong>无向完全图</strong>：在一个无向图中，如果任意两顶点都有一条直接边相连接，则称该图为无向完全图。可以证明，在一个含有n个顶点的无向完全图中，有n（n-1）/2条边。</p><h4 id="2-2-有向图"><a href="#2-2-有向图" class="headerlink" title="2.2 有向图"></a><strong>2.2 有向图</strong></h4><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmg8f6ii6j308f08yt8t.jpg" alt="img"></a></p><p>上面的图G2是有向图。和无向图不同，有向图的所有的边都是有方向的！ G2=(V2,{A2})。其中，</p><p><strong>(1)</strong> V2={A,C,B,F,D,E,G}。 V2表示由”A,B,C,D,E,F,G”几个顶点组成的集合。<br><strong>(2)</strong> A2={&lt;A,B&gt;,&lt;B,C&gt;,&lt;B,F&gt;,&lt;B,E&gt;,&lt;C,E&gt;,&lt;E,D&gt;,&lt;D,C&gt;,&lt;E,B&gt;,&lt;F,G&gt;}。 E1是由矢量&lt;A,B&gt;,矢量&lt;B,C&gt;…等等组成的集合。其中，矢量&lt;A,B&gt;表示由”顶点A”指向”顶点C”的有向边。</p><p><strong>有向完全图</strong>：在有一个有向图中，如果任意两顶点之间都有方向互为相反的两条弧相连接，则称该图为有向完全图。在一个含有n个顶点的有向完全图中，有n(n-1)条边。</p><h3 id="3-邻接点和度"><a href="#3-邻接点和度" class="headerlink" title="3. 邻接点和度"></a><strong>3. 邻接点和度</strong></h3><h4 id="3-1-邻接点"><a href="#3-1-邻接点" class="headerlink" title="3.1 邻接点"></a><strong>3.1 邻接点</strong></h4><p>一条边上的两个顶点叫做邻接点。<br><em>例如，上面无向图G0中的顶点A和顶点C就是邻接点。</em></p><p>在有向图中，除了邻接点之外；还有”入边”和”出边”的概念。<br>顶点的入边，是指以该顶点为终点的边。而顶点的出边，则是指以该顶点为起点的边。<br><em>例如，上面有向图G2中的B和E是邻接点；&lt;B,E&gt;是B的出边，还是E的入边。</em></p><h4 id="3-2-度"><a href="#3-2-度" class="headerlink" title="3.2 度"></a><strong>3.2 度</strong></h4><p>在无向图中，某个顶点的度是邻接到该顶点的边(或弧)的数目。<br><em>例如，上面无向图G0中顶点A的度是2。</em></p><p>在有向图中，度还有”入度”和”出度”之分。<br>某个顶点的入度，是指以该顶点为终点的边的数目。而顶点的出度，则是指以该顶点为起点的边的数目。<br><strong>顶点的度=入度+出度。</strong><br><em>例如，上面有向图G2中，顶点B的入度是2，出度是3；顶点B的度=2+3=5。</em></p><h3 id="4-路径和回路"><a href="#4-路径和回路" class="headerlink" title="4. 路径和回路"></a><strong>4. 路径和回路</strong></h3><p><strong>路径</strong>：如果顶点(Vm)到顶点(Vn)之间存在一个顶点序列。则表示Vm到Vn是一条路径。<br><strong>路径长度</strong>：路径中”边的数量”。<br><strong>简单路径</strong>：若一条路径上顶点不重复出现，则是简单路径。<br><strong>回路</strong>：若路径的第一个顶点和最后一个顶点相同，则是回路。<br><strong>简单回路</strong>：第一个顶点和最后一个顶点相同，其它各顶点都不重复的回路则是简单回路。</p><h3 id="5-连通图和连通分量"><a href="#5-连通图和连通分量" class="headerlink" title="5. 连通图和连通分量"></a><strong>5. 连通图和连通分量</strong></h3><p><strong>连通图</strong>：对无向图而言，<strong>任意两个顶点之间都存在一条无向路径</strong>，则称该无向图为连通图。 对有向图而言，若图中<strong>任意两个顶点之间都存在一条有向路径</strong>，则称该有向图为强连通图。</p><p><strong>连通分量</strong>：<strong>非连通图中的各个连通子图称为该图的连通分量</strong>。</p><h3 id="6-权"><a href="#6-权" class="headerlink" title="6. 权"></a><strong>6. 权</strong></h3><p>在学习”哈夫曼树”的时候，了解过”权”的概念。图中权的概念与此类似。</p><p>边的权、网：与边有关的数据信息称为权(Weight)。在实际应用中，权值可以有某种含义。例如，在一个反映城市交通线路的图中，边上的权值可以表示该条线路的长度或等级；对于一个电子线路图，边上的权值可以表示两个端点之间的电阻、电流或电压值；对于反映工程进度的图而言，边上的权值可以表示从前一个工程到后一个工程所需要的时间或其他代价等。边上带权的图称为网或网络（network）。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/03.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmgsy4rtpj308f08faa6.jpg" alt="img"></a></p><p>上面就是一个带权的图。</p><h3 id="7-生成树"><a href="#7-生成树" class="headerlink" title="7. 生成树"></a>7. 生成树</h3><p>所谓连通图G的生成树，是G的包含其全部n个顶点的一个极小连通子图，所谓极小连通子图是指在包含所有顶点且保证连通的前提下尽可能少地包含原图中的边。生成树必定包含且仅包含连通图G的n-1条边。在生成树中添加任意一条属于原图中的边必定会产生回路，因为新添加的边使其所依附的两个顶点之间有了第二条路径。若生成树中减少任意一条边，则必然成为非连通的。</p><h3 id="8-生成森林"><a href="#8-生成森林" class="headerlink" title="8. 生成森林"></a>8. 生成森林</h3><p>在非连通图中，由每个连通分量都可得到一个极小连通子图，即一棵生成树。这些连通分量的生成树就组成了一个非连通图的生成森林。</p><h2 id="二、图的存储结构"><a href="#二、图的存储结构" class="headerlink" title="二、图的存储结构"></a>二、图的存储结构</h2><h3 id="1-邻接矩阵"><a href="#1-邻接矩阵" class="headerlink" title="1. 邻接矩阵"></a><strong>1. 邻接矩阵</strong></h3><p>邻接矩阵是指用矩阵来表示图。它是采用矩阵来描述图中顶点之间的关系(及弧或边的权)。<br>假设图中顶点数为n，则邻接矩阵定义为：</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/04.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh21hzetj30bl035gln.jpg" alt="img"></a><br>下面通过示意图来进行解释。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/05.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh227kinj30lk08ymxu.jpg" alt="img"></a></p><p>图中的G1是无向图和它对应的邻接矩阵。</p><p>无向图的邻接矩阵是一个对称矩阵，是因为边不具有方向性，所以在邻接矩阵中对角线上皆为0。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/06.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh2xdkz2j30l108ygmb.jpg" alt="img"></a></p><p>图中的G2是无向图和它对应的邻接矩阵。</p><p>有向图由于边具有方向性，因此彼此顶点之间并不能相互达到，所以其邻接矩阵的对称性不再。</p><p>通常采用两个数组来实现邻接矩阵：一个一维数组用来保存顶点信息，一个二维数组来用保存边的信息。而根据实际情况可以分析得，图中的顶点并不是任意两个顶点间都会相连，不是都需要对其边上权重进行存储。那么存储的邻接矩阵实际上会存在大量的0。虽然可以通过稀疏表示等方式对稀疏性高的矩阵进行关键信息的存储，但是却增加了图存储的复杂性。<br><strong>缺点</strong>:就是比较耗费空间。</p><h3 id="2-邻接表"><a href="#2-邻接表" class="headerlink" title="2. 邻接表"></a><strong>2. 邻接表</strong></h3><p>邻接表是图的一种链式存储表示方法。它是改进后的”邻接矩阵”。</p><p><strong>缺点：是不方便判断两个顶点之间是否有边。</strong></p><p><strong>优点：相对邻接矩阵来说更省空间。</strong></p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/07.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh65wupuj30n409hmxw.jpg" alt="img"></a></p><p>图中的G1是无向图和它对应的邻接矩阵。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/08.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh97vnlnj30lk09hdgh.jpg" alt="img"></a></p><p>图中的G2是无向图和它对应的邻接矩阵。</p><p>由此看出，<strong>在对有向图进行表示时，邻接表只能求出图的出度，而无法求出入度。</strong>这个问题很好解决，那就是增加一个表用来存储能够到达某个顶点的相邻顶点。这个表称作逆邻接表。</p><h3 id="3-逆邻接表"><a href="#3-逆邻接表" class="headerlink" title="3. 逆邻接表"></a>3. <strong>逆邻接表</strong></h3><p>逆邻接表与邻接表结构类似，只不过图的顶点链接着能够到达该顶点的相邻顶点。也就是说，邻接表时顺着图中的箭头寻找相邻顶点，而逆邻接表时逆着图中的箭头寻找相邻顶点。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmhhjp483j314o0jedha.jpg" alt="image-20211121085043748"></p><p>邻接表和逆邻接表的共同使用下，就能够把一个完整的有向图结构进行表示。可以发现，邻接表和逆邻接表实际上有一部分数据时重合的，因此可以将两个表合二为一，从而得到了所谓的十字链表。</p><h3 id="4-十字链表"><a href="#4-十字链表" class="headerlink" title="4. 十字链表"></a>4. <strong>十字链表</strong></h3><p>十字链表似乎很简单，只需要通过相同的顶点分别链向以该顶点为终点和起点的相邻顶点即可。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmhjkii88j314e0icgns.jpg" alt="image-20211121085241805"></p><p>但这并不是最优的表示方式。虽然这样的方式共用了中间的顶点存储空间，但是邻接表和逆邻接表的链表节点中重复出现的顶点并没有得到重复利用，反而是进行了再次存储。因此，上图的表示方式还可以进行进一步优化。</p><p>十字链表优化后，可通过扩展的顶点结构和边结构来进行正逆邻接表的存储：（下面的弧头可看作是边的箭头那端，弧尾可看作是边的圆点那端）</p><p><strong>顶点结构</strong></p><blockquote><p><strong>data</strong>：用于存储该顶点中的数据； </p><p><strong>firstin指针</strong>：用于连接以当前顶点为弧头的其他顶点构成的链表，即从别的顶点指进来的顶点；</p><p><strong>firstout指针</strong>：用于连接以当前顶点为弧尾的其他顶点构成的链表，即从该顶点指出去的顶点;</p></blockquote><p><strong>边结构</strong>通过存储两个顶点来确定一条边，同时通过分别代表这两个顶点的指针来与相邻顶点进行链接：</p><blockquote><p><strong>tailvex</strong>：用于存储作为弧尾的顶点的编号； </p><p><strong>headvex</strong>：用于存储作为弧头的顶点的编号； </p><p><strong>headlink 指针</strong>：用于链接下一个存储作为弧头的顶点的节点； </p><p><strong>taillink 指针</strong>：用于链接下一个存储作为弧尾的顶点的节点；</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmhunyr03j31q90u0q7p.jpg" alt="image-20211121090318141"></p><p>以上图为例子，对于顶点A而言，其作为起点能够到达顶点E。因此在邻接表中顶点A要通过边<code>AE</code>（即边04）指向顶点E，顶点A的<code>firstout</code>指针需要指向边04的<code>tailvex</code>。同时，从B出发能够到达A，所以在逆邻接表中顶点A要通过边<code>AB</code>（即边10）指向B，顶点A的<code>firstin</code>指针需要指向边10的弧头，即<code>headlink</code>指针。依次类推。</p><p>十字链表采用了一种看起来比较繁乱的方式对边的方向性进行了表示，能够在尽可能降低存储空间的情况下增加指针保留顶点之间的方向性。具体的操作可能一时间不好弄懂，建议多看几次上图，弄清指针指向的意义，明白正向和逆向邻接表的表示。</p><h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><h3 id="1-邻接矩阵无向图"><a href="#1-邻接矩阵无向图" class="headerlink" title="1. 邻接矩阵无向图"></a>1. 邻接矩阵无向图</h3><p><strong>基本定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里介绍提供了两个创建矩阵的方法。一个是<strong>用已知数据</strong>，另一个则<strong>需要用户手动输入数据</strong>。</p><h4 id="1-1-创建图-用已提供的矩阵"><a href="#1-1-创建图-用已提供的矩阵" class="headerlink" title="1.1 创建图(用已提供的矩阵)"></a><strong>1.1 创建图(用已提供的矩阵)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 创建图(用已提供的矩阵)<br> *<br> * 参数说明：<br> *     vexs  -- 顶点数组<br> *     edges -- 边数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MatrixUDG</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vexs, <span class="hljs-keyword">char</span>[][] edges)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span><br>    <span class="hljs-keyword">int</span> vlen = vexs.length;<br>    <span class="hljs-keyword">int</span> elen = edges.length;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++)<br>        mVexs[i] = vexs[i];<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    mMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vlen][vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i][<span class="hljs-number">1</span>]);<br><br>        mMatrix[p1][p2] = <span class="hljs-number">1</span>;<br>        mMatrix[p2][p1] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是利用已知数据来创建一个邻接矩阵无向图。 实际上，在本文的测试程序源码中，该方法创建的无向图就是上面图G1。具体的调用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] vexs = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;;<br>    <span class="hljs-keyword">char</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[][]&#123;<br>        &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>&#125;, <br>        &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'D'</span>&#125;, <br>        &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'F'</span>&#125;, <br>        &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>&#125;, <br>        &#123;<span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>&#125;, <br>        &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'G'</span>&#125;, <br>        &#123;<span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;&#125;;<br>    MatrixUDG pG;<br><br>    pG = <span class="hljs-keyword">new</span> MatrixUDG(vexs, edges);<br></code></pre></td></tr></table></figure><h4 id="1-2-创建图-自己输入"><a href="#1-2-创建图-自己输入" class="headerlink" title="1.2 创建图(自己输入)"></a><strong>1.2 创建图(自己输入)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 创建图(自己输入数据)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MatrixUDG</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 输入"顶点数"和"边数"</span><br>    System.out.printf(<span class="hljs-string">"input vertex number: "</span>);<br>    <span class="hljs-keyword">int</span> vlen = readInt();<br>    System.out.printf(<span class="hljs-string">"input edge number: "</span>);<br>    <span class="hljs-keyword">int</span> elen = readInt();<br>    <span class="hljs-keyword">if</span> ( vlen &lt; <span class="hljs-number">1</span> || elen &lt; <span class="hljs-number">1</span> || (elen &gt; (vlen*(vlen - <span class="hljs-number">1</span>)))) &#123;<br>        System.out.printf(<span class="hljs-string">"input error: invalid parameters!\n"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        System.out.printf(<span class="hljs-string">"vertex(%d): "</span>, i);<br>        mVexs[i] = readChar();<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    mMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vlen][vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        System.out.printf(<span class="hljs-string">"edge(%d):"</span>, i);<br>        <span class="hljs-keyword">char</span> c1 = readChar();<br>        <span class="hljs-keyword">char</span> c2 = readChar();<br>        <span class="hljs-keyword">int</span> p1 = getPosition(c1);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(c2);<br><br>        <span class="hljs-keyword">if</span> (p1==-<span class="hljs-number">1</span> || p2==-<span class="hljs-number">1</span>) &#123;<br>            System.out.printf(<span class="hljs-string">"input error: invalid edge!\n"</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        mMatrix[p1][p2] = <span class="hljs-number">1</span>;<br>        mMatrix[p2][p1] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-邻接矩阵有向图"><a href="#2-邻接矩阵有向图" class="headerlink" title="2. 邻接矩阵有向图"></a><strong>2. 邻接矩阵有向图</strong></h3><p><strong>基本定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里介绍提供了两个创建矩阵的方法。一个是<strong>用已知数据</strong>，另一个则<strong>需要用户手动输入数据</strong>。</p><h4 id="2-1-创建图-用已提供的矩阵"><a href="#2-1-创建图-用已提供的矩阵" class="headerlink" title="2.1 创建图(用已提供的矩阵)"></a><strong>2.1 创建图(用已提供的矩阵)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 创建图(用已提供的矩阵)<br> *<br> * 参数说明：<br> *     vexs  -- 顶点数组<br> *     edges -- 边数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MatrixDG</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vexs, <span class="hljs-keyword">char</span>[][] edges)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span><br>    <span class="hljs-keyword">int</span> vlen = vexs.length;<br>    <span class="hljs-keyword">int</span> elen = edges.length;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++)<br>        mVexs[i] = vexs[i];<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    mMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vlen][vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i][<span class="hljs-number">1</span>]);<br><br>        mMatrix[p1][p2] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是创建一个邻接矩阵有向图。实际上，该方法创建的有向图，就是上面的图G2。它的调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] vexs = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;;<br><span class="hljs-keyword">char</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[][]&#123;<br>    &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>&#125;, <br>    &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>&#125;, <br>    &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'E'</span>&#125;, <br>    &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'F'</span>&#125;, <br>    &#123;<span class="hljs-string">'C'</span>, <span class="hljs-string">'E'</span>&#125;, <br>    &#123;<span class="hljs-string">'D'</span>, <span class="hljs-string">'C'</span>&#125;, <br>    &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'B'</span>&#125;, <br>    &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'D'</span>&#125;, <br>    &#123;<span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;&#125;; <br>MatrixDG pG;<br><br>pG = <span class="hljs-keyword">new</span> MatrixDG(vexs, edges);<br></code></pre></td></tr></table></figure><h4 id="2-2-创建图-自己输入"><a href="#2-2-创建图-自己输入" class="headerlink" title="2.2 创建图(自己输入)"></a><strong>2.2 创建图(自己输入)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 创建图(自己输入数据)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MatrixDG</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 输入"顶点数"和"边数"</span><br>    System.out.printf(<span class="hljs-string">"input vertex number: "</span>);<br>    <span class="hljs-keyword">int</span> vlen = readInt();<br>    System.out.printf(<span class="hljs-string">"input edge number: "</span>);<br>    <span class="hljs-keyword">int</span> elen = readInt();<br>    <span class="hljs-keyword">if</span> ( vlen &lt; <span class="hljs-number">1</span> || elen &lt; <span class="hljs-number">1</span> || (elen &gt; (vlen*(vlen - <span class="hljs-number">1</span>)))) &#123;<br>        System.out.printf(<span class="hljs-string">"input error: invalid parameters!\n"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        System.out.printf(<span class="hljs-string">"vertex(%d): "</span>, i);<br>        mVexs[i] = readChar();<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    mMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vlen][vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        System.out.printf(<span class="hljs-string">"edge(%d):"</span>, i);<br>        <span class="hljs-keyword">char</span> c1 = readChar();<br>        <span class="hljs-keyword">char</span> c2 = readChar();<br>        <span class="hljs-keyword">int</span> p1 = getPosition(c1);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(c2);<br><br>        <span class="hljs-keyword">if</span> (p1==-<span class="hljs-number">1</span> || p2==-<span class="hljs-number">1</span>) &#123;<br>            System.out.printf(<span class="hljs-string">"input error: invalid edge!\n"</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        mMatrix[p1][p2] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-邻接表无向图"><a href="#3-邻接表无向图" class="headerlink" title="3. 邻接表无向图"></a><strong>3. 邻接表无向图</strong></h3><p><strong>基本定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListUDG</span> </span>&#123;<br>    <span class="hljs-comment">// 邻接表中表对应的链表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ENode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ivex;       <span class="hljs-comment">// 该边所指向的顶点的位置</span><br>        ENode nextEdge; <span class="hljs-comment">// 指向下一条弧的指针</span><br>    &#125;<br><br>    <span class="hljs-comment">// 邻接表中表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VNode</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> data;          <span class="hljs-comment">// 顶点信息</span><br>        ENode firstEdge;    <span class="hljs-comment">// 指向第一条依附该顶点的弧</span><br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> VNode[] mVexs;  <span class="hljs-comment">// 顶点数组</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>(1)</strong> ListUDG是邻接表对应的结构体。mVexs则是保存顶点信息的一维数组。<br><strong>(2)</strong> VNode是邻接表顶点对应的结构体。 data是顶点所包含的数据，而firstEdge是该顶点所包含链表的表头指针。<br><strong>(3)</strong> ENode是邻接表顶点所包含的链表的节点对应的结构体。 ivex是该节点所对应的顶点在vexs中的索引，而nextEdge是指向下一个节点的。</p><h4 id="3-1-创建图-用已提供的矩阵"><a href="#3-1-创建图-用已提供的矩阵" class="headerlink" title="3.1 创建图(用已提供的矩阵)"></a><strong>3.1 创建图(用已提供的矩阵)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 创建图(用已提供的矩阵)<br> *<br> * 参数说明：<br> *     vexs  -- 顶点数组<br> *     edges -- 边数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListUDG</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vexs, <span class="hljs-keyword">char</span>[][] edges)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span><br>    <span class="hljs-keyword">int</span> vlen = vexs.length;<br>    <span class="hljs-keyword">int</span> elen = edges.length;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> VNode[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        mVexs[i] = <span class="hljs-keyword">new</span> VNode();<br>        mVexs[i].data = vexs[i];<br>        mVexs[i].firstEdge = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">char</span> c1 = edges[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">char</span> c2 = edges[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i][<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 初始化node1</span><br>        ENode node1 = <span class="hljs-keyword">new</span> ENode();<br>        node1.ivex = p2;<br>        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p1].firstEdge = node1;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p1].firstEdge, node1);<br>        <span class="hljs-comment">// 初始化node2</span><br>        ENode node2 = <span class="hljs-keyword">new</span> ENode();<br>        node2.ivex = p1;<br>        <span class="hljs-comment">// 将node2链接到"p2所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p2].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p2].firstEdge = node2;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p2].firstEdge, node2);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是创建一个邻接表无向图。实际上，该方法创建的无向图，就是上面图G1。调用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] vexs = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;;<br><span class="hljs-keyword">char</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[][]&#123;<br>    &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>&#125;, <br>    &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'D'</span>&#125;, <br>    &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'F'</span>&#125;, <br>    &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>&#125;, <br>    &#123;<span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>&#125;, <br>    &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'G'</span>&#125;, <br>    &#123;<span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;&#125;;<br>ListUDG pG;<br><br>pG = <span class="hljs-keyword">new</span> ListUDG(vexs, edges);<br></code></pre></td></tr></table></figure><h4 id="3-2-创建图-自己输入"><a href="#3-2-创建图-自己输入" class="headerlink" title="3.2 创建图(自己输入)"></a><strong>3.2 创建图(自己输入)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 创建图(自己输入数据)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListUDG</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 输入"顶点数"和"边数"</span><br>    System.out.printf(<span class="hljs-string">"input vertex number: "</span>);<br>    <span class="hljs-keyword">int</span> vlen = readInt();<br>    System.out.printf(<span class="hljs-string">"input edge number: "</span>);<br>    <span class="hljs-keyword">int</span> elen = readInt();<br>    <span class="hljs-keyword">if</span> ( vlen &lt; <span class="hljs-number">1</span> || elen &lt; <span class="hljs-number">1</span> || (elen &gt; (vlen*(vlen - <span class="hljs-number">1</span>)))) &#123;<br>        System.out.printf(<span class="hljs-string">"input error: invalid parameters!\n"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> VNode[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        System.out.printf(<span class="hljs-string">"vertex(%d): "</span>, i);<br>        mVexs[i] = <span class="hljs-keyword">new</span> VNode();<br>        mVexs[i].data = readChar();<br>        mVexs[i].firstEdge = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    <span class="hljs-comment">//mMatrix = new int[vlen][vlen];</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        System.out.printf(<span class="hljs-string">"edge(%d):"</span>, i);<br>        <span class="hljs-keyword">char</span> c1 = readChar();<br>        <span class="hljs-keyword">char</span> c2 = readChar();<br>        <span class="hljs-keyword">int</span> p1 = getPosition(c1);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(c2);<br>        <span class="hljs-comment">// 初始化node1</span><br>        ENode node1 = <span class="hljs-keyword">new</span> ENode();<br>        node1.ivex = p2;<br>        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p1].firstEdge = node1;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p1].firstEdge, node1);<br>        <span class="hljs-comment">// 初始化node2</span><br>        ENode node2 = <span class="hljs-keyword">new</span> ENode();<br>        node2.ivex = p1;<br>        <span class="hljs-comment">// 将node2链接到"p2所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p2].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p2].firstEdge = node2;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p2].firstEdge, node2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-邻接表有向图"><a href="#4-邻接表有向图" class="headerlink" title="4. 邻接表有向图"></a><strong>4. 邻接表有向图</strong></h3><p><strong>基本定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListDG</span> </span>&#123;<br>    <span class="hljs-comment">// 邻接表中表对应的链表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ENode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ivex;       <span class="hljs-comment">// 该边所指向的顶点的位置</span><br>        ENode nextEdge; <span class="hljs-comment">// 指向下一条弧的指针</span><br>    &#125;<br><br>    <span class="hljs-comment">// 邻接表中表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VNode</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> data;          <span class="hljs-comment">// 顶点信息</span><br>        ENode firstEdge;    <span class="hljs-comment">// 指向第一条依附该顶点的弧</span><br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> VNode[] mVexs;  <span class="hljs-comment">// 顶点数组</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>(1)</strong> ListDG是邻接表对应的结构体。 mVexs则是保存顶点信息的一维数组。<br><strong>(2)</strong> VNode是邻接表顶点对应的结构体。 data是顶点所包含的数据，而firstEdge是该顶点所包含链表的表头指针。<br><strong>(3)</strong> ENode是邻接表顶点所包含的链表的节点对应的结构体。 ivex是该节点所对应的顶点在vexs中的索引，而nextEdge是指向下一个节点的。</p><h4 id="4-1-创建图-用已提供的矩阵"><a href="#4-1-创建图-用已提供的矩阵" class="headerlink" title="4.1 创建图(用已提供的矩阵)"></a><strong>4.1 创建图(用已提供的矩阵)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 创建图(用已提供的矩阵)<br> *<br> * 参数说明：<br> *     vexs  -- 顶点数组<br> *     edges -- 边数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListDG</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vexs, <span class="hljs-keyword">char</span>[][] edges)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span><br>    <span class="hljs-keyword">int</span> vlen = vexs.length;<br>    <span class="hljs-keyword">int</span> elen = edges.length;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> VNode[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        mVexs[i] = <span class="hljs-keyword">new</span> VNode();<br>        mVexs[i].data = vexs[i];<br>        mVexs[i].firstEdge = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">char</span> c1 = edges[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">char</span> c2 = edges[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i][<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-comment">// 初始化node1</span><br>        ENode node1 = <span class="hljs-keyword">new</span> ENode();<br>        node1.ivex = p2;<br>        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p1].firstEdge = node1;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p1].firstEdge, node1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是创建一个邻接表有向图。实际上，该方法创建的有向图，就是上面的图G2。该函数的调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] vexs = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;;<br>    <span class="hljs-keyword">char</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[][]&#123;<br>        &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>&#125;, <br>        &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>&#125;, <br>        &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'E'</span>&#125;, <br>        &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'F'</span>&#125;, <br>        &#123;<span class="hljs-string">'C'</span>, <span class="hljs-string">'E'</span>&#125;, <br>        &#123;<span class="hljs-string">'D'</span>, <span class="hljs-string">'C'</span>&#125;, <br>        &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'B'</span>&#125;, <br>        &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'D'</span>&#125;, <br>        &#123;<span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;&#125;; <br>    ListDG pG;<br><br>    pG = <span class="hljs-keyword">new</span> ListDG(vexs, edges);<br></code></pre></td></tr></table></figure><h4 id="4-2-创建图-自己输入"><a href="#4-2-创建图-自己输入" class="headerlink" title="4.2 创建图(自己输入)"></a><strong>4.2 创建图(自己输入)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 创建图(自己输入数据)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListDG</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 输入"顶点数"和"边数"</span><br>    System.out.printf(<span class="hljs-string">"input vertex number: "</span>);<br>    <span class="hljs-keyword">int</span> vlen = readInt();<br>    System.out.printf(<span class="hljs-string">"input edge number: "</span>);<br>    <span class="hljs-keyword">int</span> elen = readInt();<br>    <span class="hljs-keyword">if</span> ( vlen &lt; <span class="hljs-number">1</span> || elen &lt; <span class="hljs-number">1</span> || (elen &gt; (vlen*(vlen - <span class="hljs-number">1</span>)))) &#123;<br>        System.out.printf(<span class="hljs-string">"input error: invalid parameters!\n"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> VNode[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        System.out.printf(<span class="hljs-string">"vertex(%d): "</span>, i);<br>        mVexs[i] = <span class="hljs-keyword">new</span> VNode();<br>        mVexs[i].data = readChar();<br>        mVexs[i].firstEdge = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    <span class="hljs-comment">//mMatrix = new int[vlen][vlen];</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        System.out.printf(<span class="hljs-string">"edge(%d):"</span>, i);<br>        <span class="hljs-keyword">char</span> c1 = readChar();<br>        <span class="hljs-keyword">char</span> c2 = readChar();<br>        <span class="hljs-keyword">int</span> p1 = getPosition(c1);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(c2);<br>        <span class="hljs-comment">// 初始化node1</span><br>        ENode node1 = <span class="hljs-keyword">new</span> ENode();<br>        node1.ivex = p2;<br>        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p1].firstEdge = node1;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p1].firstEdge, node1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1.图的思维导图</title>
      <link href="/2021/11/22/7.1.%E5%9B%BE%E7%9A%84%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
      <url>/2021/11/22/7.1.%E5%9B%BE%E7%9A%84%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/10/04/08RwKH.jpg" alt="08RwKH.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.5.斐波那契堆</title>
      <link href="/2021/11/17/6.5.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86/"/>
      <url>/2021/11/17/6.5.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="斐波那契堆-Fibonacci-heap"><a href="#斐波那契堆-Fibonacci-heap" class="headerlink" title="斐波那契堆(Fibonacci heap)"></a>斐波那契堆(Fibonacci heap)</h1><h2 id="斐波那契堆介绍"><a href="#斐波那契堆介绍" class="headerlink" title="斐波那契堆介绍"></a>斐波那契堆介绍</h2><p>斐波那契堆(Fibonacci heap)是一种可合并堆，可用于实现合并优先队列。</p><p>它比二项堆具有更好的平摊分析性能，它的合并操作的时间复杂度是O(1)。<br>与二项堆一样，它也是由一组堆最小有序树组成，并且是一种可合并堆。<br>与二项堆不同的是，斐波那契堆中的树不一定是二项树；而且二项堆中的树是有序排列的，但是斐波那契堆中的树都是有根而无序的。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/111642221538159.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm26qa506j30qa098aaq.jpg" alt="img"></a></p><h2 id="斐波那契堆的基本操作"><a href="#斐波那契堆的基本操作" class="headerlink" title="斐波那契堆的基本操作"></a><strong>斐波那契堆的基本操作</strong></h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FibHeap</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> keyNum;         <span class="hljs-comment">// 堆中节点的总数</span><br>    <span class="hljs-keyword">private</span> FibNode min;        <span class="hljs-comment">// 最小节点(某个最小堆的根节点)</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FibNode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> key;            <span class="hljs-comment">// 关键字(键值)</span><br>        <span class="hljs-keyword">int</span> degree;         <span class="hljs-comment">// 度数</span><br>        FibNode left;       <span class="hljs-comment">// 左兄弟</span><br>        FibNode right;      <span class="hljs-comment">// 右兄弟</span><br>        FibNode child;      <span class="hljs-comment">// 第一个孩子节点</span><br>        FibNode parent;     <span class="hljs-comment">// 父节点</span><br>        <span class="hljs-keyword">boolean</span> marked;     <span class="hljs-comment">// 是否被删除第一个孩子</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FibNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key    = key;<br>            <span class="hljs-keyword">this</span>.degree = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>.marked = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">this</span>.left   = <span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">this</span>.right  = <span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">this</span>.child  = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>FibNode</strong>是斐波那契堆的节点类，它包含的信息较多。key是用于比较节点大小的，degree是记录节点的度，left和right分别是指向节点的左右兄弟，child是节点的第一个孩子，parent是节点的父节点，marked是记录该节点是否被删除第1个孩子(marked在删除节点时有用)。<br><strong>FibHeap</strong>是斐波那契堆对应的类。min是保存当前堆的最小节点，keyNum用于记录堆中节点的总数，maxDegree用于记录堆中最大度，而cons在删除节点时来暂时保存堆数据的临时空间。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/111643182933476.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm29eesmsj31080u0mzh.jpg" alt="img"></a></p><p>上面是斐波那契堆的两种不同结构图的对比。从中可以看出，斐波那契堆是由一组最小堆组成，这些最小堆的根节点组成了双向链表(后文称为”<strong>根链表</strong>“)；斐波那契堆中的最小节点就是”根链表中的最小节点”！</p><h3 id="2-插入操作"><a href="#2-插入操作" class="headerlink" title="2. 插入操作"></a><strong>2. 插入操作</strong></h3><p>插入操作非常简单：插入一个节点到堆中，直接将该节点插入到”根链表的min节点”之前即可；若被插入节点比”min节点”小，则更新”min节点”为被插入节点。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/111644494183536.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm29vi11lj30eq0f9wez.jpg" alt="img"></a></p><p><em>上面是插入操作的示意图。</em></p><p>斐波那契堆的根链表是”双向链表”，这里将min节点看作双向联表的表头(后文也是如此)。在插入节点时，每次都是”将节点插入到min节点之前(即插入到双链表末尾)”。此外，对于根链表中最小堆都只有一个节点的情况，插入操作就很演化成双向链表的插入操作。</p><p>插入操作代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 将node堆结点加入root结点之前(循环链表中)<br> *   a …… root<br> *   a …… node …… root<br>*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(FibNode node, FibNode root)</span> </span>&#123;<br>    node.left        = root.left;<br>    root.left.right  = node;<br>    node.right       = root;<br>    root.left        = node;<br>&#125;<br> <br><span class="hljs-comment">/*<br> * 将节点node插入到斐波那契堆中<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(FibNode node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (keyNum == <span class="hljs-number">0</span>)<br>        min = node;<br>    <span class="hljs-keyword">else</span> &#123;<br>        addNode(node, min);<br>        <span class="hljs-keyword">if</span> (node.key &lt; min.key)<br>            min = node;<br>    &#125;<br><br>    keyNum++;<br>&#125;<br> <br><span class="hljs-comment">/* <br> * 新建键值为key的节点，并将其插入到斐波那契堆中<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    FibNode node;<br><br>    node = <span class="hljs-keyword">new</span> FibNode(key);<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> ;<br><br>    insert(node);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-合并操作"><a href="#3-合并操作" class="headerlink" title="3. 合并操作"></a><strong>3. 合并操作</strong></h3><p>合并操作和插入操作的原理非常类似：将一个堆的根链表插入到另一个堆的根链表上即可。简单来说，就是将两个双链表拼接成一个双向链表。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/111646216536924.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm2albn5kj30pr0ix3zv.jpg" alt="img"></a></p><p>合并操作代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br>* 将双向链表b链接到双向链表a的后面<br>*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">catList</span><span class="hljs-params">(FibNode a, FibNode b)</span> </span>&#123;<br>    FibNode tmp;<br><br>    tmp           = a.right;<br>    a.right       = b.right;<br>    b.right.left  = a;<br>    b.right       = tmp;<br>    tmp.left      = b;<br>&#125;<br><br><span class="hljs-comment">/*<br> * 将other合并到当前堆中<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(FibHeap other)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (other==<span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-keyword">if</span>((<span class="hljs-keyword">this</span>.min) == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// this无"最小节点"</span><br>        <span class="hljs-keyword">this</span>.min = other.min;<br>        <span class="hljs-keyword">this</span>.keyNum = other.keyNum;<br>        other = <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((other.min) == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// this有"最小节点" &amp;&amp; other无"最小节点"</span><br>        other = <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">// this有"最小节点" &amp;&amp; other有"最小节点"</span><br>        <span class="hljs-comment">// 将"other中根链表"添加到"this"中</span><br>    catList(<span class="hljs-keyword">this</span>.min, other.min) ;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.min.key &gt; other.min.key)<br>            <span class="hljs-keyword">this</span>.min = other.min;<br>        <span class="hljs-keyword">this</span>.keyNum += other.keyNum;<br>        other = <span class="hljs-keyword">null</span>;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-取出最小节点"><a href="#4-取出最小节点" class="headerlink" title="4. 取出最小节点"></a><strong>4. 取出最小节点</strong></h3><p>抽取最小结点的操作是斐波那契堆中较复杂的操作。<br>(1）将要抽取最小结点的子树都直接串联在根表中；<br>(2）合并所有degree相等的树，直到没有相等的degree的树。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm2bg4704j30sw3h2wqi.jpg" alt="img"></p><p>取出最小节点代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 将node链接到root根结点<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">link</span><span class="hljs-params">(FibNode node, FibNode root)</span> </span>&#123;<br>    <span class="hljs-comment">// 将node从双链表中移除</span><br>    removeNode(node);<br>    <span class="hljs-comment">// 将node设为root的孩子</span><br>    <span class="hljs-keyword">if</span> (root.child == <span class="hljs-keyword">null</span>)<br>        root.child = node;<br>    <span class="hljs-keyword">else</span><br>        addNode(node, root.child);<br><br>    node.parent = root;<br>    root.degree++;<br>    node.marked = <span class="hljs-keyword">false</span>;<br>&#125;<br> <br><span class="hljs-comment">/* <br> * 合并斐波那契堆的根链表中左右相同度数的树<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consolidate</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 计算log2(keyNum)，floor意味着向上取整！</span><br><span class="hljs-comment">// ex. log2(13) = 3，向上取整为4。</span><br>    <span class="hljs-keyword">int</span> maxDegree = (<span class="hljs-keyword">int</span>) Math.floor(Math.log(keyNum) / Math.log(<span class="hljs-number">2.0</span>));<br>    <span class="hljs-keyword">int</span> D = maxDegree + <span class="hljs-number">1</span>;<br>    FibNode[] cons = <span class="hljs-keyword">new</span> FibNode[D+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; D; i++)<br>        cons[i] = <span class="hljs-keyword">null</span>;<br> <br>    <span class="hljs-comment">// 合并相同度的根节点，使每个度数的树唯一</span><br>    <span class="hljs-keyword">while</span> (min != <span class="hljs-keyword">null</span>) &#123;<br>        FibNode x = extractMin();            <span class="hljs-comment">// 取出堆中的最小树(最小节点所在的树)</span><br>        <span class="hljs-keyword">int</span> d = x.degree;                        <span class="hljs-comment">// 获取最小树的度数</span><br>        <span class="hljs-comment">// cons[d] != null，意味着有两棵树(x和y)的"度数"相同。</span><br>        <span class="hljs-keyword">while</span> (cons[d] != <span class="hljs-keyword">null</span>) &#123;<br>            FibNode y = cons[d];                <span class="hljs-comment">// y是"与x的度数相同的树" </span><br>            <span class="hljs-keyword">if</span> (x.key &gt; y.key) &#123;    <span class="hljs-comment">// 保证x的键值比y小</span><br>                FibNode tmp = x;<br>                x = y;<br>                y = tmp;<br>            &#125;<br><br>            link(y, x);    <span class="hljs-comment">// 将y链接到x中</span><br>            cons[d] = <span class="hljs-keyword">null</span>;<br>            d++;<br>        &#125;<br>        cons[d] = x;<br>    &#125;<br>    min = <span class="hljs-keyword">null</span>;<br> <br>    <span class="hljs-comment">// 将cons中的结点重新加到根表中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;D; i++) &#123;<br><br>        <span class="hljs-keyword">if</span> (cons[i] != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-keyword">null</span>)<br>                min = cons[i];<br>            <span class="hljs-keyword">else</span> &#123;<br>                addNode(cons[i], min);<br>                <span class="hljs-keyword">if</span> ((cons[i]).key &lt; min.key)<br>                    min = cons[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">/*<br> * 移除最小节点<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeMin</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> ;<br><br>    FibNode m = min;<br>    <span class="hljs-comment">// 将min每一个儿子(儿子和儿子的兄弟)都添加到"斐波那契堆的根链表"中</span><br>    <span class="hljs-keyword">while</span> (m.child != <span class="hljs-keyword">null</span>) &#123;<br>        FibNode child = m.child;<br><br>        removeNode(child);<br>        <span class="hljs-keyword">if</span> (child.right == child)<br>            m.child = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">else</span><br>            m.child = child.right;<br><br>        addNode(child, min);<br>        child.parent = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将m从根链表中移除</span><br>    removeNode(m);<br>    <span class="hljs-comment">// 若m是堆中唯一节点，则设置堆的最小节点为null；</span><br>    <span class="hljs-comment">// 否则，设置堆的最小节点为一个非空节点(m.right)，然后再进行调节。</span><br>    <span class="hljs-keyword">if</span> (m.right == m)<br>        min = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        min = m.right;<br>        consolidate();<br>    &#125;<br>    keyNum--;<br><br>    m = <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-减小节点值"><a href="#5-减小节点值" class="headerlink" title="5. 减小节点值"></a><strong>5. 减小节点值</strong></h3><p>减少斐波那契堆中的节点的键值，这个操作的难点是：如果减少节点后破坏了”最小堆”性质，如何去维护呢？下面对一般性情况进行分析。<br>(1) 首先，将”被减小节点”从”它所在的最小堆”剥离出来；然后将”该节点”关联到”根链表”中。 倘若被减小的节点不是单独一个节点，而是包含子树的树根。则是将以”被减小节点”为根的子树从”最小堆”中剥离出来，然后将该树关联到根链表中。<br>(2) 接着，对”被减少节点”的原父节点进行”级联剪切”。所谓”级联剪切”，就是在被减小节点破坏了最小堆性质，并被切下来之后；再从”它的父节点”进行递归级联剪切操作。<br>   而级联操作的具体动作则是：若父节点(被减小节点的父节点)的marked标记为false，则将其设为true，然后退出。<br>                             否则，将父节点从最小堆中切下来(方式和”切被减小节点的方式”一样)；然后递归对祖父节点进行”级联剪切”。<br>   marked标记的作用就是用来标记”该节点的子节点是否有被删除过”，它的作用是来实现级联剪切。而级联剪切的真正目的是为了防止”最小堆”由二叉树演化成链表。<br>(3) 最后，别忘了对根链表的最小节点进行更新。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm2cc7b3xj30gb0qata7.jpg" alt="img"></p><p>减小节点值的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 修改度数<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">renewDegree</span><span class="hljs-params">(FibNode parent, <span class="hljs-keyword">int</span> degree)</span> </span>&#123;<br>    parent.degree -= degree;<br>    <span class="hljs-keyword">if</span> (parent. parent != <span class="hljs-keyword">null</span>)<br>        renewDegree(parent.parent, degree);<br>&#125;<br> <br><span class="hljs-comment">/* <br> * 将node从父节点parent的子链接中剥离出来，<br> * 并使node成为"堆的根链表"中的一员。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(FibNode node, FibNode parent)</span> </span>&#123;<br>    removeNode(node);<br>    renewDegree(parent, node.degree);<br>    <span class="hljs-comment">// node没有兄弟</span><br>    <span class="hljs-keyword">if</span> (node == node.right) <br>        parent.child = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">else</span> <br>        parent.child = node.right;<br><br>    node.parent = <span class="hljs-keyword">null</span>;<br>    node.left = node.right = node;<br>    node.marked = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 将"node所在树"添加到"根链表"中</span><br>    addNode(node, min);<br>&#125;<br><br><span class="hljs-comment">/* <br> * 对节点node进行"级联剪切"<br> *<br> * 级联剪切：如果减小后的结点破坏了最小堆性质，<br> *     则把它切下来(即从所在双向链表中删除，并将<br> *     其插入到由最小树根节点形成的双向链表中)，<br> *     然后再从"被切节点的父节点"到所在树根节点递归执行级联剪枝<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cascadingCut</span><span class="hljs-params">(FibNode node)</span> </span>&#123;<br>    FibNode parent = node.parent;<br><br>    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node.marked == <span class="hljs-keyword">false</span>) <br>            node.marked = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cut(node, parent);<br>            cascadingCut(parent);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* <br> * 将斐波那契堆中节点node的值减少为key<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(FibNode node, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span> ||node==<span class="hljs-keyword">null</span>) <br>        <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-keyword">if</span> (key &gt; node.key) &#123;<br>    System.out.printf(<span class="hljs-string">"decrease failed: the new key(%d) is no smaller than current key(%d)\n"</span>, key, node.key);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    FibNode parent = node.parent;<br>    node.key = key;<br>    <span class="hljs-keyword">if</span> (parent!=<span class="hljs-keyword">null</span> &amp;&amp; (node.key &lt; parent.key)) &#123;<br>        <span class="hljs-comment">// 将node从父节点parent中剥离出来，并将node添加到根链表中</span><br>        cut(node, parent);<br>        cascadingCut(parent);<br>    &#125;<br><br>    <span class="hljs-comment">// 更新最小节点</span><br>    <span class="hljs-keyword">if</span> (node.key &lt; min.key)<br>        min = node;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-增加节点值"><a href="#6-增加节点值" class="headerlink" title="6. 增加节点值"></a><strong>6. 增加节点值</strong></h3><p>增加节点值和减少节点值类似，这个操作的难点也是如何维护”最小堆”性质。思路如下：<br>(1) 将”被增加节点”的”左孩子和左孩子的所有兄弟”都链接到根链表中。<br>(2) 接下来，把”被增加节点”添加到根链表；但是别忘了对其进行级联剪切。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/111650112008396.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm2d0uo2wj30ic0xmtav.jpg" alt="img"></a></p><p>增加节点值的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 将斐波那契堆中节点node的值增加为key<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">(FibNode node, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span> ||node==<span class="hljs-keyword">null</span>) <br>        <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-keyword">if</span> ( key &lt;= node.key) &#123;<br>    System.out.printf(<span class="hljs-string">"increase failed: the new key(%d) is no greater than current key(%d)\n"</span>, key, node.key);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 将node每一个儿子(不包括孙子,重孙,...)都添加到"斐波那契堆的根链表"中</span><br>    <span class="hljs-keyword">while</span> (node.child != <span class="hljs-keyword">null</span>) &#123;<br>        FibNode child = node.child;<br>        removeNode(child);               <span class="hljs-comment">// 将child从node的子链表中删除</span><br>        <span class="hljs-keyword">if</span> (child.right == child)<br>            node.child = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">else</span><br>            node.child = child.right;<br><br>        addNode(child, min);       <span class="hljs-comment">// 将child添加到根链表中</span><br>        child.parent = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    node.degree = <span class="hljs-number">0</span>;<br>    node.key = key;<br><br>    <span class="hljs-comment">// 如果node不在根链表中，</span><br>    <span class="hljs-comment">//     则将node从父节点parent的子链接中剥离出来，</span><br>    <span class="hljs-comment">//     并使node成为"堆的根链表"中的一员，</span><br>    <span class="hljs-comment">//     然后进行"级联剪切"</span><br>    <span class="hljs-comment">// 否则，则判断是否需要更新堆的最小节点</span><br>    FibNode parent = node.parent;<br>    <span class="hljs-keyword">if</span>(parent != <span class="hljs-keyword">null</span>) &#123;<br>        cut(node, parent);<br>        cascadingCut(parent);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(min == node) &#123;<br>        FibNode right = node.right;<br>        <span class="hljs-keyword">while</span>(right != node) &#123;<br>            <span class="hljs-keyword">if</span>(node.key &gt; right.key)<br>                min = right;<br>            right = right.right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-删除节点"><a href="#7-删除节点" class="headerlink" title="7. 删除节点"></a><strong>7. 删除节点</strong></h3><p>删除节点，本文采用了操作是：”取出最小节点”和”减小节点值”的组合。<br>(1) 先将被删除节点的键值减少。减少后的值要比”原最小节点的值”即可。<br>(2) 接着，取出最小节点即可。</p><p>删除节点值的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 删除结点node<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(FibNode node)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = min.key;<br>    decrease(node, m-<span class="hljs-number">1</span>);<br>    removeMin();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="斐波那契堆的Java实现"><a href="#斐波那契堆的Java实现" class="headerlink" title="斐波那契堆的Java实现"></a><strong>斐波那契堆的Java实现</strong></h2><h3 id="斐波那契堆的实现文件-FibHeap-java"><a href="#斐波那契堆的实现文件-FibHeap-java" class="headerlink" title="斐波那契堆的实现文件(FibHeap.java)"></a>斐波那契堆的实现文件(FibHeap.java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FibHeap</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> keyNum;         <span class="hljs-comment">// 堆中节点的总数</span><br>    <span class="hljs-keyword">private</span> FibNode min;        <span class="hljs-comment">// 最小节点(某个最小堆的根节点)</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FibNode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> key;            <span class="hljs-comment">// 关键字(键值)</span><br>        <span class="hljs-keyword">int</span> degree;            <span class="hljs-comment">// 度数</span><br>        FibNode left;        <span class="hljs-comment">// 左兄弟</span><br>        FibNode right;        <span class="hljs-comment">// 右兄弟</span><br>        FibNode child;        <span class="hljs-comment">// 第一个孩子节点</span><br>        FibNode parent;        <span class="hljs-comment">// 父节点</span><br>        <span class="hljs-keyword">boolean</span> marked;     <span class="hljs-comment">// 是否被删除第一个孩子</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FibNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key    = key;<br>            <span class="hljs-keyword">this</span>.degree = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>.marked = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">this</span>.left   = <span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">this</span>.right  = <span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">this</span>.child  = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FibHeap</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.keyNum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.min = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将node从双链表移除<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(FibNode node)</span> </span>&#123;<br>        node.left.right = node.right;<br>        node.right.left = node.left;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将node堆结点加入root结点之前(循环链表中)<br>     *   a …… root<br>     *   a …… node …… root<br>    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(FibNode node, FibNode root)</span> </span>&#123;<br>        node.left        = root.left;<br>        root.left.right  = node;<br>        node.right       = root;<br>        root.left        = node;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将节点node插入到斐波那契堆中<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(FibNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (keyNum == <span class="hljs-number">0</span>)<br>            min = node;<br>        <span class="hljs-keyword">else</span> &#123;<br>            addNode(node, min);<br>            <span class="hljs-keyword">if</span> (node.key &lt; min.key)<br>                min = node;<br>        &#125;<br><br>        keyNum++;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 新建键值为key的节点，并将其插入到斐波那契堆中<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        FibNode node;<br><br>        node = <span class="hljs-keyword">new</span> FibNode(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        insert(node);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将双向链表b链接到双向链表a的后面<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">catList</span><span class="hljs-params">(FibNode a, FibNode b)</span> </span>&#123;<br>        FibNode tmp;<br><br>        tmp           = a.right;<br>        a.right       = b.right;<br>        b.right.left  = a;<br>        b.right       = tmp;<br>        tmp.left      = b;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将other合并到当前堆中<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(FibHeap other)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (other==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">this</span>.min) == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// this无"最小节点"</span><br>            <span class="hljs-keyword">this</span>.min = other.min;<br>            <span class="hljs-keyword">this</span>.keyNum = other.keyNum;<br>            other = <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((other.min) == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// this有"最小节点" &amp;&amp; other无"最小节点"</span><br>            other = <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">// this有"最小节点" &amp;&amp; other有"最小节点"</span><br>            <span class="hljs-comment">// 将"other中根链表"添加到"this"中</span><br>            catList(<span class="hljs-keyword">this</span>.min, other.min) ;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.min.key &gt; other.min.key)<br>                <span class="hljs-keyword">this</span>.min = other.min;<br>            <span class="hljs-keyword">this</span>.keyNum += other.keyNum;<br>            other = <span class="hljs-keyword">null</span>;;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将"堆的最小结点"从根链表中移除，<br>     * 这意味着"将最小节点所属的树"从堆中移除!<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> FibNode <span class="hljs-title">extractMin</span><span class="hljs-params">()</span> </span>&#123;<br>        FibNode p = min;<br><br>        <span class="hljs-keyword">if</span> (p == p.right)<br>            min = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            removeNode(p);<br>            min = p.right;<br>        &#125;<br>        p.left = p.right = p;<br><br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将node链接到root根结点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">link</span><span class="hljs-params">(FibNode node, FibNode root)</span> </span>&#123;<br>        <span class="hljs-comment">// 将node从双链表中移除</span><br>        removeNode(node);<br>        <span class="hljs-comment">// 将node设为root的孩子</span><br>        <span class="hljs-keyword">if</span> (root.child == <span class="hljs-keyword">null</span>)<br>            root.child = node;<br>        <span class="hljs-keyword">else</span><br>            addNode(node, root.child);<br><br>        node.parent = root;<br>        root.degree++;<br>        node.marked = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 合并斐波那契堆的根链表中左右相同度数的树<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consolidate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 计算log2(keyNum)，floor意味着向上取整！</span><br>        <span class="hljs-comment">// ex. log2(13) = 3，向上取整为4。</span><br>        <span class="hljs-keyword">int</span> maxDegree = (<span class="hljs-keyword">int</span>) Math.floor(Math.log(keyNum) / Math.log(<span class="hljs-number">2.0</span>));<br>        <span class="hljs-keyword">int</span> D = maxDegree + <span class="hljs-number">1</span>;<br>        FibNode[] cons = <span class="hljs-keyword">new</span> FibNode[D+<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; D; i++)<br>            cons[i] = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 合并相同度的根节点，使每个度数的树唯一</span><br>        <span class="hljs-keyword">while</span> (min != <span class="hljs-keyword">null</span>) &#123;<br>            FibNode x = extractMin();            <span class="hljs-comment">// 取出堆中的最小树(最小节点所在的树)</span><br>            <span class="hljs-keyword">int</span> d = x.degree;                        <span class="hljs-comment">// 获取最小树的度数</span><br>            <span class="hljs-comment">// cons[d] != null，意味着有两棵树(x和y)的"度数"相同。</span><br>            <span class="hljs-keyword">while</span> (cons[d] != <span class="hljs-keyword">null</span>) &#123;<br>                FibNode y = cons[d];                <span class="hljs-comment">// y是"与x的度数相同的树"</span><br>                <span class="hljs-keyword">if</span> (x.key &gt; y.key) &#123;    <span class="hljs-comment">// 保证x的键值比y小</span><br>                    FibNode tmp = x;<br>                    x = y;<br>                    y = tmp;<br>                &#125;<br><br>                link(y, x);    <span class="hljs-comment">// 将y链接到x中</span><br>                cons[d] = <span class="hljs-keyword">null</span>;<br>                d++;<br>            &#125;<br>            cons[d] = x;<br>        &#125;<br>        min = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 将cons中的结点重新加到根表中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;D; i++) &#123;<br><br>            <span class="hljs-keyword">if</span> (cons[i] != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (min == <span class="hljs-keyword">null</span>)<br>                    min = cons[i];<br>                <span class="hljs-keyword">else</span> &#123;<br>                    addNode(cons[i], min);<br>                    <span class="hljs-keyword">if</span> ((cons[i]).key &lt; min.key)<br>                        min = cons[i];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 移除最小节点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        FibNode m = min;<br>        <span class="hljs-comment">// 将min每一个儿子(儿子和儿子的兄弟)都添加到"斐波那契堆的根链表"中</span><br>        <span class="hljs-keyword">while</span> (m.child != <span class="hljs-keyword">null</span>) &#123;<br>            FibNode child = m.child;<br><br>            removeNode(child);<br>            <span class="hljs-keyword">if</span> (child.right == child)<br>                m.child = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">else</span><br>                m.child = child.right;<br><br>            addNode(child, min);<br>            child.parent = <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 将m从根链表中移除</span><br>        removeNode(m);<br>        <span class="hljs-comment">// 若m是堆中唯一节点，则设置堆的最小节点为null；</span><br>        <span class="hljs-comment">// 否则，设置堆的最小节点为一个非空节点(m.right)，然后再进行调节。</span><br>        <span class="hljs-keyword">if</span> (m.right == m)<br>            min = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            min = m.right;<br>            consolidate();<br>        &#125;<br>        keyNum--;<br><br>        m = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 获取斐波那契堆中最小键值；失败返回-1<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimum</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">return</span> min.key;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 修改度数<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">renewDegree</span><span class="hljs-params">(FibNode parent, <span class="hljs-keyword">int</span> degree)</span> </span>&#123;<br>        parent.degree -= degree;<br>        <span class="hljs-keyword">if</span> (parent. parent != <span class="hljs-keyword">null</span>)<br>            renewDegree(parent.parent, degree);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将node从父节点parent的子链接中剥离出来，<br>     * 并使node成为"堆的根链表"中的一员。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(FibNode node, FibNode parent)</span> </span>&#123;<br>        removeNode(node);<br>        renewDegree(parent, node.degree);<br>        <span class="hljs-comment">// node没有兄弟</span><br>        <span class="hljs-keyword">if</span> (node == node.right)<br>            parent.child = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">else</span><br>            parent.child = node.right;<br><br>        node.parent = <span class="hljs-keyword">null</span>;<br>        node.left = node.right = node;<br>        node.marked = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 将"node所在树"添加到"根链表"中</span><br>        addNode(node, min);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 对节点node进行"级联剪切"<br>     *<br>     * 级联剪切：如果减小后的结点破坏了最小堆性质，<br>     *     则把它切下来(即从所在双向链表中删除，并将<br>     *     其插入到由最小树根节点形成的双向链表中)，<br>     *     然后再从"被切节点的父节点"到所在树根节点递归执行级联剪枝<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cascadingCut</span><span class="hljs-params">(FibNode node)</span> </span>&#123;<br>        FibNode parent = node.parent;<br><br>        <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (node.marked == <span class="hljs-keyword">false</span>)<br>                node.marked = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cut(node, parent);<br>                cascadingCut(parent);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将斐波那契堆中节点node的值减少为key<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(FibNode node, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span> ||node==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span> (key &gt; node.key) &#123;<br>            System.out.printf(<span class="hljs-string">"decrease failed: the new key(%d) is no smaller than current key(%d)\n"</span>, key, node.key);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        FibNode parent = node.parent;<br>        node.key = key;<br>        <span class="hljs-keyword">if</span> (parent!=<span class="hljs-keyword">null</span> &amp;&amp; (node.key &lt; parent.key)) &#123;<br>            <span class="hljs-comment">// 将node从父节点parent中剥离出来，并将node添加到根链表中</span><br>            cut(node, parent);<br>            cascadingCut(parent);<br>        &#125;<br><br>        <span class="hljs-comment">// 更新最小节点</span><br>        <span class="hljs-keyword">if</span> (node.key &lt; min.key)<br>            min = node;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将斐波那契堆中节点node的值增加为key<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">(FibNode node, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span> ||node==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span> ( key &lt;= node.key) &#123;<br>            System.out.printf(<span class="hljs-string">"increase failed: the new key(%d) is no greater than current key(%d)\n"</span>, key, node.key);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-comment">// 将node每一个儿子(不包括孙子,重孙,...)都添加到"斐波那契堆的根链表"中</span><br>        <span class="hljs-keyword">while</span> (node.child != <span class="hljs-keyword">null</span>) &#123;<br>            FibNode child = node.child;<br>            removeNode(child);               <span class="hljs-comment">// 将child从node的子链表中删除</span><br>            <span class="hljs-keyword">if</span> (child.right == child)<br>                node.child = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">else</span><br>                node.child = child.right;<br><br>            addNode(child, min);       <span class="hljs-comment">// 将child添加到根链表中</span><br>            child.parent = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        node.degree = <span class="hljs-number">0</span>;<br>        node.key = key;<br><br>        <span class="hljs-comment">// 如果node不在根链表中，</span><br>        <span class="hljs-comment">//     则将node从父节点parent的子链接中剥离出来，</span><br>        <span class="hljs-comment">//     并使node成为"堆的根链表"中的一员，</span><br>        <span class="hljs-comment">//     然后进行"级联剪切"</span><br>        <span class="hljs-comment">// 否则，则判断是否需要更新堆的最小节点</span><br>        FibNode parent = node.parent;<br>        <span class="hljs-keyword">if</span>(parent != <span class="hljs-keyword">null</span>) &#123;<br>            cut(node, parent);<br>            cascadingCut(parent);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(min == node) &#123;<br>            FibNode right = node.right;<br>            <span class="hljs-keyword">while</span>(right != node) &#123;<br>                <span class="hljs-keyword">if</span>(node.key &gt; right.key)<br>                    min = right;<br>                right = right.right;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 更新斐波那契堆的节点node的键值为key<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(FibNode node, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(key &lt; node.key)<br>            decrease(node, key);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; node.key)<br>            increase(node, key);<br>        <span class="hljs-keyword">else</span><br>            System.out.printf(<span class="hljs-string">"No need to update!!!\n"</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> oldkey, <span class="hljs-keyword">int</span> newkey)</span> </span>&#123;<br>        FibNode node;<br><br>        node = search(oldkey);<br>        <span class="hljs-keyword">if</span> (node!=<span class="hljs-keyword">null</span>)<br>            update(node, newkey);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 在最小堆root中查找键值为key的节点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> FibNode <span class="hljs-title">search</span><span class="hljs-params">(FibNode root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        FibNode t = root;    <span class="hljs-comment">// 临时节点</span><br>        FibNode p = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 要查找的节点</span><br><br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> (t.key == key) &#123;<br>                p = t;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> ((p = search(t.child, key)) != <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            t = t.right;<br>        &#125; <span class="hljs-keyword">while</span> (t != root);<br><br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 在斐波那契堆中查找键值为key的节点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> FibNode <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">return</span> search(min, key);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 在斐波那契堆中是否存在键值为key的节点。<br>     * 存在返回true，否则返回false。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> search(key)!=<span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span>: <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 删除结点node<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(FibNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = min.key;<br>        decrease(node, m-<span class="hljs-number">1</span>);<br>        removeMin();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        FibNode node = search(key);<br>        <span class="hljs-keyword">if</span> (node==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        remove(node);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 销毁斐波那契堆<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroyNode</span><span class="hljs-params">(FibNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span>;<br><br>        FibNode start = node;<br>        <span class="hljs-keyword">do</span> &#123;<br>            destroyNode(node.child);<br>            <span class="hljs-comment">// 销毁node，并将node指向下一个</span><br>            node = node.right;<br>            node.left = <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">while</span>(node != start);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>        destroyNode(min);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 打印"斐波那契堆"<br>     *<br>     * 参数说明：<br>     *     node       -- 当前节点<br>     *     prev       -- 当前节点的前一个节点(父节点or兄弟节点)<br>     *     direction  --  1，表示当前节点是一个左孩子;<br>     *                    2，表示当前节点是一个兄弟节点。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(FibNode node, FibNode prev, <span class="hljs-keyword">int</span> direction)</span> </span>&#123;<br>        FibNode start=node;<br><br>        <span class="hljs-keyword">if</span> (node==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> (direction == <span class="hljs-number">1</span>)<br>                System.out.printf(<span class="hljs-string">"%8d(%d) is %2d's child\n"</span>, node.key, node.degree, prev.key);<br>            <span class="hljs-keyword">else</span><br>                System.out.printf(<span class="hljs-string">"%8d(%d) is %2d's next\n"</span>, node.key, node.degree, prev.key);<br><br>            <span class="hljs-keyword">if</span> (node.child != <span class="hljs-keyword">null</span>)<br>                print(node.child, node, <span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// 兄弟节点</span><br>            prev = node;<br>            node = node.right;<br>            direction = <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">while</span>(node != start);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        FibNode p = min;<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆的详细信息: ==\n"</span>);<br>        <span class="hljs-keyword">do</span> &#123;<br>            i++;<br>            System.out.printf(<span class="hljs-string">"%2d. %4d(%d) is root\n"</span>, i, p.key, p.degree);<br><br>            print(p.child, p, <span class="hljs-number">1</span>);<br>            p = p.right;<br>        &#125; <span class="hljs-keyword">while</span> (p != min);<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="斐波那契堆的测试程序-Main-java"><a href="#斐波那契堆的测试程序-Main-java" class="headerlink" title="斐波那契堆的测试程序(Main.java)"></a>斐波那契堆的测试程序(Main.java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> DEBUG = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">// 共8个</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">12</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">25</span>, <span class="hljs-number">15</span>, <span class="hljs-number">28</span>, <span class="hljs-number">33</span>, <span class="hljs-number">41</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-comment">// 共14个</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b[] = &#123;<span class="hljs-number">18</span>, <span class="hljs-number">35</span>, <span class="hljs-number">20</span>, <span class="hljs-number">42</span>,  <span class="hljs-number">9</span>,<br>                                 <span class="hljs-number">31</span>, <span class="hljs-number">23</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">48</span>, <span class="hljs-number">11</span>,<br>                              <span class="hljs-number">24</span>, <span class="hljs-number">52</span>, <span class="hljs-number">13</span>,  <span class="hljs-number">2</span> &#125;;<br><br>    <span class="hljs-comment">// 验证"基本信息(斐波那契堆的结构)"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testBasic</span><span class="hljs-params">()</span> </span>&#123;<br>        FibHeap hb=<span class="hljs-keyword">new</span> FibHeap();<br><br>        <span class="hljs-comment">// 斐波那契堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)删除最小节点\n"</span>);<br>        hb.removeMin();<br>        hb.print(); <span class="hljs-comment">// 打印斐波那契堆hb</span><br>    &#125;<br><br>    <span class="hljs-comment">// 验证"插入操作"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsert</span><span class="hljs-params">()</span> </span>&#123;<br>        FibHeap ha=<span class="hljs-keyword">new</span> FibHeap();<br><br>        <span class="hljs-comment">// 斐波那契堆ha</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(ha)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            ha.insert(a[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(ha)删除最小节点\n"</span>);<br>        ha.removeMin();<br>        ha.print(); <span class="hljs-comment">// 打印斐波那契堆ha</span><br><br>        System.out.printf(<span class="hljs-string">"== 插入50\n"</span>);<br>        ha.insert(<span class="hljs-number">50</span>);<br>        ha.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"合并操作"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUnion</span><span class="hljs-params">()</span> </span>&#123;<br>        FibHeap ha=<span class="hljs-keyword">new</span> FibHeap();<br>        FibHeap hb=<span class="hljs-keyword">new</span> FibHeap();<br><br>        <span class="hljs-comment">// 斐波那契堆ha</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(ha)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            ha.insert(a[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(ha)删除最小节点\n"</span>);<br>        ha.removeMin();<br>        ha.print(); <span class="hljs-comment">// 打印斐波那契堆ha</span><br><br>        <span class="hljs-comment">// 斐波那契堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)删除最小节点\n"</span>);<br>        hb.removeMin();<br>        hb.print(); <span class="hljs-comment">// 打印斐波那契堆hb</span><br><br>        <span class="hljs-comment">// 将"斐波那契堆hb"合并到"斐波那契堆ha"中。</span><br>        System.out.printf(<span class="hljs-string">"== 合并ha和hb\n"</span>);<br>        ha.union(hb);<br>        ha.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"删除最小节点"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRemoveMin</span><span class="hljs-params">()</span> </span>&#123;<br>        FibHeap ha=<span class="hljs-keyword">new</span> FibHeap();<br>        FibHeap hb=<span class="hljs-keyword">new</span> FibHeap();<br><br>        <span class="hljs-comment">// 斐波那契堆ha</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(ha)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            ha.insert(a[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(ha)删除最小节点\n"</span>);<br>        ha.removeMin();<br>        <span class="hljs-comment">//ha.print(); // 打印斐波那契堆ha</span><br><br>        <span class="hljs-comment">// 斐波那契堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)删除最小节点\n"</span>);<br>        hb.removeMin();<br>        <span class="hljs-comment">//hb.print(); // 打印斐波那契堆hb</span><br><br>        <span class="hljs-comment">// 将"斐波那契堆hb"合并到"斐波那契堆ha"中。</span><br>        System.out.printf(<span class="hljs-string">"== 合并ha和hb\n"</span>);<br>        ha.union(hb);<br>        ha.print();<br><br>        System.out.printf(<span class="hljs-string">"== 删除最小节点\n"</span>);<br>        ha.removeMin();<br>        ha.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"减小节点"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDecrease</span><span class="hljs-params">()</span> </span>&#123;<br>        FibHeap hb=<span class="hljs-keyword">new</span> FibHeap();<br><br>        <span class="hljs-comment">// 斐波那契堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)删除最小节点\n"</span>);<br>        hb.removeMin();<br>        hb.print(); <span class="hljs-comment">// 打印斐波那契堆hb</span><br><br>        System.out.printf(<span class="hljs-string">"== 将20减小为2\n"</span>);<br>        hb.update(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>);<br>        hb.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"增大节点"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIncrease</span><span class="hljs-params">()</span> </span>&#123;<br>        FibHeap hb=<span class="hljs-keyword">new</span> FibHeap();<br><br>        <span class="hljs-comment">// 斐波那契堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)删除最小节点\n"</span>);<br>        hb.removeMin();<br>        hb.print(); <span class="hljs-comment">// 打印斐波那契堆hb</span><br><br>        System.out.printf(<span class="hljs-string">"== 将20增加为60\n"</span>);<br>        hb.update(<span class="hljs-number">20</span>, <span class="hljs-number">60</span>);<br>        hb.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"删除节点"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span> </span>&#123;<br>        FibHeap hb=<span class="hljs-keyword">new</span> FibHeap();<br><br>        <span class="hljs-comment">// 斐波那契堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)删除最小节点\n"</span>);<br>        hb.removeMin();<br>        hb.print(); <span class="hljs-comment">// 打印斐波那契堆hb</span><br><br>        System.out.printf(<span class="hljs-string">"== 删除节点20\n"</span>);<br>        hb.remove(<span class="hljs-number">20</span>);<br>        hb.print();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 验证"基本信息(斐波那契堆的结构)"</span><br>        testBasic();<br>        <span class="hljs-comment">// 验证"插入操作"</span><br>        <span class="hljs-comment">//testInsert();</span><br>        <span class="hljs-comment">// 验证"合并操作"</span><br>        <span class="hljs-comment">//testUnion();</span><br>        <span class="hljs-comment">// 验证"删除最小节点"</span><br>        <span class="hljs-comment">//testRemoveMin();</span><br>        <span class="hljs-comment">// 验证"减小节点"</span><br>        <span class="hljs-comment">//testDecrease();</span><br>        <span class="hljs-comment">// 验证"增大节点"</span><br>        <span class="hljs-comment">//testIncrease();</span><br>        <span class="hljs-comment">// 验证"删除节点"</span><br>        <span class="hljs-comment">//testDelete();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">== 斐波那契堆(hb)中依次添加: 18 35 20 42 9 31 23 6 48 11 24 52 13 2 </span><br><span class="hljs-section">== 斐波那契堆(hb)删除最小节点</span><br><span class="hljs-section">== 斐波那契堆的详细信息: ==</span><br><span class="hljs-code"> 1.    6(3) is root</span><br><span class="hljs-code">       9(0) is  6's child</span><br><span class="hljs-code">      18(1) is  9's next</span><br><span class="hljs-code">      35(0) is 18's child</span><br><span class="hljs-code">      20(2) is 18's next</span><br><span class="hljs-code">      42(0) is 20's child</span><br><span class="hljs-code">      23(1) is 42's next</span><br><span class="hljs-code">      31(0) is 23's child</span><br><span class="hljs-code"> 2.   11(2) is root</span><br><span class="hljs-code">      48(0) is 11's child</span><br><span class="hljs-code">      24(1) is 48's next</span><br><span class="hljs-code">      52(0) is 24's child</span><br><span class="hljs-code"> 3.   13(0) is root</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.4.二项堆</title>
      <link href="/2021/11/17/6.4.%E4%BA%8C%E9%A1%B9%E5%A0%86/"/>
      <url>/2021/11/17/6.4.%E4%BA%8C%E9%A1%B9%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="二项堆"><a href="#二项堆" class="headerlink" title="二项堆"></a>二项堆</h1><p>二项堆是二项树的集合。在了解二项堆之前，先对二项树进行介绍。</p><h2 id="二项树的介绍"><a href="#二项树的介绍" class="headerlink" title="二项树的介绍"></a>二项树的介绍</h2><h3 id="二项树的定义"><a href="#二项树的定义" class="headerlink" title="二项树的定义"></a><strong>二项树的定义</strong></h3><p>二项堆是二项树的集合。在了解二项堆之前，先对二项树进行介绍。</p><p>二项树是一种递归定义的有序树。它的递归定义如下：<br>(01) 二项树B0只有一个结点；<br>(02) 二项树Bk由两棵二项树B(k-1)组成的，其中一棵树是另一棵树根的最左孩子。<br>如下图所示：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/101009066844094.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm1jxjzu1j312v0cdab5.jpg" alt="img"></a></p><p>上图的B0、B1、B2、B3、B4都是二项树。对比前面提到的二项树的定义：B0只有一个节点，B1由两个B0所组成，B2由两个B1所组成，B3由两个B2所组成，B4由两个B3所组成；而且，当两颗相同的二项树组成另一棵树时，其中一棵树是另一棵树的最左孩子。</p><h3 id="二项树的性质"><a href="#二项树的性质" class="headerlink" title="二项树的性质"></a><strong>二项树的性质</strong></h3><p>二项树有以下性质：<br>[性质一] Bk共有2k个节点。<br>        如上图所示，B0有20=1节点，B1有21=2个节点，B2有22=4个节点，…<br>[性质二] Bk的高度为k。<br>        如上图所示，B0的高度为0，B1的高度为1，B2的高度为2，…<br>[性质三] Bk在深度i处恰好有C(k,i)个节点，其中i=0,1,2,…,k。<br>       C(k,i)是高中数学中阶乘元素，例如，C(10,3)=(10<em>9</em>8) / (3<em>2</em>1)=240<br>       B4中深度为0的节点C(4,0)=1<br>       B4中深度为1的节点C(4,1)= 4 / 1 = 4<br>       B4中深度为2的节点C(4,2)= (4<em>3) / (2</em>1) = 6<br>       B4中深度为3的节点C(4,3)= (4<em>3</em>2) / (3<em>2</em>1) = 4<br>       B4中深度为4的节点C(4,4)= (4<em>3</em>2<em>1) / (4</em>3<em>2</em>1) = 1<br>       合计得到B4的节点分布是(1,4,6,4,1)。<br>[性质四] 根的度数为k，它大于任何其它节点的度数。<br>       节点的度数是该结点拥有的子树的数目。</p><h2 id="二项堆的介绍"><a href="#二项堆的介绍" class="headerlink" title="二项堆的介绍"></a>二项堆的介绍</h2><p>二项堆和之前所讲的堆(<a href="http://www.cnblogs.com/skywang12345/p/3610390.html" target="_blank" rel="noopener">二叉堆</a>、<a href="http://www.cnblogs.com/skywang12345/p/3638384.html" target="_blank" rel="noopener">左倾堆</a>、<a href="http://www.cnblogs.com/skywang12345/p/3638552.html" target="_blank" rel="noopener">斜堆</a>)一样，也是用于实现优先队列的。</p><p>二项堆是指满足以下性质的二项树的集合：<br>(1) 每棵二项树都满足最小堆性质。即，父节点的关键字 &lt;= 它的孩子的关键字。<br>(2) 不能有两棵或以上的二项树具有相同的度数(包括度数为0)。换句话说，具有度数k的二项树有0个或1个。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/101016180284317.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm1m0qzx7j30gu0a4mxl.jpg" alt="img"></a></p><p>上图就是一棵二项堆，它由二项树B0、B2和B3组成。</p><p>对比二项堆的定义：</p><p>(1)二项树B0、B2、B3都是最小堆；</p><p>(0)二项堆不包含相同度数的二项树。</p><p>​     二项堆的第(1)个性质保证了二项堆的最小节点就是某个二项树的根节点，第(2)个性质则说明结点数为n的二项堆最多只有log{n} + 1棵二项树。实际上，将包含n个节点的二项堆，表示成若干个2的指数和(或者转换成二进制)，则每一个2个指数都对应一棵二项树。例如，13(二进制是1101)的2个指数和为13=23 + 22+ 20, 因此具有13个节点的二项堆由度数为3, 2, 0的三棵二项树组成。</p><h2 id="二项堆的基本操作"><a href="#二项堆的基本操作" class="headerlink" title="二项堆的基本操作"></a>二项堆的基本操作</h2><p>二项堆是可合并堆，它的合并操作的复杂度是O(log n)。</p><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinomialHeap</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; mRoot;    <span class="hljs-comment">// 根结点</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinomialNode</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        T key;                <span class="hljs-comment">// 关键字(键值)</span><br>        <span class="hljs-keyword">int</span> degree;            <span class="hljs-comment">// 度数</span><br>        BinomialNode&lt;T&gt; child;    <span class="hljs-comment">// 左孩子</span><br>        BinomialNode&lt;T&gt; parent;    <span class="hljs-comment">// 父节点</span><br>        BinomialNode&lt;T&gt; next;    <span class="hljs-comment">// 兄弟节点</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinomialNode</span><span class="hljs-params">(T key)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.degree = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>.child = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"key:"</span>+key;<br>        &#125;<br>    &#125;<br>        <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>BinomialNode是二项堆的节点。它包括了关键字(key)，用于比较节点大小；度数(degree)，用来表示当前节点的度数；左孩子(child)、父节点(parent)以及兄弟节点(next)。<br>BinomialHeap是二项堆对应的类，它包括了二项堆的根节点mRoot以及二项堆的基本操作的定义。</p><p>下面是一棵二项堆的树形图和它对应的内存结构关系图。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/101021406063534.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm1obcyadj30u00ux40c.jpg" alt="img"></a></p><h3 id="2-合并操作"><a href="#2-合并操作" class="headerlink" title="2. 合并操作"></a><strong>2. 合并操作</strong></h3><p>合并操作是二项堆的重点，它的添加操作也是基于合并操作来实现的。合并两个二项堆，需要的步骤概括起来如下：<br>(1) 将两个二项堆的根链表合并成一个链表。合并后的新链表按照”节点的度数”单调递增排列。<br>(2) 将新链表中”根节点度数相同的二项树”连接起来，直到所有根节点度数都不相同。</p><p>下面，先看看合并操作的代码；然后再通过示意图对合并操作进行说明。</p><p>merge()代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 将h1, h2中的根表合并成一个按度数递增的链表，返回合并后的根节点<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">merge</span><span class="hljs-params">(BinomialNode&lt;T&gt; h1, BinomialNode&lt;T&gt; h2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (h1 == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> h2;<br>    <span class="hljs-keyword">if</span> (h2 == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> h1;<br><br>    <span class="hljs-comment">// root是新堆的根，h3用来遍历h1和h3的。</span><br>    BinomialNode&lt;T&gt; pre_h3, h3, root=<span class="hljs-keyword">null</span>;<br><br>    pre_h3 = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//整个while，h1, h2, pre_h3, h3都在往后顺移</span><br>    <span class="hljs-keyword">while</span> ((h1!=<span class="hljs-keyword">null</span>) &amp;&amp; (h2!=<span class="hljs-keyword">null</span>)) &#123;<br><br>        <span class="hljs-keyword">if</span> (h1.degree &lt;= h2.degree) &#123;<br>            h3 = h1;<br>            h1 = h1.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            h3 = h2;<br>            h2 = h2.next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (pre_h3 == <span class="hljs-keyword">null</span>) &#123;<br>            pre_h3 = h3;<br>            root = h3;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pre_h3.next = h3;<br>            pre_h3 = h3;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (h1 != <span class="hljs-keyword">null</span>) &#123;<br>            h3.next = h1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            h3.next = h2;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>link()代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 合并两个二项堆：将child合并到root中<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">link</span><span class="hljs-params">(BinomialNode&lt;T&gt; child, BinomialNode&lt;T&gt; root)</span> </span>&#123;<br>    child.parent = root;<br>    child.next   = root.child;<br>    root.child = child;<br>    root.degree++;<br>&#125;<br></code></pre></td></tr></table></figure><p>合并操作代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 合并二项堆：将h1, h2合并成一个堆，并返回合并后的堆<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">union</span><span class="hljs-params">(BinomialNode&lt;T&gt; h1, BinomialNode&lt;T&gt; h2)</span> </span>&#123;<br>    BinomialNode&lt;T&gt; root;<br><br>    <span class="hljs-comment">// 将h1, h2中的根表合并成一个按度数递增的链表root</span><br>    root = merge(h1, h2);<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    BinomialNode&lt;T&gt; prev_x = <span class="hljs-keyword">null</span>;<br>    BinomialNode&lt;T&gt; x      = root;<br>    BinomialNode&lt;T&gt; next_x = x.next;<br>    <span class="hljs-keyword">while</span> (next_x != <span class="hljs-keyword">null</span>) &#123;<br><br>        <span class="hljs-keyword">if</span> (   (x.degree != next_x.degree)<br>            || ((next_x.next != <span class="hljs-keyword">null</span>) &amp;&amp; (next_x.degree == next_x.next.degree))) &#123;<br>            <span class="hljs-comment">// Case 1: x.degree != next_x.degree</span><br>            <span class="hljs-comment">// Case 2: x.degree == next_x.degree == next_x.next.degree</span><br>            prev_x = x;<br>            x = next_x;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.key.compareTo(next_x.key) &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Case 3: x.degree == next_x.degree != next_x.next.degree</span><br>            <span class="hljs-comment">//      &amp;&amp; x.key    &lt;= next_x.key</span><br>            x.next = next_x.next;<br>            link(next_x, x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Case 4: x.degree == next_x.degree != next_x.next.degree</span><br>            <span class="hljs-comment">//      &amp;&amp; x.key    &gt;  next_x.key</span><br>            <span class="hljs-keyword">if</span> (prev_x == <span class="hljs-keyword">null</span>) &#123;<br>                root = next_x;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prev_x.next = next_x;<br>            &#125;<br>            link(x, next_x);<br>            x = next_x;<br>        &#125;<br>        next_x = x.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-comment">/*<br> * 将二项堆other合并到当前堆中<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(BinomialHeap&lt;T&gt; other)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (other!=<span class="hljs-keyword">null</span> &amp;&amp; other.mRoot!=<span class="hljs-keyword">null</span>)<br>        mRoot = union(mRoot, other.mRoot);<br>&#125;<br></code></pre></td></tr></table></figure><p>合并函数combine(h1, h2)的作用是将h1和h2合并，并返回合并后的二项堆。在combine(h1, h2)中，涉及到了两个函数merge(h1, h2)和link(child, root)。<br>merge(h1, h2)就是我们前面所说的”两个二项堆的根链表合并成一个链表，合并后的新链表按照’节点的度数’单调递增排序”。<br>link(child, root)则是为了合并操作的辅助函数，它的作用是将”二项堆child的根节点”设为”二项堆root的左孩子”，从而将child整合到root中去。</p><p>​    在combine(h1, h2)中对h1和h2进行合并时；首先通过 merge(h1, h2) 将h1和h2的根链表合并成一个”按节点的度数单调递增”的链表；然后进入while循环，对合并得到的新链表进行遍历，将新链表中”根节点度数相同的二项树”连接起来，直到所有根节点度数都不相同为止。在将新联表中”根节点度数相同的二项树”连接起来时，可以将被连接的情况概括为4种。</p><p><em>x是根链表的当前节点，next_x是x的下一个(兄弟)节点。</em><br><strong>Case 1</strong>: x-&gt;degree != next_x-&gt;degree<br>       即，”当前节点的度数”与”下一个节点的度数”相等时。此时，不需要执行任何操作，继续查看后面的节点。<br><strong>Case 2</strong>: x-&gt;degree == next_x-&gt;degree == next_x-&gt;next-&gt;degree<br>       即，”当前节点的度数”、”下一个节点的度数”和”下下一个节点的度数”都相等时。此时，暂时不执行任何操作，还是继续查看后面的节点。实际上，这里是将”下一个节点”和”下下一个节点”等到后面再进行整合连接。<br><strong>Case 3</strong>: x-&gt;degree == next_x-&gt;degree != next_x-&gt;next-&gt;degree<br>    &amp;&amp; x-&gt;key &lt;= next_x-&gt;key<br>       即，”当前节点的度数”与”下一个节点的度数”相等，并且”当前节点的键值”&lt;=”下一个节点的度数”。此时，将”下一个节点(对应的二项树)”作为”当前节点(对应的二项树)的左孩子”。<br><strong>Case 4</strong>: x-&gt;degree == next_x-&gt;degree != next_x-&gt;next-&gt;degree<br>    &amp;&amp; x-&gt;key &gt; next_x-&gt;key<br>       即，”当前节点的度数”与”下一个节点的度数”相等，并且”当前节点的键值”&gt;”下一个节点的度数”。此时，将”当前节点(对应的二项树)”作为”下一个节点(对应的二项树)的左孩子”。</p><p>下面通过示意图来对合并操作进行说明。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/101030524817766.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm1qyz43wj30u01r3q82.jpg" alt="img"></a></p><p><strong>第1步</strong>：将两个二项堆的根链表合并成一个链表<br>     执行完第1步之后，得到的新链表中有许多度数相同的二项树。实际上，此时得到的是对应”Case 4”的情况，”树41”(根节点为41的二项树)和”树13”的度数相同，且”树41”的键值 &gt; “树13”的键值。此时，将”树41”作为”树13”的左孩子。<br><strong>第2步</strong>：合并”树41”和”树13”<br>     执行完第2步之后，得到的是对应”Case 3”的情况，”树13”和”树28”的度数相同，且”树13”的键值 &lt; “树28”的键值。此时，将”树28”作为”树13”的左孩子。<br><strong>第3步</strong>：合并”树13”和”树28”<br>     执行完第3步之后，得到的是对应”Case 2”的情况，”树13”、”树28”和”树7”这3棵树的度数都相同。此时，将x设为下一个节点。<br><strong>第4步</strong>：将x和next_x往后移<br>     执行完第4步之后，得到的是对应”Case 3”的情况，”树7”和”树11”的度数相同，且”树7”的键值 &lt; “树11”的键值。此时，将”树11”作为”树7”的左孩子。<br><strong>第5步</strong>：合并”树7”和”树11”<br>     执行完第5步之后，得到的是对应”Case 4”的情况，”树7”和”树6”的度数相同，且”树7”的键值 &gt; “树6”的键值。此时，将”树7”作为”树6”的左孩子。<br><strong>第6步</strong>：合并”树7”和”树6”<br>     此时，合并操作完成！</p><p>PS. 合并操作的图文解析过程与”测试程序(Main.java)中的testUnion()函数”是对应的！</p><h3 id="3-插入操作"><a href="#3-插入操作" class="headerlink" title="3. 插入操作"></a><strong>3. 插入操作</strong></h3><p>理解了”合并”操作之后，插入操作就相当简单了。插入操作可以看作是将”要插入的节点”和当前已有的堆进行合并。</p><p>插入操作代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 新建key对应的节点，并将其插入到二项堆中。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T key)</span> </span>&#123;<br>    BinomialNode&lt;T&gt; node;<br><br>    <span class="hljs-comment">// 禁止插入相同的键值</span><br>    <span class="hljs-keyword">if</span> (contains(key)==<span class="hljs-keyword">true</span>) &#123;<br>        System.out.printf(<span class="hljs-string">"insert failed: the key(%s) is existed already!\n"</span>, key);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    node = <span class="hljs-keyword">new</span> BinomialNode&lt;T&gt;(key);<br>    <span class="hljs-keyword">if</span> (node==<span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> ;<br><br>    mRoot = union(mRoot, node);<br>&#125;<br></code></pre></td></tr></table></figure><p>在插入时，首先通过contains(key)查找键值为key的节点。存在的话，则直接返回；不存在的话，则新建BinomialNode对象node，然后将node和heap进行合并。</p><p>注意：这里实现的二项堆是”进制插入相同节点的”！若想允许插入相同键值的节点，则屏蔽掉插入操作中的contains(key)部分代码即可。</p><h3 id="4-删除操作"><a href="#4-删除操作" class="headerlink" title="4. 删除操作"></a><strong>4. 删除操作</strong></h3><p>删除二项堆中的某个节点，需要的步骤概括起来如下：<br>(1) 将”该节点”交换到”它所在二项树”的根节点位置。方法是，从”该节点”不断向上(即向树根方向)”遍历，不断交换父节点和子节点的数据，直到被删除的键值到达树根位置。<br>(2) 将”该节点所在的二项树”从二项堆中移除；将该二项堆记为heap。<br>(3) 将”该节点所在的二项树”进行反转。反转的意思，就是将根的所有孩子独立出来，并将这些孩子整合成二项堆，将该二项堆记为child。<br>(4) 将child和heap进行合并操作。</p><p>下面，先看看删除操作的代码；再进行图文说明。</p><p>删除操作代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 删除节点：删除键值为key的节点<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">remove</span><span class="hljs-params">(BinomialNode&lt;T&gt; root, T key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> root;<br><br>    BinomialNode&lt;T&gt; node;<br><br>    <span class="hljs-comment">// 查找键值为key的节点</span><br>    <span class="hljs-keyword">if</span> ((node = search(root, key)) == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> root;<br><br>    <span class="hljs-comment">// 将被删除的节点的数据数据上移到它所在的二项树的根节点</span><br>    BinomialNode&lt;T&gt; parent = node.parent;<br>    <span class="hljs-keyword">while</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 交换数据</span><br>        T tmp = node.key;<br>        node.key = parent.key;<br>        parent.key = tmp;<br><br>        <span class="hljs-comment">// 下一个父节点</span><br>        node   = parent;<br>        parent = node.parent;<br>    &#125;<br><br>    <span class="hljs-comment">// 找到node的前一个根节点(prev)</span><br>    BinomialNode&lt;T&gt; prev = <span class="hljs-keyword">null</span>;<br>    BinomialNode&lt;T&gt; pos  = root;<br>    <span class="hljs-keyword">while</span> (pos != node) &#123;<br>        prev = pos;<br>        pos  = pos.next;<br>    &#125;<br>    <span class="hljs-comment">// 移除node节点</span><br>    <span class="hljs-keyword">if</span> (prev!=<span class="hljs-keyword">null</span>)<br>        prev.next = node.next;<br>    <span class="hljs-keyword">else</span><br>        root = node.next;<br><br>    root = union(root, reverse(node.child));<br><br>    <span class="hljs-comment">// help GC</span><br>    node = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(T key)</span> </span>&#123;<br>    mRoot = remove(mRoot, key);<br>&#125;<br></code></pre></td></tr></table></figure><p>remove(key)的作用是删除二项堆中键值为key的节点，并返回删除节点后的二项堆。</p><p>下面通过示意图来对删除操作进行说明(<em>删除二项堆中的节点20</em>)。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/101033308568748.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm1tskf8tj30ix1imtbz.jpg" alt="img"></a></p><p>总的思想，就是将被”删除节点”从它所在的二项树中孤立出来，然后再对二项树进行相应的处理。</p><p>PS. 删除操作的图文解析过程与”测试程序(Main.java)中的testDelete()函数”是对应的！</p><h3 id="5-更新操作"><a href="#5-更新操作" class="headerlink" title="5. 更新操作"></a><strong>5. 更新操作</strong></h3><p>更新二项堆中的某个节点，就是修改节点的值，它包括两部分分：”减少节点的值” 和 “增加节点的值” 。</p><p>更新操作代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 更新二项堆的节点node的键值为key<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateKey</span><span class="hljs-params">(BinomialNode&lt;T&gt; node, T key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-keyword">int</span> cmp = key.compareTo(node.key);<br>    <span class="hljs-keyword">if</span>(cmp &lt; <span class="hljs-number">0</span>)                            <span class="hljs-comment">// key &lt; node.key</span><br>        decreaseKey(node, key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp &gt; <span class="hljs-number">0</span>)                       <span class="hljs-comment">// key &gt; node.key</span><br>        increaseKey(node, key);<br>    <span class="hljs-keyword">else</span><br>        System.out.println(<span class="hljs-string">"No need to update!!!"</span>);<br>&#125;<br><br><span class="hljs-comment">/* <br> * 将二项堆中键值oldkey更新为newkey<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(T oldkey, T newkey)</span> </span>&#123;<br>    BinomialNode&lt;T&gt; node;<br><br>    node = search(mRoot, oldkey);<br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)<br>        updateKey(node, newkey);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-1-减少节点的值"><a href="#5-1-减少节点的值" class="headerlink" title="5.1 减少节点的值"></a><strong>5.1 减少节点的值</strong></h4><p>减少节点值的操作很简单：该节点一定位于一棵二项树中，减小”二项树”中某个节点的值后要保证”该二项树仍然是一个最小堆”；因此，就需要我们不断的将该节点上调。</p><p>减少操作代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 减少关键字的值：将二项堆中的节点node的键值减小为key。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decreaseKey</span><span class="hljs-params">(BinomialNode&lt;T&gt; node, T key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(key.compareTo(node.key)&gt;=<span class="hljs-number">0</span> || contains(key)==<span class="hljs-keyword">true</span>) &#123;<br>    System.out.println(<span class="hljs-string">"decrease failed: the new key("</span>+key+<span class="hljs-string">") is existed already, or is no smaller than current key("</span>+node.key+<span class="hljs-string">")"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    node.key = key;<br><br>    BinomialNode&lt;T&gt; child, parent;<br>    child = node;<br>    parent = node.parent;<br>    <span class="hljs-keyword">while</span>(parent != <span class="hljs-keyword">null</span> &amp;&amp; child.key.compareTo(parent.key)&lt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 交换parent和child的数据</span><br>        T tmp = parent.key;<br>        parent.key = child.key;<br>        child.key = tmp;<br><br>        child = parent;<br>        parent = child.parent;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是减少操作的示意图(<em>20-&gt;2</em>)</p><p><a href="https://images0.cnblogs.com/i/497634/201404/101035204817623.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm1vlja9kj30hv0swq4j.jpg" alt="img"></a></p><p>减少操作的思想很简单，就是”保持被减节点所在二项树的最小堆性质”。</p><p>PS. 减少操作的图文解析过程与”测试程序(Main.java)中的testDecrease()函数”是对应的！</p><h4 id="5-2-增加节点的值"><a href="#5-2-增加节点的值" class="headerlink" title="5.2 增加节点的值"></a><strong>5.2 增加节点的值</strong></h4><p>增加节点值的操作也很简单。上面说过减少要将被减少的节点不断上调，从而保证”被减少节点所在的二项树”的最小堆性质；而增加操作则是将被增加节点不断的下调，从而保证”被增加节点所在的二项树”的最小堆性质。</p><p>增加操作代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 增加关键字的值：将二项堆中的节点node的键值增加为key。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increaseKey</span><span class="hljs-params">(BinomialNode&lt;T&gt; node, T key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(key.compareTo(node.key)&lt;=<span class="hljs-number">0</span> || contains(key)==<span class="hljs-keyword">true</span>) &#123;<br>    System.out.println(<span class="hljs-string">"increase failed: the new key("</span>+key+<span class="hljs-string">") is existed already, or is no greater than current key("</span>+node.key+<span class="hljs-string">")"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    node.key = key;<br><br>    BinomialNode&lt;T&gt; cur = node;<br>    BinomialNode&lt;T&gt; child = cur.child;<br>    <span class="hljs-keyword">while</span> (child != <span class="hljs-keyword">null</span>) &#123;<br><br>        <span class="hljs-keyword">if</span>(cur.key.compareTo(child.key) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果"当前节点" &lt; "它的左孩子"，</span><br>            <span class="hljs-comment">// 则在"它的孩子中(左孩子 和 左孩子的兄弟)"中，找出最小的节点；</span><br>            <span class="hljs-comment">// 然后将"最小节点的值" 和 "当前节点的值"进行互换</span><br>            BinomialNode&lt;T&gt; least = child;    <span class="hljs-comment">// least是child和它的兄弟中的最小节点</span><br>            <span class="hljs-keyword">while</span>(child.next != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (least.key.compareTo(child.next.key) &gt; <span class="hljs-number">0</span>)<br>                    least = child.next;<br>                child = child.next;<br>            &#125;<br>            <span class="hljs-comment">// 交换最小节点和当前节点的值</span><br>            T tmp = least.key;<br>            least.key = cur.key;<br>            cur.key = tmp;<br><br>            <span class="hljs-comment">// 交换数据之后，再对"原最小节点"进行调整，使它满足最小堆的性质：父节点 &lt;= 子节点</span><br>            cur = least;<br>            child = cur.child;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            child = child.next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是增加操作的示意图(<em>6-&gt;60</em>)</p><p><a href="https://images0.cnblogs.com/i/497634/201404/101035468879089.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm1whiuw5j30hv11uq5c.jpg" alt="img"></a></p><p>增加操作的思想很简单，”保持被增加点所在二项树的最小堆性质”。</p><p>PS. 增加操作的图文解析过程与”测试程序(Main.java)中的testIncrease()函数”是对应的！</p><h2 id="二项堆的Java实现"><a href="#二项堆的Java实现" class="headerlink" title="二项堆的Java实现"></a><strong>二项堆的Java实现</strong></h2><h3 id="二项堆的实现文件-BinomialHeap-java"><a href="#二项堆的实现文件-BinomialHeap-java" class="headerlink" title="二项堆的实现文件(BinomialHeap.java)"></a>二项堆的实现文件(BinomialHeap.java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinomialHeap</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; mRoot;    <span class="hljs-comment">// 根结点</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinomialNode</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        T key;                <span class="hljs-comment">// 关键字(键值)</span><br>        <span class="hljs-keyword">int</span> degree;            <span class="hljs-comment">// 度数</span><br>        BinomialNode&lt;T&gt; child;    <span class="hljs-comment">// 左孩子</span><br>        BinomialNode&lt;T&gt; parent;    <span class="hljs-comment">// 父节点</span><br>        BinomialNode&lt;T&gt; next;    <span class="hljs-comment">// 兄弟节点</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinomialNode</span><span class="hljs-params">(T key)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.degree = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>.child = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"key:"</span>+key;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinomialHeap</span><span class="hljs-params">()</span> </span>&#123;<br>        mRoot = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 获取二项堆中的最小节点的键值<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">minimum</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mRoot==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        BinomialNode&lt;T&gt; x, prev_x;    <span class="hljs-comment">// x是用来遍历的当前节点</span><br>        BinomialNode&lt;T&gt; y, prev_y;    <span class="hljs-comment">// y是最小节点</span><br><br>        prev_x  = mRoot;<br>        x       = mRoot.next;<br>        prev_y  = <span class="hljs-keyword">null</span>;<br>        y       = mRoot;<br>        <span class="hljs-comment">// 找到最小节点</span><br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (x.key.compareTo(y.key) &lt; <span class="hljs-number">0</span>) &#123;<br>                y = x;<br>                prev_y = prev_x;<br>            &#125;<br>            prev_x = x;<br>            x = x.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> y.key;<br>    &#125;<br><br><br>    <span class="hljs-comment">/*<br>     * 合并两个二项堆：将child合并到root中<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">link</span><span class="hljs-params">(BinomialNode&lt;T&gt; child, BinomialNode&lt;T&gt; root)</span> </span>&#123;<br>        child.parent = root;<br>        child.next   = root.child;<br>        root.child = child;<br>        root.degree++;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将h1, h2中的根表合并成一个按度数递增的链表，返回合并后的根节点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">merge</span><span class="hljs-params">(BinomialNode&lt;T&gt; h1, BinomialNode&lt;T&gt; h2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (h1 == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> h2;<br>        <span class="hljs-keyword">if</span> (h2 == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> h1;<br><br>        <span class="hljs-comment">// root是新堆的根，h3用来遍历h1和h3的。</span><br>        BinomialNode&lt;T&gt; pre_h3, h3, root=<span class="hljs-keyword">null</span>;<br><br>        pre_h3 = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//整个while，h1, h2, pre_h3, h3都在往后顺移</span><br>        <span class="hljs-keyword">while</span> ((h1!=<span class="hljs-keyword">null</span>) &amp;&amp; (h2!=<span class="hljs-keyword">null</span>)) &#123;<br><br>            <span class="hljs-keyword">if</span> (h1.degree &lt;= h2.degree) &#123;<br>                h3 = h1;<br>                h1 = h1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                h3 = h2;<br>                h2 = h2.next;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (pre_h3 == <span class="hljs-keyword">null</span>) &#123;<br>                pre_h3 = h3;<br>                root = h3;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre_h3.next = h3;<br>                pre_h3 = h3;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (h1 != <span class="hljs-keyword">null</span>) &#123;<br>                h3.next = h1;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                h3.next = h2;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 合并二项堆：将h1, h2合并成一个堆，并返回合并后的堆<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">union</span><span class="hljs-params">(BinomialNode&lt;T&gt; h1, BinomialNode&lt;T&gt; h2)</span> </span>&#123;<br>        BinomialNode&lt;T&gt; root;<br><br>        <span class="hljs-comment">// 将h1, h2中的根表合并成一个按度数递增的链表root</span><br>        root = merge(h1, h2);<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        BinomialNode&lt;T&gt; prev_x = <span class="hljs-keyword">null</span>;<br>        BinomialNode&lt;T&gt; x      = root;<br>        BinomialNode&lt;T&gt; next_x = x.next;<br>        <span class="hljs-keyword">while</span> (next_x != <span class="hljs-keyword">null</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (   (x.degree != next_x.degree)<br>                || ((next_x.next != <span class="hljs-keyword">null</span>) &amp;&amp; (next_x.degree == next_x.next.degree))) &#123;<br>                <span class="hljs-comment">// Case 1: x.degree != next_x.degree</span><br>                <span class="hljs-comment">// Case 2: x.degree == next_x.degree == next_x.next.degree</span><br>                prev_x = x;<br>                x = next_x;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.key.compareTo(next_x.key) &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// Case 3: x.degree == next_x.degree != next_x.next.degree</span><br>                <span class="hljs-comment">//      &amp;&amp; x.key    &lt;= next_x.key</span><br>                x.next = next_x.next;<br>                link(next_x, x);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Case 4: x.degree == next_x.degree != next_x.next.degree</span><br>                <span class="hljs-comment">//      &amp;&amp; x.key    &gt;  next_x.key</span><br>                <span class="hljs-keyword">if</span> (prev_x == <span class="hljs-keyword">null</span>) &#123;<br>                    root = next_x;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    prev_x.next = next_x;<br>                &#125;<br>                link(x, next_x);<br>                x = next_x;<br>            &#125;<br>            next_x = x.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将二项堆other合并到当前堆中<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(BinomialHeap&lt;T&gt; other)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (other!=<span class="hljs-keyword">null</span> &amp;&amp; other.mRoot!=<span class="hljs-keyword">null</span>)<br>            mRoot = union(mRoot, other.mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 新建key对应的节点，并将其插入到二项堆中。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T key)</span> </span>&#123;<br>        BinomialNode&lt;T&gt; node;<br><br>        <span class="hljs-comment">// 禁止插入相同的键值</span><br>        <span class="hljs-keyword">if</span> (contains(key)==<span class="hljs-keyword">true</span>) &#123;<br>            System.out.printf(<span class="hljs-string">"insert failed: the key(%s) is existed already!\n"</span>, key);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        node = <span class="hljs-keyword">new</span> BinomialNode&lt;T&gt;(key);<br>        <span class="hljs-keyword">if</span> (node==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        mRoot = union(mRoot, node);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 反转二项堆root，并返回反转后的根节点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">reverse</span><span class="hljs-params">(BinomialNode&lt;T&gt; root)</span> </span>&#123;<br>        BinomialNode&lt;T&gt; next;<br>        BinomialNode&lt;T&gt; tail = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br><br>        root.parent = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span> (root.next!=<span class="hljs-keyword">null</span>) &#123;<br>            next         = root.next;<br>            root.next    = tail;<br>            tail         = root;<br>            root         = next;<br>            root.parent  = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        root.next = tail;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 移除二项堆root中的最小节点，并返回删除节点后的二项树<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">extractMinimum</span><span class="hljs-params">(BinomialNode&lt;T&gt; root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br><br>        BinomialNode&lt;T&gt; x, prev_x;    <span class="hljs-comment">// x是用来遍历的当前节点</span><br>        BinomialNode&lt;T&gt; y, prev_y;    <span class="hljs-comment">// y是最小节点</span><br><br>        prev_x  = root;<br>        x       = root.next;<br>        prev_y = <span class="hljs-keyword">null</span>;<br>        y      = root;<br>        <span class="hljs-comment">// 找到最小节点</span><br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (x.key.compareTo(y.key) &lt; <span class="hljs-number">0</span>) &#123;<br>                y = x;<br>                prev_y = prev_x;<br>            &#125;<br>            prev_x = x;<br>            x = x.next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (prev_y == <span class="hljs-keyword">null</span>)    <span class="hljs-comment">// root的根节点就是最小根节点</span><br>            root = root.next;<br>        <span class="hljs-keyword">else</span>                <span class="hljs-comment">// root的根节点不是最小根节点</span><br>            prev_y.next = y.next;<br><br>        <span class="hljs-comment">// 反转最小节点的左孩子，得到最小堆child；</span><br>        <span class="hljs-comment">// 这样，就使得最小节点所在二项树的孩子们都脱离出来成为一棵独立的二项树(不包括最小节点)</span><br>        BinomialNode&lt;T&gt; child = reverse(y.child);<br>        <span class="hljs-comment">// 将"删除最小节点的二项堆child"和"root"进行合并。</span><br>        root = union(root, child);<br><br>        <span class="hljs-comment">// help GC</span><br>        y = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">extractMinimum</span><span class="hljs-params">()</span> </span>&#123;<br>        mRoot = extractMinimum(mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 减少关键字的值：将二项堆中的节点node的键值减小为key。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decreaseKey</span><span class="hljs-params">(BinomialNode&lt;T&gt; node, T key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(key.compareTo(node.key)&gt;=<span class="hljs-number">0</span> || contains(key)==<span class="hljs-keyword">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">"decrease failed: the new key("</span>+key+<span class="hljs-string">") is existed already, or is no smaller than current key("</span>+node.key+<span class="hljs-string">")"</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        node.key = key;<br><br>        BinomialNode&lt;T&gt; child, parent;<br>        child = node;<br>        parent = node.parent;<br>        <span class="hljs-keyword">while</span>(parent != <span class="hljs-keyword">null</span> &amp;&amp; child.key.compareTo(parent.key)&lt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 交换parent和child的数据</span><br>            T tmp = parent.key;<br>            parent.key = child.key;<br>            child.key = tmp;<br><br>            child = parent;<br>            parent = child.parent;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 增加关键字的值：将二项堆中的节点node的键值增加为key。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increaseKey</span><span class="hljs-params">(BinomialNode&lt;T&gt; node, T key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(key.compareTo(node.key)&lt;=<span class="hljs-number">0</span> || contains(key)==<span class="hljs-keyword">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">"increase failed: the new key("</span>+key+<span class="hljs-string">") is existed already, or is no greater than current key("</span>+node.key+<span class="hljs-string">")"</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        node.key = key;<br><br>        BinomialNode&lt;T&gt; cur = node;<br>        BinomialNode&lt;T&gt; child = cur.child;<br>        <span class="hljs-keyword">while</span> (child != <span class="hljs-keyword">null</span>) &#123;<br><br>            <span class="hljs-keyword">if</span>(cur.key.compareTo(child.key) &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 如果"当前节点" &lt; "它的左孩子"，</span><br>                <span class="hljs-comment">// 则在"它的孩子中(左孩子 和 左孩子的兄弟)"中，找出最小的节点；</span><br>                <span class="hljs-comment">// 然后将"最小节点的值" 和 "当前节点的值"进行互换</span><br>                BinomialNode&lt;T&gt; least = child;    <span class="hljs-comment">// least是child和它的兄弟中的最小节点</span><br>                <span class="hljs-keyword">while</span>(child.next != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (least.key.compareTo(child.next.key) &gt; <span class="hljs-number">0</span>)<br>                        least = child.next;<br>                    child = child.next;<br>                &#125;<br>                <span class="hljs-comment">// 交换最小节点和当前节点的值</span><br>                T tmp = least.key;<br>                least.key = cur.key;<br>                cur.key = tmp;<br><br>                <span class="hljs-comment">// 交换数据之后，再对"原最小节点"进行调整，使它满足最小堆的性质：父节点 &lt;= 子节点</span><br>                cur = least;<br>                child = cur.child;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                child = child.next;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 更新二项堆的节点node的键值为key<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateKey</span><span class="hljs-params">(BinomialNode&lt;T&gt; node, T key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">int</span> cmp = key.compareTo(node.key);<br>        <span class="hljs-keyword">if</span>(cmp &lt; <span class="hljs-number">0</span>)                            <span class="hljs-comment">// key &lt; node.key</span><br>            decreaseKey(node, key);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp &gt; <span class="hljs-number">0</span>)                    <span class="hljs-comment">// key &gt; node.key</span><br>            increaseKey(node, key);<br>        <span class="hljs-keyword">else</span><br>            System.out.println(<span class="hljs-string">"No need to update!!!"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将二项堆中键值oldkey更新为newkey<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(T oldkey, T newkey)</span> </span>&#123;<br>        BinomialNode&lt;T&gt; node;<br><br>        node = search(mRoot, oldkey);<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)<br>            updateKey(node, newkey);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 查找：在二项堆中查找键值为key的节点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">search</span><span class="hljs-params">(BinomialNode&lt;T&gt; root, T key)</span> </span>&#123;<br>        BinomialNode&lt;T&gt; child;<br>        BinomialNode&lt;T&gt; parent = root;<br><br>        parent = root;<br>        <span class="hljs-keyword">while</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (parent.key.compareTo(key) == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> parent;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>((child = search(parent.child, key)) != <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-keyword">return</span> child;<br>                parent = parent.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 二项堆中是否包含键值key<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(T key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> search(mRoot, key)!=<span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 删除节点：删除键值为key的节点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">remove</span><span class="hljs-params">(BinomialNode&lt;T&gt; root, T key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br><br>        BinomialNode&lt;T&gt; node;<br><br>        <span class="hljs-comment">// 查找键值为key的节点</span><br>        <span class="hljs-keyword">if</span> ((node = search(root, key)) == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-comment">// 将被删除的节点的数据数据上移到它所在的二项树的根节点</span><br>        BinomialNode&lt;T&gt; parent = node.parent;<br>        <span class="hljs-keyword">while</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 交换数据</span><br>            T tmp = node.key;<br>            node.key = parent.key;<br>            parent.key = tmp;<br><br>            <span class="hljs-comment">// 下一个父节点</span><br>            node   = parent;<br>            parent = node.parent;<br>        &#125;<br><br>        <span class="hljs-comment">// 找到node的前一个根节点(prev)</span><br>        BinomialNode&lt;T&gt; prev = <span class="hljs-keyword">null</span>;<br>        BinomialNode&lt;T&gt; pos  = root;<br>        <span class="hljs-keyword">while</span> (pos != node) &#123;<br>            prev = pos;<br>            pos  = pos.next;<br>        &#125;<br>        <span class="hljs-comment">// 移除node节点</span><br>        <span class="hljs-keyword">if</span> (prev!=<span class="hljs-keyword">null</span>)<br>            prev.next = node.next;<br>        <span class="hljs-keyword">else</span><br>            root = node.next;<br><br>        root = union(root, reverse(node.child));<br><br>        <span class="hljs-comment">// help GC</span><br>        node = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(T key)</span> </span>&#123;<br>        mRoot = remove(mRoot, key);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 打印"二项堆"<br>     *<br>     * 参数说明：<br>     *     node       -- 当前节点<br>     *     prev       -- 当前节点的前一个节点(父节点or兄弟节点)<br>     *     direction  --  1，表示当前节点是一个左孩子;<br>     *                    2，表示当前节点是一个兄弟节点。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(BinomialNode&lt;T&gt; node, BinomialNode&lt;T&gt; prev, <span class="hljs-keyword">int</span> direction)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(node != <span class="hljs-keyword">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(direction==<span class="hljs-number">1</span>)    <span class="hljs-comment">// node是根节点</span><br>                System.out.printf(<span class="hljs-string">"\t%2d(%d) is %2d's child\n"</span>, node.key, node.degree, prev.key);<br>            <span class="hljs-keyword">else</span>                <span class="hljs-comment">// node是分支节点</span><br>                System.out.printf(<span class="hljs-string">"\t%2d(%d) is %2d's next\n"</span>, node.key, node.degree, prev.key);<br><br>            <span class="hljs-keyword">if</span> (node.child != <span class="hljs-keyword">null</span>)<br>                print(node.child, node, <span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// 兄弟节点</span><br>            prev = node;<br>            node = node.next;<br>            direction = <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mRoot == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        BinomialNode&lt;T&gt; p = mRoot;<br>        System.out.printf(<span class="hljs-string">"== 二项堆( "</span>);<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;<br>            System.out.printf(<span class="hljs-string">"B%d "</span>, p.degree);<br>            p = p.next;<br>        &#125;<br>        System.out.printf(<span class="hljs-string">")的详细信息：\n"</span>);<br><br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        p = mRoot;<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;<br>            i++;<br>            System.out.printf(<span class="hljs-string">"%d. 二项树B%d: \n"</span>, i, p.degree);<br>            System.out.printf(<span class="hljs-string">"\t%2d(%d) is root\n"</span>, p.key, p.degree);<br><br>            print(p.child, p, <span class="hljs-number">1</span>);<br>            p = p.next;<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二项堆的测试程序-Main-java"><a href="#二项堆的测试程序-Main-java" class="headerlink" title="二项堆的测试程序(Main.java)"></a>二项堆的测试程序(Main.java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * Java 语言: 二项堆<br> *<br> * <span class="hljs-doctag">@author</span> skywang<br> * <span class="hljs-doctag">@date</span> 2014/03/31<br> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> DEBUG = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">// 共7个 = 1+2+4</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">12</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">25</span>, <span class="hljs-number">15</span>, <span class="hljs-number">28</span>, <span class="hljs-number">33</span>, <span class="hljs-number">41</span>&#125;;<br>    <span class="hljs-comment">// 共13个 = 1+4+8</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b[] = &#123;<span class="hljs-number">18</span>, <span class="hljs-number">35</span>, <span class="hljs-number">20</span>, <span class="hljs-number">42</span>,  <span class="hljs-number">9</span>,<br>               <span class="hljs-number">31</span>, <span class="hljs-number">23</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">48</span>, <span class="hljs-number">11</span>,<br>               <span class="hljs-number">24</span>, <span class="hljs-number">52</span>, <span class="hljs-number">13</span> &#125;;<br><br><br>    <span class="hljs-comment">// 验证"二项堆的插入操作"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsert</span><span class="hljs-params">()</span> </span>&#123;<br>        BinomialHeap&lt;Integer&gt; ha=<span class="hljs-keyword">new</span> BinomialHeap&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 二项堆ha</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(ha)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            ha.insert(a[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 二项堆(ha)的详细信息: \n"</span>);<br>        ha.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"二项堆的合并操作"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUnion</span><span class="hljs-params">()</span> </span>&#123;<br>        BinomialHeap&lt;Integer&gt; ha=<span class="hljs-keyword">new</span> BinomialHeap&lt;Integer&gt;();<br>        BinomialHeap&lt;Integer&gt; hb=<span class="hljs-keyword">new</span> BinomialHeap&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 二项堆ha</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(ha)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            ha.insert(a[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 二项堆(ha)的详细信息: \n"</span>);<br>        ha.print();<br><br>        <span class="hljs-comment">// 二项堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        <span class="hljs-comment">// 打印二项堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(hb)的详细信息: \n"</span>);<br>        hb.print();<br><br>        <span class="hljs-comment">// 将"二项堆hb"合并到"二项堆ha"中。</span><br>        ha.union(hb);<br>        <span class="hljs-comment">// 打印二项堆ha的详细信息</span><br>        System.out.printf(<span class="hljs-string">"== 合并ha和hb后的详细信息:\n"</span>);<br>        ha.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"二项堆的删除操作"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span> </span>&#123;<br>        BinomialHeap&lt;Integer&gt; hb=<span class="hljs-keyword">new</span> BinomialHeap&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 二项堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        <span class="hljs-comment">// 打印二项堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(hb)的详细信息: \n"</span>);<br>        hb.print();<br><br>        <span class="hljs-comment">// 将"二项堆hb"合并到"二项堆ha"中。</span><br>        hb.remove(<span class="hljs-number">20</span>);<br>        System.out.printf(<span class="hljs-string">"== 删除节点20后的详细信息: \n"</span>);<br>        hb.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"二项堆的更新(减少)操作"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDecrease</span><span class="hljs-params">()</span> </span>&#123;<br>        BinomialHeap&lt;Integer&gt; hb=<span class="hljs-keyword">new</span> BinomialHeap&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 二项堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        <span class="hljs-comment">// 打印二项堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(hb)的详细信息: \n"</span>);<br>        hb.print();<br><br>        <span class="hljs-comment">// 将节点20更新为2</span><br>        hb.update(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>);<br>        System.out.printf(<span class="hljs-string">"== 更新节点20-&gt;2后的详细信息: \n"</span>);<br>        hb.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"二项堆的更新(减少)操作"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIncrease</span><span class="hljs-params">()</span> </span>&#123;<br>        BinomialHeap&lt;Integer&gt; hb=<span class="hljs-keyword">new</span> BinomialHeap&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 二项堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        <span class="hljs-comment">// 打印二项堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(hb)的详细信息: \n"</span>);<br>        hb.print();<br><br>        <span class="hljs-comment">// 将节点6更新为60</span><br>        hb.update(<span class="hljs-number">6</span>, <span class="hljs-number">60</span>);<br>        System.out.printf(<span class="hljs-string">"== 更新节点6-&gt;60后的详细信息: \n"</span>);<br>        hb.print();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1. 验证"二项堆的插入操作"</span><br>        testInsert();<br>        <span class="hljs-comment">// 2. 验证"二项堆的合并操作"</span><br>        <span class="hljs-comment">//testUnion();</span><br>        <span class="hljs-comment">// 3. 验证"二项堆的删除操作"</span><br>        <span class="hljs-comment">//testDelete();</span><br>        <span class="hljs-comment">// 4. 验证"二项堆的更新(减少)操作"</span><br>        <span class="hljs-comment">//testDecrease();</span><br>        <span class="hljs-comment">// 5. 验证"二项堆的更新(增加)操作"</span><br>        <span class="hljs-comment">//testIncrease();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">== 二项堆(ha)中依次添加: 12 7 25 15 28 33 41 </span><br><span class="hljs-section">== 二项堆(ha)的详细信息: </span><br><span class="hljs-section">== 二项堆( B0 B1 B2 )的详细信息：</span><br>1. 二项树B0: <br><span class="hljs-code">    41(0) is root</span><br>2. 二项树B1: <br><span class="hljs-code">    28(1) is root</span><br><span class="hljs-code">    33(0) is 28's child</span><br>3. 二项树B2: <br><span class="hljs-code">     7(2) is root</span><br><span class="hljs-code">    15(1) is  7's child</span><br><span class="hljs-code">    25(0) is 15's child</span><br><span class="hljs-code">    12(0) is 15's next</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.3.斜堆</title>
      <link href="/2021/11/17/6.3.%E6%96%9C%E5%A0%86/"/>
      <url>/2021/11/17/6.3.%E6%96%9C%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="斜堆"><a href="#斜堆" class="headerlink" title="斜堆"></a>斜堆</h1><h2 id="斜堆的介绍"><a href="#斜堆的介绍" class="headerlink" title="斜堆的介绍"></a>斜堆的介绍</h2><p>斜堆(Skew heap)也叫自适应堆(self-adjusting heap)，它是左倾堆的一个变种。和左倾堆一样，它通常也用于实现优先队列；作为一种自适应的左倾堆，它的合并操作的时间复杂度也是O(lg n)。</p><p>它与左倾堆的差别是：<br>(1) 斜堆的节点没有”零距离”这个属性，而左倾堆则有。<br>(2) 斜堆的合并操作和左倾堆的合并操作算法不同。</p><p>斜堆的合并操作：<br>(1) 如果一个空斜堆与一个非空斜堆合并，返回非空斜堆。<br>(2) 如果两个斜堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将”较小堆的根节点的右孩子”和”较大堆”进行合并。<br>(3) 合并后，交换新堆根节点的左孩子和右孩子。<br>第(03)步是斜堆和左倾堆的合并操作差别的关键所在，如果是左倾堆，则合并后要比较左右孩子的零距离大小，若右孩子的零距离 &gt; 左孩子的零距离，则交换左右孩子；最后，在设置根的零距离。</p><h2 id="斜堆的基本操作"><a href="#斜堆的基本操作" class="headerlink" title="斜堆的基本操作"></a><strong>斜堆的基本操作</strong></h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkewHeap</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> SkewNode&lt;T&gt; mRoot;    <span class="hljs-comment">// 根结点</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkewNode</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        T key;                <span class="hljs-comment">// 关键字(键值)</span><br>        SkewNode&lt;T&gt; left;    <span class="hljs-comment">// 左孩子</span><br>        SkewNode&lt;T&gt; right;    <span class="hljs-comment">// 右孩子</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SkewNode</span><span class="hljs-params">(T key, SkewNode&lt;T&gt; left, SkewNode&lt;T&gt; right)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"key:"</span>+key;<br>        &#125;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>SkewNode是斜堆对应的节点类。<br>SkewHeap是斜堆类，它包含了斜堆的根节点，以及斜堆的操作。</p><h3 id="2-合并"><a href="#2-合并" class="headerlink" title="2. 合并"></a><strong>2. 合并</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 合并"斜堆x"和"斜堆y"<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> SkewNode&lt;T&gt; <span class="hljs-title">merge</span><span class="hljs-params">(SkewNode&lt;T&gt; x, SkewNode&lt;T&gt; y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> y;<br>    <span class="hljs-keyword">if</span>(y == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> x;<br><br>    <span class="hljs-comment">// 合并x和y时，将x作为合并后的树的根；</span><br>    <span class="hljs-comment">// 这里的操作是保证: x的key &lt; y的key</span><br>    <span class="hljs-keyword">if</span>(x.key.compareTo(y.key) &gt; <span class="hljs-number">0</span>) &#123;<br>        SkewNode&lt;T&gt; tmp = x;<br>        x = y;<br>        y = tmp;<br>    &#125;<br><br>    <span class="hljs-comment">// 将x的右孩子和y合并，</span><br>    <span class="hljs-comment">// 合并后直接交换x的左右孩子，而不需要像左倾堆一样考虑它们的npl。</span><br>    SkewNode&lt;T&gt; tmp = merge(x.right, y);<br>    x.right = x.left;<br>    x.left = tmp;<br><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(SkewHeap&lt;T&gt; other)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.mRoot = merge(<span class="hljs-keyword">this</span>.mRoot, other.mRoot);<br>&#125;<br></code></pre></td></tr></table></figure><p>merge(x, y)是内部接口，作用是合并x和y这两个斜堆，并返回得到的新堆的根节点。<br>merge(other)是外部接口，作用是将other合并到当前堆中。</p><h3 id="3-添加"><a href="#3-添加" class="headerlink" title="3. 添加"></a><strong>3. 添加</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 新建结点(key)，并将其插入到斜堆中<br> *<br> * 参数说明：<br> *     key 插入结点的键值<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T key)</span> </span>&#123;<br>    SkewNode&lt;T&gt; node = <span class="hljs-keyword">new</span> SkewNode&lt;T&gt;(key,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-comment">// 如果新建结点失败，则返回。</span><br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">this</span>.mRoot = merge(<span class="hljs-keyword">this</span>.mRoot, node);<br>&#125;<br></code></pre></td></tr></table></figure><p>insert(key)的作用是新建键值为key的节点，并将其加入到当前斜堆中。</p><h3 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a><strong>4. 删除</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 删除根结点<br> * <br> * 返回值：<br> *     返回被删除的节点的键值<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mRoot == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    T key = <span class="hljs-keyword">this</span>.mRoot.key;<br>    SkewNode&lt;T&gt; l = <span class="hljs-keyword">this</span>.mRoot.left;<br>    SkewNode&lt;T&gt; r = <span class="hljs-keyword">this</span>.mRoot.right;<br><br>    <span class="hljs-keyword">this</span>.mRoot = <span class="hljs-keyword">null</span>;          <span class="hljs-comment">// 删除根节点</span><br>    <span class="hljs-keyword">this</span>.mRoot = merge(l, r);   <span class="hljs-comment">// 合并左右子树</span><br><br>    <span class="hljs-keyword">return</span> key;<br>&#125;<br></code></pre></td></tr></table></figure><p>remove()的作用是删除斜堆的最小节点。</p><h2 id="斜堆的代码实现"><a href="#斜堆的代码实现" class="headerlink" title="斜堆的代码实现"></a>斜堆的代码实现</h2><h3 id="斜堆的实现文件-SkewHeap-java"><a href="#斜堆的实现文件-SkewHeap-java" class="headerlink" title="斜堆的实现文件(SkewHeap.java)"></a>斜堆的实现文件(SkewHeap.java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkewHeap</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> SkewNode&lt;T&gt; mRoot;    <span class="hljs-comment">// 根结点</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkewNode</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        T key;                <span class="hljs-comment">// 关键字(键值)</span><br>        SkewNode&lt;T&gt; left;    <span class="hljs-comment">// 左孩子</span><br>        SkewNode&lt;T&gt; right;    <span class="hljs-comment">// 右孩子</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SkewNode</span><span class="hljs-params">(T key, SkewNode&lt;T&gt; left, SkewNode&lt;T&gt; right)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"key:"</span>+key;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SkewHeap</span><span class="hljs-params">()</span> </span>&#123;<br>        mRoot = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 前序遍历"斜堆"<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(SkewNode&lt;T&gt; heap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(heap != <span class="hljs-keyword">null</span>) &#123;<br>            System.out.print(heap.key+<span class="hljs-string">" "</span>);<br>            preOrder(heap.left);<br>            preOrder(heap.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        preOrder(mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 中序遍历"斜堆"<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(SkewNode&lt;T&gt; heap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(heap != <span class="hljs-keyword">null</span>) &#123;<br>            inOrder(heap.left);<br>            System.out.print(heap.key+<span class="hljs-string">" "</span>);<br>            inOrder(heap.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        inOrder(mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 后序遍历"斜堆"<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(SkewNode&lt;T&gt; heap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(heap != <span class="hljs-keyword">null</span>)<br>        &#123;<br>            postOrder(heap.left);<br>            postOrder(heap.right);<br>            System.out.print(heap.key+<span class="hljs-string">" "</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        postOrder(mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 合并"斜堆x"和"斜堆y"<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> SkewNode&lt;T&gt; <span class="hljs-title">merge</span><span class="hljs-params">(SkewNode&lt;T&gt; x, SkewNode&lt;T&gt; y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> y;<br>        <span class="hljs-keyword">if</span>(y == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> x;<br><br>        <span class="hljs-comment">// 合并x和y时，将x作为合并后的树的根；</span><br>        <span class="hljs-comment">// 这里的操作是保证: x的key &lt; y的key</span><br>        <span class="hljs-keyword">if</span>(x.key.compareTo(y.key) &gt; <span class="hljs-number">0</span>) &#123;<br>            SkewNode&lt;T&gt; tmp = x;<br>            x = y;<br>            y = tmp;<br>        &#125;<br><br>        <span class="hljs-comment">// 将x的右孩子和y合并，</span><br>        <span class="hljs-comment">// 合并后直接交换x的左右孩子，而不需要像左倾堆一样考虑它们的npl。</span><br>        SkewNode&lt;T&gt; tmp = merge(x.right, y);<br>        x.right = x.left;<br>        x.left = tmp;<br><br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(SkewHeap&lt;T&gt; other)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mRoot = merge(<span class="hljs-keyword">this</span>.mRoot, other.mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 新建结点(key)，并将其插入到斜堆中<br>     *<br>     * 参数说明：<br>     *     key 插入结点的键值<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T key)</span> </span>&#123;<br>        SkewNode&lt;T&gt; node = <span class="hljs-keyword">new</span> SkewNode&lt;T&gt;(key,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">// 如果新建结点失败，则返回。</span><br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">this</span>.mRoot = merge(<span class="hljs-keyword">this</span>.mRoot, node);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 删除根结点<br>     *<br>     * 返回值：<br>     *     返回被删除的节点的键值<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mRoot == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        T key = <span class="hljs-keyword">this</span>.mRoot.key;<br>        SkewNode&lt;T&gt; l = <span class="hljs-keyword">this</span>.mRoot.left;<br>        SkewNode&lt;T&gt; r = <span class="hljs-keyword">this</span>.mRoot.right;<br><br>        <span class="hljs-keyword">this</span>.mRoot = <span class="hljs-keyword">null</span>;          <span class="hljs-comment">// 删除根节点</span><br>        <span class="hljs-keyword">this</span>.mRoot = merge(l, r);   <span class="hljs-comment">// 合并左右子树</span><br><br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 销毁斜堆<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(SkewNode&lt;T&gt; heap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (heap==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span> (heap.left != <span class="hljs-keyword">null</span>)<br>            destroy(heap.left);<br>        <span class="hljs-keyword">if</span> (heap.right != <span class="hljs-keyword">null</span>)<br>            destroy(heap.right);<br><br>        heap=<span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>        destroy(mRoot);<br>        mRoot = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 打印"斜堆"<br>     *<br>     * key        -- 节点的键值<br>     * direction  --  0，表示该节点是根节点;<br>     *               -1，表示该节点是它的父结点的左孩子;<br>     *                1，表示该节点是它的父结点的右孩子。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(SkewNode&lt;T&gt; heap, T key, <span class="hljs-keyword">int</span> direction)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(heap != <span class="hljs-keyword">null</span>) &#123;<br><br>            <span class="hljs-keyword">if</span>(direction==<span class="hljs-number">0</span>)    <span class="hljs-comment">// heap是根节点</span><br>                System.out.printf(<span class="hljs-string">"%2d is root\n"</span>, heap.key);<br>            <span class="hljs-keyword">else</span>                <span class="hljs-comment">// heap是分支节点</span><br>                System.out.printf(<span class="hljs-string">"%2d is %2d's %6s child\n"</span>, heap.key, key, direction==<span class="hljs-number">1</span>?<span class="hljs-string">"right"</span> : <span class="hljs-string">"left"</span>);<br><br>            print(heap.left, heap.key, -<span class="hljs-number">1</span>);<br>            print(heap.right,heap.key,  <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mRoot != <span class="hljs-keyword">null</span>)<br>            print(mRoot, mRoot.key, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="斜堆的测试程序-SkewHeapTest-java"><a href="#斜堆的测试程序-SkewHeapTest-java" class="headerlink" title="斜堆的测试程序(SkewHeapTest.java)"></a>斜堆的测试程序(SkewHeapTest.java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkewHeapTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> a[]= &#123;<span class="hljs-number">10</span>,<span class="hljs-number">40</span>,<span class="hljs-number">24</span>,<span class="hljs-number">30</span>,<span class="hljs-number">36</span>,<span class="hljs-number">20</span>,<span class="hljs-number">12</span>,<span class="hljs-number">16</span>&#125;;<br>        <span class="hljs-keyword">int</span> b[]= &#123;<span class="hljs-number">17</span>,<span class="hljs-number">13</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>,<span class="hljs-number">19</span>,<span class="hljs-number">21</span>,<span class="hljs-number">23</span>&#125;;<br>        SkewHeap&lt;Integer&gt; ha=<span class="hljs-keyword">new</span> SkewHeap&lt;Integer&gt;();<br>        SkewHeap&lt;Integer&gt; hb=<span class="hljs-keyword">new</span> SkewHeap&lt;Integer&gt;();<br><br>        System.out.printf(<span class="hljs-string">"== 斜堆(ha)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            ha.insert(a[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n== 斜堆(ha)的详细信息: \n"</span>);<br>        ha.print();<br><br><br>        System.out.printf(<span class="hljs-string">"\n== 斜堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n== 斜堆(hb)的详细信息: \n"</span>);<br>        hb.print();<br><br>        <span class="hljs-comment">// 将"斜堆hb"合并到"斜堆ha"中。</span><br>        ha.merge(hb);<br>        System.out.printf(<span class="hljs-string">"\n== 合并ha和hb后的详细信息: \n"</span>);<br>        ha.print();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ada">== 斜堆(ha)中依次添加: <span class="hljs-number">10</span> <span class="hljs-number">40</span> <span class="hljs-number">24</span> <span class="hljs-number">30</span> <span class="hljs-number">36</span> <span class="hljs-number">20</span> <span class="hljs-number">12</span> <span class="hljs-number">16</span> <br>== 斜堆(ha)的详细信息: <br><span class="hljs-number">10</span> <span class="hljs-keyword">is</span> root<br><span class="hljs-number">16</span> <span class="hljs-keyword">is</span> <span class="hljs-number">10</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">20</span> <span class="hljs-keyword">is</span> <span class="hljs-number">16</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">30</span> <span class="hljs-keyword">is</span> <span class="hljs-number">20</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">40</span> <span class="hljs-keyword">is</span> <span class="hljs-number">30</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">12</span> <span class="hljs-keyword">is</span> <span class="hljs-number">10</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">24</span> <span class="hljs-keyword">is</span> <span class="hljs-number">12</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">36</span> <span class="hljs-keyword">is</span> <span class="hljs-number">24</span><span class="hljs-symbol">'s</span>   left child<br><br>== 斜堆(hb)中依次添加: <span class="hljs-number">17</span> <span class="hljs-number">13</span> <span class="hljs-number">11</span> <span class="hljs-number">15</span> <span class="hljs-number">19</span> <span class="hljs-number">21</span> <span class="hljs-number">23</span> <br>== 斜堆(hb)的详细信息: <br><span class="hljs-number">11</span> <span class="hljs-keyword">is</span> root<br><span class="hljs-number">13</span> <span class="hljs-keyword">is</span> <span class="hljs-number">11</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">17</span> <span class="hljs-keyword">is</span> <span class="hljs-number">13</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">23</span> <span class="hljs-keyword">is</span> <span class="hljs-number">17</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">19</span> <span class="hljs-keyword">is</span> <span class="hljs-number">13</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">15</span> <span class="hljs-keyword">is</span> <span class="hljs-number">11</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">21</span> <span class="hljs-keyword">is</span> <span class="hljs-number">15</span><span class="hljs-symbol">'s</span>   left child<br><br>== 合并ha和hb后的详细信息: <br><span class="hljs-number">10</span> <span class="hljs-keyword">is</span> root<br><span class="hljs-number">11</span> <span class="hljs-keyword">is</span> <span class="hljs-number">10</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">12</span> <span class="hljs-keyword">is</span> <span class="hljs-number">11</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">15</span> <span class="hljs-keyword">is</span> <span class="hljs-number">12</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">21</span> <span class="hljs-keyword">is</span> <span class="hljs-number">15</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">24</span> <span class="hljs-keyword">is</span> <span class="hljs-number">12</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">36</span> <span class="hljs-keyword">is</span> <span class="hljs-number">24</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">13</span> <span class="hljs-keyword">is</span> <span class="hljs-number">11</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">17</span> <span class="hljs-keyword">is</span> <span class="hljs-number">13</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">23</span> <span class="hljs-keyword">is</span> <span class="hljs-number">17</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">19</span> <span class="hljs-keyword">is</span> <span class="hljs-number">13</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">16</span> <span class="hljs-keyword">is</span> <span class="hljs-number">10</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">20</span> <span class="hljs-keyword">is</span> <span class="hljs-number">16</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">30</span> <span class="hljs-keyword">is</span> <span class="hljs-number">20</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">40</span> <span class="hljs-keyword">is</span> <span class="hljs-number">30</span><span class="hljs-symbol">'s</span>   left child<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.2.左倾堆</title>
      <link href="/2021/11/17/6.2.%E5%B7%A6%E5%80%BE%E5%A0%86/"/>
      <url>/2021/11/17/6.2.%E5%B7%A6%E5%80%BE%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="左倾堆"><a href="#左倾堆" class="headerlink" title="左倾堆"></a><strong>左倾堆</strong></h1><p>左倾堆(leftist tree 或 leftist heap)，又被成为左偏树、左偏堆，最左堆等。<br>它和二叉堆一样，都是优先队列实现方式。当优先队列中涉及到”对两个优先队列进行合并”的问题时，二叉堆的效率就无法令人满意了。</p><p><strong>==目的：对两个优先队列进行合并==</strong></p><h2 id="左倾堆的定义"><a href="#左倾堆的定义" class="headerlink" title="左倾堆的定义"></a><strong>左倾堆的定义</strong></h2><p><a href="https://images0.cnblogs.com/i/497634/201404/011451438751063.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlytpjgf3j30hd0b274p.jpg" alt="img"></a></p><p>上图是一颗左倾树，它的节点除了和二叉树的节点一样具有左右子树指针外，还有两个属性：键值和零距离。<br>(1) 键值的作用是来比较节点的大小，从而对节点进行排序。<br>(2) 零距离(英文名NPL，即Null Path Length)则是从一个节点到一个”最近的不满节点”的路径长度。不满节点是指该该节点的左右孩子至少有有一个为NULL。叶节点的NPL为0，NULL节点的NPL为-1。</p><p>左倾堆有以下几个基本性质：<br>[性质1] 节点的键值小于或等于它的左右子节点的键值。(小顶堆?)<br>[性质2] 节点的左孩子的NPL &gt;= 右孩子的NPL。<br>[性质3] 节点的NPL = 它的右孩子的NPL + 1。</p><h2 id="左倾堆的图文解析"><a href="#左倾堆的图文解析" class="headerlink" title="左倾堆的图文解析"></a>左倾堆的图文解析</h2><p>合并操作是左倾堆的重点。合并两个左倾堆的基本思想如下：<br>(01) 如果一个空左倾堆与一个非空左倾堆合并，返回非空左倾堆。<br>(02) 如果两个左倾堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将”较小堆的根节点的右孩子”和”较大堆”进行合并。<br>(03) 如果新堆的右孩子的NPL &gt; 左孩子的NPL，则交换左右孩子。<br>(04) 设置新堆的根节点的NPL = 右子堆NPL + 1</p><p>下面通过图文演示合并以下两个堆的过程。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011452529377696.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyvalepjj30x40b2759.jpg" alt="img"></a><br><strong>提示</strong>：这两个堆的合并过程和测试程序相对应！</p><p><strong>第1步：将”较小堆(根为10)的右孩子”和”较大堆(根为11)”进行合并。</strong><br>合并的结果，相当于将”较大堆”设置”较小堆”的右孩子，如下图所示：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011453446095544.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyvemd0mj30x40kxwg3.jpg" alt="img"></a></p><p><strong>第2步：将上一步得到的”根11的右子树”和”根为12的树”进行合并</strong>，得到的结果如下：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011454410629829.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyvbqxj3j30x40cd3zb.jpg" alt="img"></a></p><p><strong>第3步：将上一步得到的”根12的右子树”和”根为13的树”进行合并</strong>，得到的结果如下：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011455050785927.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyvav1qrj30x40cdq3q.jpg" alt="img"></a></p><p><strong>第4步：将上一步得到的”根13的右子树”和”根为16的树”进行合并</strong>，得到的结果如下：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011456381256901.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyvcqy75j30x40cdaau.jpg" alt="img"></a></p><p><strong>第5步：将上一步得到的”根16的右子树”和”根为23的树”进行合并</strong>，得到的结果如下：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011457032506325.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyve6gnej30ng0emq3p.jpg" alt="img"></a></p><p>至此，已经成功的将两棵树合并成为一棵树了。接下来，对新生成的树进行调节。</p><p><strong>第6步：上一步得到的”树16的右孩子的NPL &gt; 左孩子的NPL”，因此交换左右孩子。</strong>得到的结果如下：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011457434061924.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyvcauk9j30ng0emaau.jpg" alt="img"></a></p><p><strong>第7步：上一步得到的”树12的右孩子的NPL &gt; 左孩子的NPL”，因此交换左右孩子。</strong>得到的结果如下：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011458120315745.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyvdp12aj30ng0emt9j.jpg" alt="img"></a></p><p><strong>第8步：上一步得到的”树10的右孩子的NPL &gt; 左孩子的NPL”，因此交换左右孩子。</strong>得到的结果如下：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011458431561137.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyvb96idj30ng0ewjs6.jpg" alt="img"></a></p><p>至此，合并完毕。上面就是合并得到的左倾堆！</p><h2 id="左倾堆的基本操作的代码"><a href="#左倾堆的基本操作的代码" class="headerlink" title="左倾堆的基本操作的代码"></a>左倾堆的基本操作的代码</h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeftistHeap</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> LeftistNode&lt;T&gt; mRoot;    <span class="hljs-comment">// 根结点</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeftistNode</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        T key;                    <span class="hljs-comment">// 关键字(键值)</span><br>        <span class="hljs-keyword">int</span> npl;                <span class="hljs-comment">// 零路经长度(Null Path Length)</span><br>        LeftistNode&lt;T&gt; left;    <span class="hljs-comment">// 左孩子</span><br>        LeftistNode&lt;T&gt; right;    <span class="hljs-comment">// 右孩子</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LeftistNode</span><span class="hljs-params">(T key, LeftistNode&lt;T&gt; left, LeftistNode&lt;T&gt; right)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.npl = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"key:"</span>+key;<br>        &#125;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>LeftistNode是左倾堆对应的节点类。<br>LeftistHeap是左倾堆类，它包含了左倾堆的根节点，以及左倾堆的操作。</p><h3 id="2-合并"><a href="#2-合并" class="headerlink" title="2. 合并"></a><strong>2. 合并</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 合并"左倾堆x"和"左倾堆y"<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> LeftistNode&lt;T&gt; <span class="hljs-title">merge</span><span class="hljs-params">(LeftistNode&lt;T&gt; x, LeftistNode&lt;T&gt; y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> y;<br>    <span class="hljs-keyword">if</span>(y == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> x;<br><br>    <span class="hljs-comment">// 合并x和y时，将x作为合并后的树的根；</span><br>    <span class="hljs-comment">// 这里的操作是保证: x的key &lt; y的key</span><br>    <span class="hljs-keyword">if</span>(x.key.compareTo(y.key) &gt; <span class="hljs-number">0</span>) &#123;<br>        LeftistNode&lt;T&gt; tmp = x;<br>        x = y;<br>        y = tmp;<br>    &#125;<br><br>    <span class="hljs-comment">// 将x的右孩子和y合并，"合并后的树的根"是x的右孩子。</span><br>    x.right = merge(x.right, y);<br><br>    <span class="hljs-comment">// 如果"x的左孩子为空" 或者 "x的左孩子的npl&lt;右孩子的npl"</span><br>    <span class="hljs-comment">// 则，交换x和y</span><br>    <span class="hljs-keyword">if</span> (x.left == <span class="hljs-keyword">null</span> || x.left.npl &lt; x.right.npl) &#123;<br>        LeftistNode&lt;T&gt; tmp = x.left;<br>        x.left = x.right;<br>        x.right = tmp;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x.right == <span class="hljs-keyword">null</span> || x.left == <span class="hljs-keyword">null</span>)<br>        x.npl = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>        x.npl = (x.left.npl &gt; x.right.npl) ? (x.right.npl + <span class="hljs-number">1</span>) : (x.left.npl + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(LeftistHeap&lt;T&gt; other)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.mRoot = merge(<span class="hljs-keyword">this</span>.mRoot, other.mRoot);<br>&#125;<br></code></pre></td></tr></table></figure><p>merge(x, y)是内部接口，作用是合并x和y这两个左倾堆，并返回得到的新堆的根节点。<br>merge(other)是外部接口，作用是将other合并到当前堆中。</p><h3 id="3-添加"><a href="#3-添加" class="headerlink" title="3. 添加"></a><strong>3. 添加</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 新建结点(key)，并将其插入到左倾堆中<br> *<br> * 参数说明：<br> *     key 插入结点的键值<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T key)</span> </span>&#123;<br>    LeftistNode&lt;T&gt; node = <span class="hljs-keyword">new</span> LeftistNode&lt;T&gt;(key,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-comment">// 如果新建结点失败，则返回。</span><br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">this</span>.mRoot = merge(<span class="hljs-keyword">this</span>.mRoot, node);<br>&#125;<br></code></pre></td></tr></table></figure><p>insert(key)的作用是新建键值为key的节点，并将其加入到当前左倾堆中。</p><h3 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a><strong>4. 删除</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 删除根结点<br> * <br> * 返回值：<br> *     返回被删除的节点的键值<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mRoot == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    T key = <span class="hljs-keyword">this</span>.mRoot.key;<br>    LeftistNode&lt;T&gt; l = <span class="hljs-keyword">this</span>.mRoot.left;<br>    LeftistNode&lt;T&gt; r = <span class="hljs-keyword">this</span>.mRoot.right;<br><br>    <span class="hljs-keyword">this</span>.mRoot = <span class="hljs-keyword">null</span>;          <span class="hljs-comment">// 删除根节点</span><br>    <span class="hljs-keyword">this</span>.mRoot = merge(l, r);   <span class="hljs-comment">// 合并左右子树</span><br><br>    <span class="hljs-keyword">return</span> key;<br>&#125;<br></code></pre></td></tr></table></figure><p>remove()的作用是删除左倾堆的最小节点。</p><h2 id="左倾堆的Java实现-完整源码"><a href="#左倾堆的Java实现-完整源码" class="headerlink" title="左倾堆的Java实现(完整源码)"></a><strong>左倾堆的Java实现(完整源码)</strong></h2><h3 id="左倾堆的实现文件-LeftistHeap-java"><a href="#左倾堆的实现文件-LeftistHeap-java" class="headerlink" title="左倾堆的实现文件(LeftistHeap.java)"></a>左倾堆的实现文件(LeftistHeap.java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeftistHeap</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> LeftistNode&lt;T&gt; mRoot;    <span class="hljs-comment">// 根结点</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeftistNode</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        T key;                    <span class="hljs-comment">// 关键字(键值)</span><br>        <span class="hljs-keyword">int</span> npl;                <span class="hljs-comment">// 零路经长度(Null Path Length)</span><br>        LeftistNode&lt;T&gt; left;    <span class="hljs-comment">// 左孩子</span><br>        LeftistNode&lt;T&gt; right;    <span class="hljs-comment">// 右孩子</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LeftistNode</span><span class="hljs-params">(T key, LeftistNode&lt;T&gt; left, LeftistNode&lt;T&gt; right)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.npl = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"key:"</span>+key;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LeftistHeap</span><span class="hljs-params">()</span> </span>&#123;<br>        mRoot = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 前序遍历"左倾堆"<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(LeftistNode&lt;T&gt; heap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(heap != <span class="hljs-keyword">null</span>) &#123;<br>            System.out.print(heap.key+<span class="hljs-string">" "</span>);<br>            preOrder(heap.left);<br>            preOrder(heap.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        preOrder(mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 中序遍历"左倾堆"<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(LeftistNode&lt;T&gt; heap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(heap != <span class="hljs-keyword">null</span>) &#123;<br>            inOrder(heap.left);<br>            System.out.print(heap.key+<span class="hljs-string">" "</span>);<br>            inOrder(heap.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        inOrder(mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 后序遍历"左倾堆"<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(LeftistNode&lt;T&gt; heap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(heap != <span class="hljs-keyword">null</span>)<br>        &#123;<br>            postOrder(heap.left);<br>            postOrder(heap.right);<br>            System.out.print(heap.key+<span class="hljs-string">" "</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        postOrder(mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 合并"左倾堆x"和"左倾堆y"<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> LeftistNode&lt;T&gt; <span class="hljs-title">merge</span><span class="hljs-params">(LeftistNode&lt;T&gt; x, LeftistNode&lt;T&gt; y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> y;<br>        <span class="hljs-keyword">if</span>(y == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> x;<br><br>        <span class="hljs-comment">// 合并x和y时，将x作为合并后的树的根；</span><br>        <span class="hljs-comment">// 这里的操作是保证: x的key &lt; y的key</span><br>        <span class="hljs-keyword">if</span>(x.key.compareTo(y.key) &gt; <span class="hljs-number">0</span>) &#123;<br>            LeftistNode&lt;T&gt; tmp = x;<br>            x = y;<br>            y = tmp;<br>        &#125;<br><br>        <span class="hljs-comment">// 将x的右孩子和y合并，"合并后的树的根"是x的右孩子。</span><br>        x.right = merge(x.right, y);<br><br>        <span class="hljs-comment">// 如果"x的左孩子为空" 或者 "x的左孩子的npl&lt;右孩子的npl"</span><br>        <span class="hljs-comment">// 则，交换x和y</span><br>        <span class="hljs-keyword">if</span> (x.left == <span class="hljs-keyword">null</span> || x.left.npl &lt; x.right.npl) &#123;<br>            LeftistNode&lt;T&gt; tmp = x.left;<br>            x.left = x.right;<br>            x.right = tmp;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x.right == <span class="hljs-keyword">null</span> || x.left == <span class="hljs-keyword">null</span>)<br>            x.npl = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span><br>            x.npl = (x.left.npl &gt; x.right.npl) ? (x.right.npl + <span class="hljs-number">1</span>) : (x.left.npl + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(LeftistHeap&lt;T&gt; other)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mRoot = merge(<span class="hljs-keyword">this</span>.mRoot, other.mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 新建结点(key)，并将其插入到左倾堆中<br>     *<br>     * 参数说明：<br>     *     key 插入结点的键值<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T key)</span> </span>&#123;<br>        LeftistNode&lt;T&gt; node = <span class="hljs-keyword">new</span> LeftistNode&lt;T&gt;(key,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">// 如果新建结点失败，则返回。</span><br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">this</span>.mRoot = merge(<span class="hljs-keyword">this</span>.mRoot, node);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 删除根结点<br>     *<br>     * 返回值：<br>     *     返回被删除的节点的键值<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mRoot == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        T key = <span class="hljs-keyword">this</span>.mRoot.key;<br>        LeftistNode&lt;T&gt; l = <span class="hljs-keyword">this</span>.mRoot.left;<br>        LeftistNode&lt;T&gt; r = <span class="hljs-keyword">this</span>.mRoot.right;<br><br>        <span class="hljs-keyword">this</span>.mRoot = <span class="hljs-keyword">null</span>;          <span class="hljs-comment">// 删除根节点</span><br>        <span class="hljs-keyword">this</span>.mRoot = merge(l, r);   <span class="hljs-comment">// 合并左右子树</span><br><br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 销毁左倾堆<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(LeftistNode&lt;T&gt; heap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (heap==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span> (heap.left != <span class="hljs-keyword">null</span>)<br>            destroy(heap.left);<br>        <span class="hljs-keyword">if</span> (heap.right != <span class="hljs-keyword">null</span>)<br>            destroy(heap.right);<br><br>        heap=<span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>        destroy(mRoot);<br>        mRoot = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 打印"左倾堆"<br>     *<br>     * key        -- 节点的键值<br>     * direction  --  0，表示该节点是根节点;<br>     *               -1，表示该节点是它的父结点的左孩子;<br>     *                1，表示该节点是它的父结点的右孩子。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(LeftistNode&lt;T&gt; heap, T key, <span class="hljs-keyword">int</span> direction)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(heap != <span class="hljs-keyword">null</span>) &#123;<br><br>            <span class="hljs-keyword">if</span>(direction==<span class="hljs-number">0</span>)    <span class="hljs-comment">// heap是根节点</span><br>                System.out.printf(<span class="hljs-string">"%2d(%d) is root\n"</span>, heap.key, heap.npl);<br>            <span class="hljs-keyword">else</span>                <span class="hljs-comment">// heap是分支节点</span><br>                System.out.printf(<span class="hljs-string">"%2d(%d) is %2d's %6s child\n"</span>, heap.key, heap.npl, key, direction==<span class="hljs-number">1</span>?<span class="hljs-string">"right"</span> : <span class="hljs-string">"left"</span>);<br><br>            print(heap.left, heap.key, -<span class="hljs-number">1</span>);<br>            print(heap.right,heap.key,  <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mRoot != <span class="hljs-keyword">null</span>)<br>            print(mRoot, mRoot.key, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="左倾堆的测试程序-LeftistHeapTest-java"><a href="#左倾堆的测试程序-LeftistHeapTest-java" class="headerlink" title="左倾堆的测试程序(LeftistHeapTest.java)"></a>左倾堆的测试程序(LeftistHeapTest.java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeftistHeapTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> a[]= &#123;<span class="hljs-number">10</span>,<span class="hljs-number">40</span>,<span class="hljs-number">24</span>,<span class="hljs-number">30</span>,<span class="hljs-number">36</span>,<span class="hljs-number">20</span>,<span class="hljs-number">12</span>,<span class="hljs-number">16</span>&#125;;<br>        <span class="hljs-keyword">int</span> b[]= &#123;<span class="hljs-number">17</span>,<span class="hljs-number">13</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>,<span class="hljs-number">19</span>,<span class="hljs-number">21</span>,<span class="hljs-number">23</span>&#125;;<br>        LeftistHeap&lt;Integer&gt; ha=<span class="hljs-keyword">new</span> LeftistHeap&lt;Integer&gt;();<br>        LeftistHeap&lt;Integer&gt; hb=<span class="hljs-keyword">new</span> LeftistHeap&lt;Integer&gt;();<br><br>        System.out.printf(<span class="hljs-string">"== 左倾堆(ha)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            ha.insert(a[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n== 左倾堆(ha)的详细信息: \n"</span>);<br>        ha.print();<br><br><br>        System.out.printf(<span class="hljs-string">"\n== 左倾堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n== 左倾堆(hb)的详细信息: \n"</span>);<br>        hb.print();<br><br>        <span class="hljs-comment">// 将"左倾堆hb"合并到"左倾堆ha"中。</span><br>        ha.merge(hb);<br>        System.out.printf(<span class="hljs-string">"\n== 合并ha和hb后的详细信息: \n"</span>);<br>        ha.print();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ada">== 左倾堆(ha)中依次添加: <span class="hljs-number">10</span> <span class="hljs-number">40</span> <span class="hljs-number">24</span> <span class="hljs-number">30</span> <span class="hljs-number">36</span> <span class="hljs-number">20</span> <span class="hljs-number">12</span> <span class="hljs-number">16</span> <br>== 左倾堆(ha)的详细信息: <br><span class="hljs-number">10</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">is</span> root<br><span class="hljs-number">24</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">10</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">30</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">24</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">36</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">24</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">12</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">10</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">20</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">12</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">40</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">20</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">16</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">12</span><span class="hljs-symbol">'s</span>  right child<br><br>== 左倾堆(hb)中依次添加: <span class="hljs-number">17</span> <span class="hljs-number">13</span> <span class="hljs-number">11</span> <span class="hljs-number">15</span> <span class="hljs-number">19</span> <span class="hljs-number">21</span> <span class="hljs-number">23</span> <br>== 左倾堆(hb)的详细信息: <br><span class="hljs-number">11</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">is</span> root<br><span class="hljs-number">15</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">11</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">19</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">15</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">21</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">15</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">13</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">11</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">17</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">13</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">23</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">13</span><span class="hljs-symbol">'s</span>  right child<br><br>== 合并ha和hb后的详细信息: <br><span class="hljs-number">10</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">is</span> root<br><span class="hljs-number">11</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">10</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">15</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">11</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">19</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">15</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">21</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">15</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">12</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">11</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">13</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">12</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">17</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">13</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">16</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">13</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">23</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">16</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">20</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">12</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">40</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">20</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">24</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">10</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">30</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">24</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">36</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">24</span><span class="hljs-symbol">'s</span>  right child<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.1.堆</title>
      <link href="/2021/11/17/6.1.%E5%A0%86/"/>
      <url>/2021/11/17/6.1.%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 Heap"></a>堆 Heap</h1><h2 id="1-堆的定义"><a href="#1-堆的定义" class="headerlink" title="1. 堆的定义"></a>1. 堆的定义</h2><p>堆是一种数据结构具有以下的特点：<br>1）<strong>完全二叉树</strong>：除了最后一层结点，其它层的结点数都达到了最大值；同时最后一层的结点都是按照从左到右依次排布。<br>2）堆中存储的值是<strong>偏序</strong>；</p><p><strong>Min-heap</strong>(小根堆，小顶堆): 父节点的值小于或等于子节点的值；<br><strong>Max-heap</strong>(大根堆，大顶堆): 父节点的值大于或等于子节点的值；</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlv796k8ej30ib0bb0to.jpg" alt="img"></p><p>堆的常用方法：</p><ul><li>构建优先队列</li><li>支持堆排序</li><li>快速找出一个集合中的最小值（或者最大值）</li></ul><p>堆常用来实现优先队列，在面试中经常考的问题都是与排序有关，比如<strong>==堆排序==</strong>、<strong>==topK问题==</strong>等。由于堆的根节点是序列中最大或者最小值，因而可以在建堆以及重建堆的过程中，筛选出数据序列中的极值，从而达到排序或者挑选topK值的目的。</p><h2 id="2-堆的存储："><a href="#2-堆的存储：" class="headerlink" title="2. 堆的存储："></a><strong>2. 堆的存储：</strong></h2><p>之前说到，堆是一种完全二叉树，但是否就意味着我们真的要用树来表示它呢？答案是否定的，因为完全二叉树有其非常卓越的性质：<strong>对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1,2n+2</strong>，因此我们可以直接用数组来表示一个堆。如第0个结点左右子结点下标分别为1和2。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlv8nck8wg30be04m74g.gif" alt="img"></p><table><thead><tr><th align="left"></th><th>堆</th><th>二叉搜索树</th></tr></thead><tbody><tr><td align="left">节点的顺序</td><td>在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。</td><td>左子节点必须比父节点小，右子节点必须必比父节点大。</td></tr><tr><td align="left">内存占用</td><td>堆仅仅使用一个数组来存储数据，且不使用指针。</td><td>普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配内存。</td></tr><tr><td align="left">平衡</td><td>堆中实际上不需要整棵树都是有序的,我们只需要满足堆属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证<strong>O(log n)</strong> 的性能。</td><td>二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到<strong>O(log n)</strong>。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树</td></tr><tr><td align="left">搜索</td><td>慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。</td><td>快</td></tr></tbody></table><h2 id="3-堆的操作"><a href="#3-堆的操作" class="headerlink" title="3. 堆的操作"></a>3. 堆的操作</h2><h3 id="insert-Push"><a href="#insert-Push" class="headerlink" title="insert(Push)"></a><strong>insert(Push)</strong></h3><p>插入一个元素：新元素被加入到heap的末尾，然后更新树以恢复堆的次序。<br>每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中——这就类似于直接插入排序中将一个数据并入到有序区间中。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlvistp98j30kv0jxab7.jpg" alt="img"></p><p><strong>最大堆的插入代码(Java语言)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 最大堆的向上调整算法(从start开始向上直到0，调整堆)<br> *<br> * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。<br> *<br> * 参数说明：<br> *     start -- 被上调节点的起始位置(一般为数组中最后一个元素的索引)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> c = start;            <span class="hljs-comment">// 当前节点(current)的位置</span><br>    <span class="hljs-keyword">int</span> p = (c-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;        <span class="hljs-comment">// 父(parent)结点的位置 </span><br>    T tmp = mHeap.get(c);        <span class="hljs-comment">// 当前节点(current)的大小</span><br><br>    <span class="hljs-keyword">while</span>(c &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> cmp = mHeap.get(p).compareTo(tmp);<br>        <span class="hljs-keyword">if</span>(cmp &gt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            mHeap.set(c, mHeap.get(p));<br>            c = p;<br>            p = (p-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;   <br>        &#125;       <br>    &#125;<br>    mHeap.set(c, tmp);<br>&#125;<br>  <br><span class="hljs-comment">/* <br> * 将data插入到二叉堆中<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T data)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> size = mHeap.size();<br><br>    mHeap.add(data);    <span class="hljs-comment">// 将"数组"插在表尾</span><br>    filterup(size);        <span class="hljs-comment">// 向上调整堆</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Removemax-Pop"><a href="#Removemax-Pop" class="headerlink" title="Removemax(Pop)"></a><strong>Removemax(Pop)</strong></h3><p>按定义，堆中每次都删除第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最大的，如果父结点比这个最小的子结点还大说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlvjvfq44j30u014bwgw.jpg" alt="img"></p><p><strong>二叉堆的删除代码(Java语言)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 最大堆的向下调整算法<br> *<br> * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。<br> *<br> * 参数说明：<br> *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)<br> *     end   -- 截至范围(一般为数组中最后一个元素的索引)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> c = start;          <span class="hljs-comment">// 当前(current)节点的位置</span><br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>*c + <span class="hljs-number">1</span>;     <span class="hljs-comment">// 左(left)孩子的位置</span><br>    T tmp = mHeap.get(c);    <span class="hljs-comment">// 当前(current)节点的大小</span><br><br>    <span class="hljs-keyword">while</span>(l &lt;= end) &#123;<br>        <span class="hljs-keyword">int</span> cmp = mHeap.get(l).compareTo(mHeap.get(l+<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// "l"是左孩子，"l+1"是右孩子</span><br>        <span class="hljs-keyword">if</span>(l &lt; end &amp;&amp; cmp&lt;<span class="hljs-number">0</span>)<br>            l++;        <span class="hljs-comment">// 左右两孩子中选择较大者，即mHeap[l+1]</span><br>        cmp = tmp.compareTo(mHeap.get(l));<br>        <span class="hljs-keyword">if</span>(cmp &gt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;        <span class="hljs-comment">//调整结束</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            mHeap.set(c, mHeap.get(l));<br>            c = l;<br>            l = <span class="hljs-number">2</span>*l + <span class="hljs-number">1</span>;   <br>        &#125;       <br>    &#125;   <br>    mHeap.set(c, tmp);<br>&#125;<br><br><span class="hljs-comment">/*<br> * 删除最大堆中的data<br> *<br> * 返回值：<br> *      0，成功<br> *     -1，失败<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">remove</span><span class="hljs-params">(T data)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果"堆"已空，则返回-1</span><br>    <span class="hljs-keyword">if</span>(mHeap.isEmpty() == <span class="hljs-keyword">true</span>)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 获取data在数组中的索引</span><br>    <span class="hljs-keyword">int</span> index = mHeap.indexOf(data);<br>    <span class="hljs-keyword">if</span> (index==-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">int</span> size = mHeap.size();<br>    mHeap.set(index, mHeap.get(size-<span class="hljs-number">1</span>));<span class="hljs-comment">// 用最后元素填补</span><br>    mHeap.remove(size - <span class="hljs-number">1</span>);                <span class="hljs-comment">// 删除最后的元素</span><br><br>    <span class="hljs-keyword">if</span> (mHeap.size() &gt; <span class="hljs-number">1</span>)<br>        filterdown(index, mHeap.size()-<span class="hljs-number">1</span>);    <span class="hljs-comment">// 从index号位置开始自上向下调整为最小堆</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="buildHeap堆化数组"><a href="#buildHeap堆化数组" class="headerlink" title="buildHeap堆化数组"></a><strong>buildHeap</strong>堆化数组</h3><p>对于叶子节点，不用调整次序，根据满二叉树的性质，叶子节点比内部节点的个数多1.所以i=n/2 -1 ，不用从n开始。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlvcx13epj30ka0ds76u.jpg" alt="img"></p><h2 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4. 堆排序"></a>4. 堆排序</h2><p>堆建好之后堆中第0个数据是堆中最大的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最大的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。</p><h2 id="5-堆的实现"><a href="#5-堆的实现" class="headerlink" title="5. 堆的实现"></a>5. 堆的实现</h2><h3 id="二叉堆-最大堆-的实现"><a href="#二叉堆-最大堆-的实现" class="headerlink" title="二叉堆(最大堆)的实现"></a>二叉堆(最大堆)的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * 二叉堆(最大堆)<br> */</span><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxHeap</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;T&gt; mHeap;    <span class="hljs-comment">// 队列(实际上是动态数组ArrayList的实例)</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxHeap</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mHeap = <span class="hljs-keyword">new</span> ArrayList&lt;T&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 最大堆的向下调整算法<br>     *<br>     * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。<br>     *<br>     * 参数说明：<br>     *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)<br>     *     end   -- 截至范围(一般为数组中最后一个元素的索引)<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = start;          <span class="hljs-comment">// 当前(current)节点的位置</span><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>*c + <span class="hljs-number">1</span>;     <span class="hljs-comment">// 左(left)孩子的位置</span><br>        T tmp = mHeap.get(c);    <span class="hljs-comment">// 当前(current)节点的大小</span><br><br>        <span class="hljs-keyword">while</span>(l &lt;= end) &#123;<br>            <span class="hljs-keyword">int</span> cmp = mHeap.get(l).compareTo(mHeap.get(l+<span class="hljs-number">1</span>));<br>            <span class="hljs-comment">// "l"是左孩子，"l+1"是右孩子</span><br>            <span class="hljs-keyword">if</span>(l &lt; end &amp;&amp; cmp&lt;<span class="hljs-number">0</span>)<br>                l++;        <span class="hljs-comment">// 左右两孩子中选择较大者，即mHeap[l+1]</span><br>            cmp = tmp.compareTo(mHeap.get(l));<br>            <span class="hljs-keyword">if</span>(cmp &gt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;        <span class="hljs-comment">//调整结束</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                mHeap.set(c, mHeap.get(l));<br>                c = l;<br>                l = <span class="hljs-number">2</span>*l + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        mHeap.set(c, tmp);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 删除最大堆中的data<br>     *<br>     * 返回值：<br>     *      0，成功<br>     *     -1，失败<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">remove</span><span class="hljs-params">(T data)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果"堆"已空，则返回-1</span><br>        <span class="hljs-keyword">if</span>(mHeap.isEmpty() == <span class="hljs-keyword">true</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 获取data在数组中的索引</span><br>        <span class="hljs-keyword">int</span> index = mHeap.indexOf(data);<br>        <span class="hljs-keyword">if</span> (index==-<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">int</span> size = mHeap.size();<br>        mHeap.set(index, mHeap.get(size-<span class="hljs-number">1</span>));<span class="hljs-comment">// 用最后元素填补</span><br>        mHeap.remove(size - <span class="hljs-number">1</span>);                <span class="hljs-comment">// 删除最后的元素</span><br><br>        <span class="hljs-keyword">if</span> (mHeap.size() &gt; <span class="hljs-number">1</span>)<br>            filterdown(index, mHeap.size()-<span class="hljs-number">1</span>);    <span class="hljs-comment">// 从index号位置开始自上向下调整为最小堆</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 最大堆的向上调整算法(从start开始向上直到0，调整堆)<br>     *<br>     * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。<br>     *<br>     * 参数说明：<br>     *     start -- 被上调节点的起始位置(一般为数组中最后一个元素的索引)<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = start;            <span class="hljs-comment">// 当前节点(current)的位置</span><br>        <span class="hljs-keyword">int</span> p = (c-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;        <span class="hljs-comment">// 父(parent)结点的位置</span><br>        T tmp = mHeap.get(c);        <span class="hljs-comment">// 当前节点(current)的大小</span><br><br>        <span class="hljs-keyword">while</span>(c &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> cmp = mHeap.get(p).compareTo(tmp);<br>            <span class="hljs-keyword">if</span>(cmp &gt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                mHeap.set(c, mHeap.get(p));<br>                c = p;<br>                p = (p-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        mHeap.set(c, tmp);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将data插入到二叉堆中<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T data)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = mHeap.size();<br><br>        mHeap.add(data);    <span class="hljs-comment">// 将"数组"插在表尾</span><br>        filterup(size);        <span class="hljs-comment">// 向上调整堆</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;mHeap.size(); i++)<br>            sb.append(mHeap.get(i) +<span class="hljs-string">" "</span>);<br><br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">60</span>, <span class="hljs-number">90</span>, <span class="hljs-number">70</span>, <span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">80</span>&#125;;<br>        MaxHeap&lt;Integer&gt; tree=<span class="hljs-keyword">new</span> MaxHeap&lt;Integer&gt;();<br><br>        System.out.printf(<span class="hljs-string">"== 依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            tree.insert(a[i]);<br>        &#125;<br><br>        System.out.printf(<span class="hljs-string">"\n== 最 大 堆: %s"</span>, tree);<br><br>        i=<span class="hljs-number">85</span>;<br>        tree.insert(i);<br>        System.out.printf(<span class="hljs-string">"\n== 添加元素: %d"</span>, i);<br>        System.out.printf(<span class="hljs-string">"\n== 最 大 堆: %s"</span>, tree);<br><br>        i=<span class="hljs-number">90</span>;<br>        tree.remove(i);<br>        System.out.printf(<span class="hljs-string">"\n== 删除元素: %d"</span>, i);<br>        System.out.printf(<span class="hljs-string">"\n== 最 大 堆: %s"</span>, tree);<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉堆-最小堆-的实现"><a href="#二叉堆-最小堆-的实现" class="headerlink" title="二叉堆(最小堆)的实现"></a>二叉堆(最小堆)的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * 二叉堆(最小堆)<br> */</span><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHeap</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;T&gt; mHeap;        <span class="hljs-comment">// 存放堆的数组</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinHeap</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mHeap = <span class="hljs-keyword">new</span> ArrayList&lt;T&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 最小堆的向下调整算法<br>     *<br>     * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。<br>     *<br>     * 参数说明：<br>     *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)<br>     *     end   -- 截至范围(一般为数组中最后一个元素的索引)<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = start;          <span class="hljs-comment">// 当前(current)节点的位置</span><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>*c + <span class="hljs-number">1</span>;     <span class="hljs-comment">// 左(left)孩子的位置</span><br>        T tmp = mHeap.get(c);    <span class="hljs-comment">// 当前(current)节点的大小</span><br><br>        <span class="hljs-keyword">while</span>(l &lt;= end) &#123;<br>            <span class="hljs-keyword">int</span> cmp = mHeap.get(l).compareTo(mHeap.get(l+<span class="hljs-number">1</span>));<br>            <span class="hljs-comment">// "l"是左孩子，"l+1"是右孩子</span><br>            <span class="hljs-keyword">if</span>(l &lt; end &amp;&amp; cmp&gt;<span class="hljs-number">0</span>)<br>                l++;        <span class="hljs-comment">// 左右两孩子中选择较小者，即mHeap[l+1]</span><br><br>            cmp = tmp.compareTo(mHeap.get(l));<br>            <span class="hljs-keyword">if</span>(cmp &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;        <span class="hljs-comment">//调整结束</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                mHeap.set(c, mHeap.get(l));<br>                c = l;<br>                l = <span class="hljs-number">2</span>*l + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        mHeap.set(c, tmp);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 最小堆的删除<br>     *<br>     * 返回值：<br>     *     成功，返回被删除的值<br>     *     失败，返回null<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">remove</span><span class="hljs-params">(T data)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果"堆"已空，则返回-1</span><br>        <span class="hljs-keyword">if</span>(mHeap.isEmpty() == <span class="hljs-keyword">true</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 获取data在数组中的索引</span><br>        <span class="hljs-keyword">int</span> index = mHeap.indexOf(data);<br>        <span class="hljs-keyword">if</span> (index==-<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">int</span> size = mHeap.size();<br>        mHeap.set(index, mHeap.get(size-<span class="hljs-number">1</span>));<span class="hljs-comment">// 用最后元素填补</span><br>        mHeap.remove(size - <span class="hljs-number">1</span>);                <span class="hljs-comment">// 删除最后的元素</span><br><br>        <span class="hljs-keyword">if</span> (mHeap.size() &gt; <span class="hljs-number">1</span>)<br>            filterdown(index, mHeap.size()-<span class="hljs-number">1</span>);    <span class="hljs-comment">// 从index号位置开始自上向下调整为最小堆</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 最小堆的向上调整算法(从start开始向上直到0，调整堆)<br>     *<br>     * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。<br>     *<br>     * 参数说明：<br>     *     start -- 被上调节点的起始位置(一般为数组中最后一个元素的索引)<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = start;            <span class="hljs-comment">// 当前节点(current)的位置</span><br>        <span class="hljs-keyword">int</span> p = (c-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;        <span class="hljs-comment">// 父(parent)结点的位置</span><br>        T tmp = mHeap.get(c);        <span class="hljs-comment">// 当前节点(current)的大小</span><br><br>        <span class="hljs-keyword">while</span>(c &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> cmp = mHeap.get(p).compareTo(tmp);<br>            <span class="hljs-keyword">if</span>(cmp &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                mHeap.set(c, mHeap.get(p));<br>                c = p;<br>                p = (p-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        mHeap.set(c, tmp);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将data插入到二叉堆中<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T data)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = mHeap.size();<br><br>        mHeap.add(data);    <span class="hljs-comment">// 将"数组"插在表尾</span><br>        filterup(size);        <span class="hljs-comment">// 向上调整堆</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;mHeap.size(); i++)<br>            sb.append(mHeap.get(i) +<span class="hljs-string">" "</span>);<br><br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">80</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">60</span>, <span class="hljs-number">90</span>, <span class="hljs-number">70</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>&#125;;<br>        MinHeap&lt;Integer&gt; tree=<span class="hljs-keyword">new</span> MinHeap&lt;Integer&gt;();<br><br>        System.out.printf(<span class="hljs-string">"== 依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            tree.insert(a[i]);<br>        &#125;<br><br>        System.out.printf(<span class="hljs-string">"\n== 最 小 堆: %s"</span>, tree);<br><br>        i=<span class="hljs-number">15</span>;<br>        tree.insert(i);<br>        System.out.printf(<span class="hljs-string">"\n== 添加元素: %d"</span>, i);<br>        System.out.printf(<span class="hljs-string">"\n== 最 小 堆: %s"</span>, tree);<br><br>        i=<span class="hljs-number">10</span>;<br>        tree.remove(i);<br>        System.out.printf(<span class="hljs-string">"\n== 删除元素: %d"</span>, i);<br>        System.out.printf(<span class="hljs-string">"\n== 最 小 堆: %s"</span>, tree);<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.2.3.最优二叉树--哈夫曼树</title>
      <link href="/2021/11/17/5.2.3.%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91--%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
      <url>/2021/11/17/5.2.3.%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91--%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a><strong>哈夫曼树</strong></h1><h2 id="1-定义与概念"><a href="#1-定义与概念" class="headerlink" title="1.定义与概念"></a>1.定义与概念</h2><p>Huffman Tree，中文名是哈夫曼树或霍夫曼树，它是最优二叉树。</p><p><strong>定义</strong>：给定n个权值作为n个叶子结点，构造一棵二叉树，若树的==带权路径长度达到最小==，则这棵树被称为哈夫曼树。 这个定义里面涉及到了几个陌生的概念，下面就是一颗哈夫曼树，我们来看图解答。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/tree/huffman/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlntgjw8bj308f06v0ss.jpg" alt="img"></a></p><p>(01) 路径和路径长度</p><blockquote><p><strong>定义</strong>：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。<br><strong>例子</strong>：100和80的路径长度是1，50和30的路径长度是2，20和10的路径长度是3。</p></blockquote><p>(02) 结点的权及带权路径长度</p><blockquote><p><strong>定义</strong>：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。<br><strong>例子</strong>：节点20的路径长度是3，它的带权路径长度= 路径长度 * 权 = 3 * 20 = 60。</p></blockquote><p>(03) 树的带权路径长度</p><blockquote><p><strong>定义</strong>：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。<br><strong>例子</strong>：示例中，树的WPL= 1X100 + 2X50 + 3X20 + 3X10 = 100 + 100 + 60 + 30 = 290。</p></blockquote><p>比较下面两棵树</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/tree/huffman/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlo1e4b8nj30hd06v74m.jpg" alt="img"></a></p><p>上面的两棵树都是以{10, 20, 50, 100}为叶子节点的树。</p><blockquote><p>左边的树WPL=2x10 + 2x20 + 2x50 + 2x100 = 360<br>右边的树WPL=290</p></blockquote><p>左边的树WPL &gt; 右边的树的WPL。你也可以计算除上面两种示例之外的情况，但实际上右边的树就是{10,20,50,100}对应的哈夫曼树。至此，应该堆哈夫曼树的概念有了一定的了解了，下面看看如何去构造一棵哈夫曼树。</p><h2 id="2-如何构造哈夫曼树"><a href="#2-如何构造哈夫曼树" class="headerlink" title="2.如何构造哈夫曼树"></a>2.如何构造哈夫曼树</h2><p>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，哈夫曼树的构造规则为：</p><blockquote><p><strong>1</strong>. 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；<br><strong>2</strong>. 在森林中选出根结点的权值最小的两棵树进行合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；<br><strong>3</strong>. 从森林中删除选取的两棵树，并将新树加入森林；<br><strong>4</strong>. 重复(02)、(03)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。</p></blockquote><p>以{5,6,7,8,15}为例，来构造一棵哈夫曼树。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/tree/huffman/03.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlo3erlp0j30eq0nnt9w.jpg" alt="img"></a></p><p><strong>第1步</strong>：创建森林，森林包括5棵树，这5棵树的权值分别是5,6,7,8,15。<br><strong>第2步</strong>：在森林中，选择根节点权值最小的两棵树(5和6)来进行合并，将它们作为一颗新树的左右孩子(谁左谁右无关紧要，这里，我们选择较小的作为左孩子)，并且新树的权值是左右孩子的权值之和。即，新树的权值是11。 然后，将”树5”和”树6”从森林中删除，并将新的树(树11)添加到森林中。<br><strong>第3步</strong>：在森林中，选择根节点权值最小的两棵树(7和8)来进行合并。得到的新树的权值是15。 然后，将”树7”和”树8”从森林中删除，并将新的树(树15)添加到森林中。<br><strong>第4步</strong>：在森林中，选择根节点权值最小的两棵树(11和15)来进行合并。得到的新树的权值是26。 然后，将”树11”和”树15”从森林中删除，并将新的树(树26)添加到森林中。<br><strong>第5步</strong>：在森林中，选择根节点权值最小的两棵树(15和26)来进行合并。得到的新树的权值是41。 然后，将”树15”和”树26”从森林中删除，并将新的树(树41)添加到森林中。<br>此时，森林中只有一棵树(树41)。这棵树就是我们需要的哈夫曼树！</p><h2 id="3-构造哈夫曼树代码"><a href="#3-构造哈夫曼树代码" class="headerlink" title="3.构造哈夫曼树代码"></a>3.构造哈夫曼树代码</h2><p>哈夫曼树的重点是如何构造哈夫曼树。本文构造哈夫曼时，用到了以前介绍过的”(二叉堆)最小堆”。下面对哈夫曼树进行讲解。</p><ol><li>HuffmanNode是哈夫曼树的节点类。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * Huffman节点类(Huffman.java的辅助类)<br> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuffmanNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>, <span class="hljs-title">Cloneable</span> </span>&#123;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> key;<span class="hljs-comment">// 权值</span><br><span class="hljs-keyword">protected</span> HuffmanNode left;<span class="hljs-comment">// 左孩子</span><br><span class="hljs-keyword">protected</span> HuffmanNode right;<span class="hljs-comment">// 右孩子</span><br><span class="hljs-keyword">protected</span> HuffmanNode parent;<span class="hljs-comment">// 父结点</span><br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">HuffmanNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, HuffmanNode left, HuffmanNode right, HuffmanNode parent)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.key = key;<br><span class="hljs-keyword">this</span>.left = left;<br><span class="hljs-keyword">this</span>.right = right;<br><span class="hljs-keyword">this</span>.parent = parent;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>Object obj=<span class="hljs-keyword">null</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>obj = (HuffmanNode)<span class="hljs-keyword">super</span>.clone();<span class="hljs-comment">//Object 中的clone()识别出你要复制的是哪一个对象。    </span><br>&#125; <span class="hljs-keyword">catch</span>(CloneNotSupportedException e) &#123;<br>System.out.println(e.toString());<br>&#125;<br><br><span class="hljs-keyword">return</span> obj;    <br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.key - ((HuffmanNode)obj).key;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>Huffman是哈夫曼树对应的类，它包含了哈夫曼树的根节点和哈夫曼树的相关操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * Huffman树<br> */</span><br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Huffman</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> HuffmanNode mRoot;<span class="hljs-comment">// 根结点</span><br><br><span class="hljs-comment">/* <br> * 创建Huffman树<br> *<br> * @param 权值数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Huffman</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[])</span> </span>&#123;<br>        HuffmanNode parent = <span class="hljs-keyword">null</span>;<br>MinHeap heap;<br><br><span class="hljs-comment">// 建立数组a对应的最小堆</span><br>heap = <span class="hljs-keyword">new</span> MinHeap(a);<br> <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length-<span class="hljs-number">1</span>; i++) &#123;   <br>        HuffmanNode left = heap.dumpFromMinimum();  <span class="hljs-comment">// 最小节点是左孩子</span><br>        HuffmanNode right = heap.dumpFromMinimum(); <span class="hljs-comment">// 其次才是右孩子</span><br> <br><span class="hljs-comment">// 新建parent节点，左右孩子分别是left/right；</span><br><span class="hljs-comment">// parent的大小是左右孩子之和</span><br>parent = <span class="hljs-keyword">new</span> HuffmanNode(left.key+right.key, left, right, <span class="hljs-keyword">null</span>);<br>left.parent = parent;<br>right.parent = parent;<br><br><span class="hljs-comment">// 将parent节点数据拷贝到"最小堆"中</span><br>heap.insert(parent);<br>&#125;<br><br>mRoot = parent;<br><br><span class="hljs-comment">// 销毁最小堆</span><br>heap.destroy();<br>&#125;<br><br><span class="hljs-comment">/*<br> * 前序遍历"Huffman树"<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(HuffmanNode tree)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(tree != <span class="hljs-keyword">null</span>) &#123;<br>System.out.print(tree.key+<span class="hljs-string">" "</span>);<br>preOrder(tree.left);<br>preOrder(tree.right);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> </span>&#123;<br>preOrder(mRoot);<br>&#125;<br><br><span class="hljs-comment">/*<br> * 中序遍历"Huffman树"<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(HuffmanNode tree)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(tree != <span class="hljs-keyword">null</span>) &#123;<br>inOrder(tree.left);<br>System.out.print(tree.key+<span class="hljs-string">" "</span>);<br>inOrder(tree.right);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">()</span> </span>&#123;<br>inOrder(mRoot);<br>&#125;<br><br><br><span class="hljs-comment">/*<br> * 后序遍历"Huffman树"<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(HuffmanNode tree)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(tree != <span class="hljs-keyword">null</span>)<br>&#123;<br>postOrder(tree.left);<br>postOrder(tree.right);<br>System.out.print(tree.key+<span class="hljs-string">" "</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">()</span> </span>&#123;<br>postOrder(mRoot);<br>&#125;<br><br><span class="hljs-comment">/*<br> * 销毁Huffman树<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(HuffmanNode tree)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (tree==<span class="hljs-keyword">null</span>)<br><span class="hljs-keyword">return</span> ;<br><br><span class="hljs-keyword">if</span> (tree.left != <span class="hljs-keyword">null</span>)<br>destroy(tree.left);<br><span class="hljs-keyword">if</span> (tree.right != <span class="hljs-keyword">null</span>)<br>destroy(tree.right);<br><br>tree=<span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>destroy(mRoot);<br>mRoot = <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-comment">/*<br> * 打印"Huffman树"<br> *<br> * key        -- 节点的键值 <br> * direction  --  0，表示该节点是根节点;<br> *               -1，表示该节点是它的父结点的左孩子;<br> *                1，表示该节点是它的父结点的右孩子。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(HuffmanNode tree, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> direction)</span> </span>&#123;<br><br><span class="hljs-keyword">if</span>(tree != <span class="hljs-keyword">null</span>) &#123;<br><br><span class="hljs-keyword">if</span>(direction==<span class="hljs-number">0</span>)<span class="hljs-comment">// tree是根节点</span><br>System.out.printf(<span class="hljs-string">"%2d is root\n"</span>, tree.key);<br><span class="hljs-keyword">else</span><span class="hljs-comment">// tree是分支节点</span><br>System.out.printf(<span class="hljs-string">"%2d is %2d's %6s child\n"</span>, tree.key, key, direction==<span class="hljs-number">1</span>?<span class="hljs-string">"right"</span> : <span class="hljs-string">"left"</span>);<br><br>print(tree.left, tree.key, -<span class="hljs-number">1</span>);<br>print(tree.right,tree.key,  <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (mRoot != <span class="hljs-keyword">null</span>)<br>print(mRoot, mRoot.key, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>首先创建最小堆，然后进入for循环。</p><p>每次循环时：</p><blockquote><p>(01) 首先，将最小堆中的最小节点拷贝一份并赋值给left，然后重塑最小堆(将最小节点和后面的节点交换位置，接着将”交换位置后的最小节点”之前的全部元素重新构造成最小堆)；<br>(02) 接着，再将最小堆中的最小节点拷贝一份并将其赋值right，然后再次重塑最小堆；<br>(03) 然后，新建节点parent，并将它作为left和right的父节点；<br>(04) 接着，将parent的数据复制给最小堆中的指定节点。</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * 最小堆(Huffman.java的辅助类)<br> */</span><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHeap</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> List&lt;HuffmanNode&gt; mHeap;<span class="hljs-comment">// 存放堆的数组</span><br><br><span class="hljs-comment">/* <br> * 创建最小堆<br> *<br> * 参数说明：<br> *     a -- 数据所在的数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MinHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[])</span> </span>&#123;<br>mHeap = <span class="hljs-keyword">new</span> ArrayList&lt;HuffmanNode&gt;();<br><span class="hljs-comment">// 初始化数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>    HuffmanNode node = <span class="hljs-keyword">new</span> HuffmanNode(a[i], <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>mHeap.add(node);<br>&#125;<br><br><span class="hljs-comment">// 从(size/2-1) --&gt; 0逐次遍历。遍历之后，得到的数组实际上是一个最小堆。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>filterdown(i, a.length-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/* <br> * 最小堆的向下调整算法<br> *<br> * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。<br> *<br> * 参数说明：<br> *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)<br> *     end   -- 截至范围(一般为数组中最后一个元素的索引)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br><span class="hljs-keyword">int</span> c = start;  <span class="hljs-comment">// 当前(current)节点的位置</span><br><span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>*c + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左(left)孩子的位置</span><br>HuffmanNode tmp = mHeap.get(c);<span class="hljs-comment">// 当前(current)节点</span><br><br><span class="hljs-keyword">while</span>(l &lt;= end) &#123;<br><span class="hljs-comment">// "l"是左孩子，"l+1"是右孩子</span><br><span class="hljs-keyword">if</span>(l &lt; end &amp;&amp; (mHeap.get(l).compareTo(mHeap.get(l+<span class="hljs-number">1</span>))&gt;<span class="hljs-number">0</span>))<br>l++;<span class="hljs-comment">// 左右两孩子中选择较小者，即mHeap[l+1]</span><br><br><span class="hljs-keyword">int</span> cmp = tmp.compareTo(mHeap.get(l));<br><span class="hljs-keyword">if</span>(cmp &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//调整结束</span><br><span class="hljs-keyword">else</span> &#123;<br>mHeap.set(c, mHeap.get(l));<br>c = l;<br>l = <span class="hljs-number">2</span>*l + <span class="hljs-number">1</span>;   <br>&#125;       <br>&#125;   <br>mHeap.set(c, tmp);<br>&#125;<br><br><span class="hljs-comment">/*<br> * 最小堆的向上调整算法(从start开始向上直到0，调整堆)<br> *<br> * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。<br> *<br> * 参数说明：<br> *     start -- 被上调节点的起始位置(一般为数组中最后一个元素的索引)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br><span class="hljs-keyword">int</span> c = start;<span class="hljs-comment">// 当前节点(current)的位置</span><br><span class="hljs-keyword">int</span> p = (c-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-comment">// 父(parent)结点的位置 </span><br>HuffmanNode tmp = mHeap.get(c);<span class="hljs-comment">// 当前(current)节点</span><br><br><span class="hljs-keyword">while</span>(c &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">int</span> cmp = mHeap.get(p).compareTo(tmp);<br><span class="hljs-keyword">if</span>(cmp &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">else</span> &#123;<br>mHeap.set(c, mHeap.get(p));<br>c = p;<br>p = (p-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;   <br>&#125;       <br>&#125;<br>mHeap.set(c, tmp);<br>&#125; <br> <br><span class="hljs-comment">/* <br> * 将node插入到二叉堆中<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(HuffmanNode node)</span> </span>&#123;<br><span class="hljs-keyword">int</span> size = mHeap.size();<br><br>mHeap.add(node);<span class="hljs-comment">// 将"数组"插在表尾</span><br>filterup(size);<span class="hljs-comment">// 向上调整堆</span><br>&#125;<br><br><span class="hljs-comment">/*<br> * 交换两个HuffmanNode节点的全部数据<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swapNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>HuffmanNode tmp = mHeap.get(i);<br>mHeap.set(i, mHeap.get(j));<br>mHeap.set(j, tmp);<br>&#125;<br><br><span class="hljs-comment">/* <br> * 新建一个节点，并将最小堆中最小节点的数据复制给该节点。<br> * 然后除最小节点之外的数据重新构造成最小堆。<br> *<br> * 返回值：<br> *     失败返回null。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> HuffmanNode <span class="hljs-title">dumpFromMinimum</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> size = mHeap.size();<br><br><span class="hljs-comment">// 如果"堆"已空，则返回</span><br><span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br><span class="hljs-comment">// 将"最小节点"克隆一份，将克隆得到的对象赋值给node</span><br>HuffmanNode node = (HuffmanNode)mHeap.get(<span class="hljs-number">0</span>).clone();<br><br><span class="hljs-comment">// 交换"最小节点"和"最后一个节点"</span><br>mHeap.set(<span class="hljs-number">0</span>, mHeap.get(size-<span class="hljs-number">1</span>));<br><span class="hljs-comment">// 删除最后的元素</span><br>mHeap.remove(size-<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">if</span> (mHeap.size() &gt; <span class="hljs-number">1</span>)<br>filterdown(<span class="hljs-number">0</span>, mHeap.size()-<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">// 销毁最小堆</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>mHeap.clear();<br>mHeap = <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * Huffman树的测试程序<br> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuffmanTest</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a[]= &#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">15</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i;<br>Huffman tree;<br><br>System.out.print(<span class="hljs-string">"== 添加数组: "</span>);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;a.length; i++) <br>System.out.print(a[i]+<span class="hljs-string">" "</span>);<br><br><span class="hljs-comment">// 创建数组a对应的Huffman树</span><br>tree = <span class="hljs-keyword">new</span> Huffman(a);<br><br>System.out.print(<span class="hljs-string">"\n== 前序遍历: "</span>);<br>tree.preOrder();<br><br>System.out.print(<span class="hljs-string">"\n== 中序遍历: "</span>);<br>tree.inOrder();<br><br>System.out.print(<span class="hljs-string">"\n== 后序遍历: "</span>);<br>tree.postOrder();<br>System.out.println();<br><br>System.out.println(<span class="hljs-string">"== 树的详细信息: "</span>);<br>tree.print();<br><br><span class="hljs-comment">// 销毁二叉树</span><br>tree.destroy();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.2.2.红黑树</title>
      <link href="/2021/11/17/5.2.2.%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2021/11/17/5.2.2.%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>红黑树是平衡二叉树的一种，它保证在最坏情况下基本动态集合操作的==<strong>事件复杂度为O(log n)</strong>==。时间复杂度证明：<a href="https://www.cnblogs.com/skywang12345/p/3245399.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3245399.html</a></p><p>(1) 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入<strong>最多只需要三次旋转</strong>就能达到平衡，实现起来也更为简单。</p><p>(2) 平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。</p><p>红黑树和平衡二叉树区别如下：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlhlzai1oj315h0u043d.jpg" alt="image-20211120120927328"></p><h2 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2 特性"></a>1.2 特性</h2><p>==<strong>红黑树具有五个特性：</strong>==</p><ol><li>==<strong>每个结点要么是红的要么是黑的。</strong>==</li><li>==<strong>根结点是黑的。</strong>==</li><li>==<strong>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。</strong>==</li><li>==<strong>如果一个结点是红的，那么它的两个儿子都是黑的。</strong>==</li><li>==<strong>对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。</strong>==</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlhl6dzddj31i90u0q5x.jpg" alt="image-20211120120840570"></p><p>红黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只要求达到部分平衡。这是一种折中的方案，大大提高了结点删除和插入的效率。C++中的STL就常用到红黑树作为底层的数据结构。</p><p>红黑树应用：例如，Java集合中的<a href="http://www.cnblogs.com/skywang12345/p/3311268.html" target="_blank" rel="noopener">TreeSet</a>和<a href="http://www.cnblogs.com/skywang12345/p/3310928.html" target="_blank" rel="noopener">TreeMap</a>，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p><h2 id="1-3-红黑树的基本操作"><a href="#1-3-红黑树的基本操作" class="headerlink" title="1.3 红黑树的基本操作"></a>1.3 红黑树的基本操作</h2><h3 id="1-3-1-添加"><a href="#1-3-1-添加" class="headerlink" title="1.3.1 添加"></a>1.3.1 添加</h3><p>将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下：</p><p><strong>第一步: 将红黑树当作一颗二叉查找树，将节点插入。</strong><br>红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。<br>好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！</p><p><strong>第二步：将插入的节点着色为”红色”。</strong><br>为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：<br>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。<br>将插入的节点着色为红色，不会违背”特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。</p><p><strong>第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。</strong><br>第二步中，将插入节点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？<br>对于”特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。<br>对于”特性(2)”，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。<br>对于”特性(3)”，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。<br>对于”特性(4)”，是有可能违背的！<br>那接下来，想办法使之”满足特性(4)”，就可以将树重新构造成红黑树了。</p><ol><li><strong>添加操作的伪代码《算法导论》</strong></li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">RB-INSERT(T, z)  <br><span class="hljs-number">01</span>  y ← nil[T]                        <span class="hljs-comment">// 新建节点“y”，将y设为空节点。</span><br><span class="hljs-number">02</span>  x ← root[T]                       <span class="hljs-comment">// 设“红黑树T”的根节点为“x”</span><br><span class="hljs-number">03</span>  <span class="hljs-keyword">while</span> x ≠ nil[T]                  <span class="hljs-comment">// 找出要插入的节点“z”在二叉树T中的位置“y”</span><br><span class="hljs-number">04</span>      <span class="hljs-keyword">do</span> y ← x                      <br><span class="hljs-number">05</span>         <span class="hljs-keyword">if</span> key[z] &lt; key[x]  <br><span class="hljs-number">06</span>            then x ← left[x]  <br><span class="hljs-number">07</span>            <span class="hljs-keyword">else</span> x ← right[x]  <br><span class="hljs-number">08</span>  p[z] ← y                          <span class="hljs-comment">// 设置 “z的父亲” 为 “y”</span><br><span class="hljs-number">09</span>  <span class="hljs-keyword">if</span> y = nil[T]                     <br><span class="hljs-number">10</span>     then root[T] ← z               <span class="hljs-comment">// 情况1：若y是空节点，则将z设为根</span><br><span class="hljs-number">11</span>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> key[z] &lt; key[y]        <br><span class="hljs-number">12</span>             then left[y] ← z       <span class="hljs-comment">// 情况2：若“z所包含的值” &lt; “y所包含的值”，则将z设为“y的左孩子”</span><br><span class="hljs-number">13</span>             <span class="hljs-keyword">else</span> right[y] ← z      <span class="hljs-comment">// 情况3：(“z所包含的值” &gt;= “y所包含的值”)将z设为“y的右孩子” </span><br><span class="hljs-number">14</span>  left[z] ← nil[T]                  <span class="hljs-comment">// z的左孩子设为空</span><br><span class="hljs-number">15</span>  right[z] ← nil[T]                 <span class="hljs-comment">// z的右孩子设为空。至此，已经完成将“节点z插入到二叉树”中了。</span><br><span class="hljs-number">16</span>  color[z] ← RED                    <span class="hljs-comment">// 将z着色为“红色”</span><br><span class="hljs-number">17</span>  RB-INSERT-FIXUP(T, z)             <span class="hljs-comment">// 通过RB-INSERT-FIXUP对红黑树的节点进行颜色修改以及旋转，让树T仍然是一颗红黑树</span><br></code></pre></td></tr></table></figure><p>结合伪代码以及为代码上面的说明，先理解RB-INSERT。理解了RB-INSERT之后，我们接着对 RB-INSERT-FIXUP的伪代码进行说明。</p><ol start="2"><li><strong>添加修正操作的伪代码《算法导论》</strong></li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">RB-INSERT-FIXUP(T, z)<br><span class="hljs-number">01</span> <span class="hljs-keyword">while</span> color[p[z]] = RED                                                  <span class="hljs-comment">// 若“当前节点(z)的父节点是红色”，则进行以下处理。</span><br><span class="hljs-number">02</span>     <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> p[z] = left[p[p[z]]]                                           <span class="hljs-comment">// 若“z的父节点”是“z的祖父节点的左孩子”，则进行以下处理。</span><br><span class="hljs-number">03</span>           then y ← right[p[p[z]]]                                        <span class="hljs-comment">// 将y设置为“z的叔叔节点(z的祖父节点的右孩子)”</span><br><span class="hljs-number">04</span>                <span class="hljs-keyword">if</span> color[y] = RED                                         <span class="hljs-comment">// Case 1条件：叔叔是红色</span><br><span class="hljs-number">05</span>                   then color[p[z]] ← BLACK                    ▹ Case <span class="hljs-number">1</span>   <span class="hljs-comment">//  (01) 将“父节点”设为黑色。</span><br><span class="hljs-number">06</span>                        color[y] ← BLACK                       ▹ Case <span class="hljs-number">1</span>   <span class="hljs-comment">//  (02) 将“叔叔节点”设为黑色。</span><br><span class="hljs-number">07</span>                        color[p[p[z]]] ← RED                   ▹ Case <span class="hljs-number">1</span>   <span class="hljs-comment">//  (03) 将“祖父节点”设为“红色”。</span><br><span class="hljs-number">08</span>                        z ← p[p[z]]                            ▹ Case <span class="hljs-number">1</span>   <span class="hljs-comment">//  (04) 将“祖父节点”设为“当前节点”(红色节点)</span><br><span class="hljs-number">09</span>                   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> z = right[p[z]]                                <span class="hljs-comment">// Case 2条件：叔叔是黑色，且当前节点是右孩子</span><br><span class="hljs-number">10</span>                           then z ← p[z]                       ▹ Case <span class="hljs-number">2</span>   <span class="hljs-comment">//  (01) 将“父节点”作为“新的当前节点”。</span><br><span class="hljs-number">11</span>                                LEFT-ROTATE(T, z)              ▹ Case <span class="hljs-number">2</span>   <span class="hljs-comment">//  (02) 以“新的当前节点”为支点进行左旋。</span><br><span class="hljs-number">12</span>                           color[p[z]] ← BLACK                 ▹ Case <span class="hljs-number">3</span>   <span class="hljs-comment">// Case 3条件：叔叔是黑色，且当前节点是左孩子。(01) 将“父节点”设为“黑色”。</span><br><span class="hljs-number">13</span>                           color[p[p[z]]] ← RED                ▹ Case <span class="hljs-number">3</span>   <span class="hljs-comment">//  (02) 将“祖父节点”设为“红色”。</span><br><span class="hljs-number">14</span>                           RIGHT-ROTATE(T, p[p[z]])            ▹ Case <span class="hljs-number">3</span>   <span class="hljs-comment">//  (03) 以“祖父节点”为支点进行右旋。</span><br><span class="hljs-number">15</span>        <span class="hljs-keyword">else</span> (same as then clause with <span class="hljs-string">"right"</span> <span class="hljs-keyword">and</span> <span class="hljs-string">"left"</span> exchanged)      <span class="hljs-comment">// 若“z的父节点”是“z的祖父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。</span><br><span class="hljs-number">16</span> color[root[T]] ← BLACK<br></code></pre></td></tr></table></figure><p>根据被插入节点的父节点的情况，可以将”当节点z被着色为红色节点，并插入二叉树”划分为三种情况来处理。</p><h4 id="1-3-1-1-情况说明：被插入的节点是根节点。"><a href="#1-3-1-1-情况说明：被插入的节点是根节点。" class="headerlink" title="1.3.1.1. 情况说明：被插入的节点是根节点。"></a>1.3.1.1. <strong>情况说明：被插入的节点是根节点。</strong></h4><p>  处理方法：直接把此节点涂为黑色。</p><h4 id="1-3-1-2-情况说明：被插入的节点的父节点是黑色。"><a href="#1-3-1-2-情况说明：被插入的节点的父节点是黑色。" class="headerlink" title="1.3.1.2. 情况说明：被插入的节点的父节点是黑色。"></a>1.3.1.2. <strong>情况说明：被插入的节点的父节点是黑色。</strong></h4><p>  处理方法：什么也不需要做。节点被插入后，仍然是红黑树。</p><h4 id="1-3-1-3-情况说明：被插入的节点的父节点是红色。"><a href="#1-3-1-3-情况说明：被插入的节点的父节点是红色。" class="headerlink" title="1.3.1.3.情况说明：被插入的节点的父节点是红色。"></a>1.3.1.3.<strong>情况说明：被插入的节点的父节点是红色。</strong></h4><p>  处理方法：那么，该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据”叔叔节点的情况”，将这种情况进一步划分为3种情况(Case)。</p><table><thead><tr><th></th><th><strong>现象说明</strong></th><th><strong>处理策略</strong></th></tr></thead><tbody><tr><td>Case 1</td><td>当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</td><td>(01) 将“父节点”设为黑色。 (02) 将“叔叔节点”设为黑色。 (03) 将“祖父节点”设为“红色”。 (04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作, 即迭代。</td></tr><tr><td>Case 2</td><td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</td><td>(01) 将“父节点”作为“新的当前节点”。 (02) 以“新的当前节点”为支点进行左旋。</td></tr><tr><td>Case 3</td><td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</td><td>(01) 将“父节点”设为“黑色”。 (02) 将“祖父节点”设为“红色”。 (03) 以“祖父节点”为支点进行右旋。</td></tr></tbody></table><p>上面三种情况(Case)处理问题的核心思路都是：<strong>==将红色的节点移到根节点；然后，将根节点设为黑色==</strong>。下面对它们详细进行介绍。</p><h5 id="Case-1-叔叔是红色"><a href="#Case-1-叔叔是红色" class="headerlink" title="(Case 1)叔叔是红色"></a>(Case 1)叔叔是红色</h5><h6 id="Case1-1-现象说明"><a href="#Case1-1-现象说明" class="headerlink" title="Case1.1 现象说明"></a>Case<strong>1.1 现象说明</strong></h6><p>当前节点(即，被插入节点)的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。(插入35)</p><h6 id="Case1-2-处理策略"><a href="#Case1-2-处理策略" class="headerlink" title="Case1.2 处理策略"></a>Case<strong>1.2 处理策略</strong></h6><p>(01) 将“父节点”设为黑色。<br>(02) 将“叔叔节点”设为黑色。<br>(03) 将“祖父节点”设为“红色”。<br>(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</p><p>  <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>  “当前节点”和“父节点”都是红色，违背“特性(4)”。所以，将“父节点”设置“黑色”以解决这个问题。<br>  但是，将“父节点”由“红色”变成“黑色”之后，违背了“特性(5)”：因为，包含“父节点”的分支的黑色节点的总数增加了1。  解决这个问题的办法是：将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”。关于这里，说明几点：第一，为什么“祖父节点”之前是黑色？这个应该很容易想明白，因为在变换操作之前，该树是红黑树，“父节点”是红色，那么“祖父节点”一定是黑色。 第二，为什么将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；能解决“包含‘父节点’的分支的黑色节点的总数增加了1”的问题。这个道理也很简单。“包含‘父节点’的分支的黑色节点的总数增加了1” 同时也意味着 “包含‘祖父节点’的分支的黑色节点的总数增加了1”，既然这样，我们通过将“祖父节点”由“黑色”变成“红色”以解决“包含‘祖父节点’的分支的黑色节点的总数增加了1”的问题； 但是，这样处理之后又会引起另一个问题“包含‘叔叔’节点的分支的黑色节点的总数减少了1”，现在我们已知“叔叔节点”是“红色”，将“叔叔节点”设为“黑色”就能解决这个问题。 所以，将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；就解决了该问题。<br>  按照上面的步骤处理之后：当前节点、父节点、叔叔节点之间都不会违背红黑树特性，但祖父节点却不一定。若此时，祖父节点是根节点，直接将祖父节点设为“黑色”，那就完全解决这个问题了；若祖父节点不是根节点，那我们需要将“祖父节点”设为“新的当前节点”，接着对“新的当前节点”进行分析。</p><h6 id="Case1-3-示意图"><a href="#Case1-3-示意图" class="headerlink" title="Case1.3 示意图"></a>Case<strong>1.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251759273578917.jpg" target="_blank" rel="noopener"><strong><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljntndr2j318o0eitak.jpg" alt="img"></strong></a></p><h5 id="Case-2-叔叔是黑色，且当前节点是右孩子"><a href="#Case-2-叔叔是黑色，且当前节点是右孩子" class="headerlink" title="(Case 2)叔叔是黑色，且当前节点是右孩子"></a>(Case 2)叔叔是黑色，且当前节点是右孩子</h5><h6 id="Case2-1-现象说明"><a href="#Case2-1-现象说明" class="headerlink" title="Case2.1 现象说明"></a>Case<strong>2.1 现象说明</strong></h6><p>当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子。(插入70，图有错误)</p><h6 id="Case2-2-处理策略"><a href="#Case2-2-处理策略" class="headerlink" title="Case2.2 处理策略"></a>Case<strong>2.2 处理策略</strong></h6><p>(01) 将“父节点”作为“新的当前节点”。<br>(02) 以“新的当前节点”为支点进行左旋。</p><p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   首先，将“父节点”作为“新的当前节点”；接着，以“新的当前节点”为支点进行左旋。 为了便于理解，我们先说明第(02)步，再说明第(01)步；为了便于说明，我们设置“父节点”的代号为F(Father)，“当前节点”的代号为S(Son)。<br>为什么要“以F为支点进行左旋”呢？根据已知条件可知：S是F的右孩子。而之前我们说过，我们处理红黑树的核心思想：将红色的节点移到根节点；然后，将根节点设为黑色。既然是“将红色的节点移到根节点”，那就是说要不断的将破坏红黑树特性的红色节点上移(即向根方向移动)。 而S又是一个右孩子，因此，我们可以通过“左旋”来将S上移！<br>   按照上面的步骤(以F为支点进行左旋)处理之后：若S变成了根节点，那么直接将其设为“黑色”，就完全解决问题了；若S不是根节点，那我们需要执行步骤(01)，即“将F设为‘新的当前节点’”。那为什么不继续以S为新的当前节点继续处理，而需要以F为新的当前节点来进行处理呢？这是因为“左旋”之后，F变成了S的“子节点”，即S变成了F的父节点；而我们处理问题的时候，需要从下至上(由叶到根)方向进行处理；也就是说，必须先解决“孩子”的问题，再解决“父亲”的问题；所以，我们执行步骤(01)：将“父节点”作为“新的当前节点”。</p><h6 id="Case2-3-示意图"><a href="#Case2-3-示意图" class="headerlink" title="Case2.3 示意图"></a>Case<strong>2.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251801031546918.jpg" target="_blank" rel="noopener"><strong><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljo7qeefj31a90e30uk.jpg" alt="img"></strong></a></p><h5 id="Case-3-叔叔是黑色，且当前节点是左孩子"><a href="#Case-3-叔叔是黑色，且当前节点是左孩子" class="headerlink" title="(Case 3)叔叔是黑色，且当前节点是左孩子"></a>(Case 3)叔叔是黑色，且当前节点是左孩子</h5><h6 id="Case3-1-现象说明"><a href="#Case3-1-现象说明" class="headerlink" title="Case3.1 现象说明"></a><strong>Case3.1 现象说明</strong></h6><p>当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子。(插入40)</p><h6 id="Case3-2-处理策略"><a href="#Case3-2-处理策略" class="headerlink" title="Case3.2 处理策略"></a>Case<strong>3.2 处理策略</strong></h6><p>(01) 将“父节点”设为“黑色”。<br>(02) 将“祖父节点”设为“红色”。<br>(03) 以“祖父节点”为支点进行右旋。</p><p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“叔叔节点”为U(Uncle)，“父节点”为F(Father)，祖父节点为G(Grand-Father)。<br>   S和F都是红色，违背了红黑树的“特性(4)”，我们可以将F由“红色”变为“黑色”，就解决了“违背‘特性(4)’”的问题；但却引起了其它问题：违背特性(5)，因为将F由红色改为黑色之后，所有经过F的分支的黑色节点的个数增加了1。那我们如何解决“所有经过F的分支的黑色节点的个数增加了1”的问题呢？ 我们可以通过“将G由黑色变成红色”，同时“以G为支点进行右旋”来解决。</p><h6 id="Case3-3-示意图"><a href="#Case3-3-示意图" class="headerlink" title="Case3.3 示意图"></a>Case<strong>3.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201404/170945094945387.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljofpukej31a80e2dhp.jpg" alt="img"></a></p><p>提示：上面的进行Case 3处理之后，再将节点”120”当作当前节点，就变成了Case 2的情况。</p><h3 id="1-3-2-删除"><a href="#1-3-2-删除" class="headerlink" title="1.3.2 删除"></a>1.3.2 删除</h3><p>将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：</p><p><strong>第一步：将红黑树当作一颗二叉查找树，将节点删除。</strong><br>    这和”删除常规二叉查找树中删除节点的方法是一样的”。分3种情况：<br>    ① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。<br>    ② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。<br>    ③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了，下面就考虑后继节点。 在”被删除节点”有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然”的后继节点”不可能双子都非空，就意味着”该节点的后继节点”要么没有儿子，要么只有一个儿子。若没有儿子，则按”情况① “进行处理；若只有一个儿子，则按”情况② “进行处理。</p><p><strong>第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</strong><br>    因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p><p><strong>删除操作的伪代码《算法导论》</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">RB</span>-<span class="hljs-type">DELETE</span>(<span class="hljs-type">T</span>, z)<br><span class="hljs-number">01</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">left</span>[z] = <span class="hljs-literal">nil</span>[<span class="hljs-type">T</span>] or <span class="hljs-keyword">right</span>[z] = <span class="hljs-literal">nil</span>[<span class="hljs-type">T</span>]         <br><span class="hljs-number">02</span>    then y ← z                                  <span class="hljs-comment">// 若“z的左孩子” 或 “z的右孩子”为空，则将“z”赋值给 “y”；</span><br><span class="hljs-number">03</span>    <span class="hljs-keyword">else</span> y ← <span class="hljs-type">TREE</span>-<span class="hljs-type">SUCCESSOR</span>(z)                  <span class="hljs-comment">// 否则，将“z的后继节点”赋值给 “y”。</span><br><span class="hljs-number">04</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">left</span>[y] ≠ <span class="hljs-literal">nil</span>[<span class="hljs-type">T</span>]<br><span class="hljs-number">05</span>    then x ← <span class="hljs-keyword">left</span>[y]                            <span class="hljs-comment">// 若“y的左孩子” 不为空，则将“y的左孩子” 赋值给 “x”；</span><br><span class="hljs-number">06</span>    <span class="hljs-keyword">else</span> x ← <span class="hljs-keyword">right</span>[y]                           <span class="hljs-comment">// 否则，“y的右孩子” 赋值给 “x”。</span><br><span class="hljs-number">07</span> p[x] ← p[y]                                    <span class="hljs-comment">// 将“y的父节点” 设置为 “x的父节点”</span><br><span class="hljs-number">08</span> <span class="hljs-keyword">if</span> p[y] = <span class="hljs-literal">nil</span>[<span class="hljs-type">T</span>]                               <br><span class="hljs-number">09</span>    then root[<span class="hljs-type">T</span>] ← x                            <span class="hljs-comment">// 情况1：若“y的父节点” 为空，则设置“x” 为 “根节点”。</span><br><span class="hljs-number">10</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> y = <span class="hljs-keyword">left</span>[p[y]]                    <br><span class="hljs-number">11</span>            then <span class="hljs-keyword">left</span>[p[y]] ← x                 <span class="hljs-comment">// 情况2：若“y是它父节点的左孩子”，则设置“x” 为 “y的父节点的左孩子”</span><br><span class="hljs-number">12</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">right</span>[p[y]] ← x                <span class="hljs-comment">// 情况3：若“y是它父节点的右孩子”，则设置“x” 为 “y的父节点的右孩子”</span><br><span class="hljs-number">13</span> <span class="hljs-keyword">if</span> y ≠ z                                    <br><span class="hljs-number">14</span>    then key[z] ← key[y]                        <span class="hljs-comment">// 若“y的值” 赋值给 “z”。注意：这里只拷贝z的值给y，而没有拷贝z的颜色！！！</span><br><span class="hljs-number">15</span>         copy y's satellite data into z         <br><span class="hljs-number">16</span> <span class="hljs-keyword">if</span> color[y] = <span class="hljs-type">BLACK</span>                            <br><span class="hljs-number">17</span>    then <span class="hljs-type">RB</span>-<span class="hljs-type">DELETE</span>-<span class="hljs-type">FIXUP</span>(<span class="hljs-type">T</span>, x)                  <span class="hljs-comment">// 若“y为黑节点”，则调用</span><br><span class="hljs-number">18</span> <span class="hljs-keyword">return</span> y<br></code></pre></td></tr></table></figure><p>结合伪代码以及为代码上面的说明，先理解RB-DELETE。理解了RB-DELETE之后，接着对 RB-DELETE-FIXUP的伪代码进行说明</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">RB-DELETE-FIXUP(T, x)<br><span class="hljs-number">01</span> <span class="hljs-keyword">while</span> x ≠ root[T] <span class="hljs-keyword">and</span> color[x] = BLACK  <br><span class="hljs-number">02</span>     <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> x = left[p[x]]      <br><span class="hljs-number">03</span>           then w ← right[p[x]]                                             <span class="hljs-comment">// 若 “x”是“它父节点的左孩子”，则设置 “w”为“x的叔叔”(即x为它父节点的右孩子)                                          </span><br><span class="hljs-number">04</span>                <span class="hljs-keyword">if</span> color[w] = RED                                           <span class="hljs-comment">// Case 1: x是“黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</span><br><span class="hljs-number">05</span>                   then color[w] ← BLACK                        ▹  Case <span class="hljs-number">1</span>   <span class="hljs-comment">//   (01) 将x的兄弟节点设为“黑色”。</span><br><span class="hljs-number">06</span>                        color[p[x]] ← RED                       ▹  Case <span class="hljs-number">1</span>   <span class="hljs-comment">//   (02) 将x的父节点设为“红色”。</span><br><span class="hljs-number">07</span>                        LEFT-ROTATE(T, p[x])                    ▹  Case <span class="hljs-number">1</span>   <span class="hljs-comment">//   (03) 对x的父节点进行左旋。</span><br><span class="hljs-number">08</span>                        w ← right[p[x]]                         ▹  Case <span class="hljs-number">1</span>   <span class="hljs-comment">//   (04) 左旋后，重新设置x的兄弟节点。</span><br><span class="hljs-number">09</span>                <span class="hljs-keyword">if</span> color[left[w]] = BLACK <span class="hljs-keyword">and</span> color[right[w]] = BLACK       <span class="hljs-comment">// Case 2: x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</span><br><span class="hljs-number">10</span>                   then color[w] ← RED                          ▹  Case <span class="hljs-number">2</span>   <span class="hljs-comment">//   (01) 将x的兄弟节点设为“红色”。</span><br><span class="hljs-number">11</span>                        x ←  p[x]                               ▹  Case <span class="hljs-number">2</span>   <span class="hljs-comment">//   (02) 设置“x的父节点”为“新的x节点”。</span><br><span class="hljs-number">12</span>                   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> color[right[w]] = BLACK                          <span class="hljs-comment">// Case 3: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</span><br><span class="hljs-number">13</span>                           then color[left[w]] ← BLACK          ▹  Case <span class="hljs-number">3</span>   <span class="hljs-comment">//   (01) 将x兄弟节点的左孩子设为“黑色”。</span><br><span class="hljs-number">14</span>                                color[w] ← RED                  ▹  Case <span class="hljs-number">3</span>   <span class="hljs-comment">//   (02) 将x兄弟节点设为“红色”。</span><br><span class="hljs-number">15</span>                                RIGHT-ROTATE(T, w)              ▹  Case <span class="hljs-number">3</span>   <span class="hljs-comment">//   (03) 对x的兄弟节点进行右旋。</span><br><span class="hljs-number">16</span>                                w ← right[p[x]]                 ▹  Case <span class="hljs-number">3</span>   <span class="hljs-comment">//   (04) 右旋后，重新设置x的兄弟节点。</span><br><span class="hljs-number">17</span>                         color[w] ← color[p[x]]                 ▹  Case <span class="hljs-number">4</span>   <span class="hljs-comment">// Case 4: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的。(01) 将x父节点颜色 赋值给 x的兄弟节点。</span><br><span class="hljs-number">18</span>                         color[p[x]] ← BLACK                    ▹  Case <span class="hljs-number">4</span>   <span class="hljs-comment">//   (02) 将x父节点设为“黑色”。</span><br><span class="hljs-number">19</span>                         color[right[w]] ← BLACK                ▹  Case <span class="hljs-number">4</span>   <span class="hljs-comment">//   (03) 将x兄弟节点的右子节设为“黑色”。</span><br><span class="hljs-number">20</span>                         LEFT-ROTATE(T, p[x])                   ▹  Case <span class="hljs-number">4</span>   <span class="hljs-comment">//   (04) 对x的父节点进行左旋。</span><br><span class="hljs-number">21</span>                         x ← root[T]                            ▹  Case <span class="hljs-number">4</span>   <span class="hljs-comment">//   (05) 设置“x”为“根节点”。</span><br><span class="hljs-number">22</span>        <span class="hljs-keyword">else</span> (same as then clause with <span class="hljs-string">"right"</span> <span class="hljs-keyword">and</span> <span class="hljs-string">"left"</span> exchanged)        <span class="hljs-comment">// 若 “x”是“它父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。</span><br><span class="hljs-number">23</span> color[x] ← BLACK<br></code></pre></td></tr></table></figure><p>下面对删除函数进行分析。在分析之前，我们再次温习一下红黑树的几个特性：<br>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p><p>前面我们将”删除红黑树中的节点”大致分为两步，在第一步中”将红黑树当作一颗二叉查找树，将节点删除”后，可能违反”特性(2)、(4)、(5)”三个特性。第二步需要解决上面的三个问题，进而保持红黑树的全部特性。<br>为了便于分析，我们假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。为什么呢？<br>通过RB-DELETE算法，我们知道：删除节点y之后，x占据了原来节点y的位置。 既然删除y(y是黑色)，意味着减少一个黑色节点；那么，再在该位置上增加一个黑色即可。这样，当我们假设”x包含一个额外的黑色”，就正好弥补了”删除y所丢失的黑色节点”，也就不会违反”特性(5)”。 因此，假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。<br>现在，x不仅包含它原本的颜色属性，x还包含一个额外的黑色。即x的颜色属性是”红+黑”或”黑+黑”，它违反了”特性(1)”。</p><p>现在，我们面临的问题，由解决”违反了特性(2)、(4)、(5)三个特性”转换成了”解决违反特性(1)、(2)、(4)三个特性”。RB-DELETE-FIXUP需要做的就是通过算法恢复红黑树的特性(1)、(2)、(4)。RB-DELETE-FIXUP的思想是：将x所包含的额外的黑色不断沿树上移(向根方向移动)，直到出现下面的姿态：<br>a) x指向一个”红+黑”节点。此时，将x设为一个”黑”节点即可。<br>b) x指向根。此时，将x设为一个”黑”节点即可。<br>c) 非前面两种姿态。</p><p>将上面的姿态，可以概括为3种情况。</p><h4 id="1-3-2-1-情况说明：x是“红-黑”节点。"><a href="#1-3-2-1-情况说明：x是“红-黑”节点。" class="headerlink" title="1.3.2.1.情况说明：x是“红+黑”节点。"></a>1.3.2.1.情况说明：x是“红+黑”节点。</h4><p>  处理方法：直接把x设为黑色，结束。此时红黑树性质全部恢复。</p><h4 id="1-3-2-2-情况说明：x是“黑-黑”节点，且x是根。"><a href="#1-3-2-2-情况说明：x是“黑-黑”节点，且x是根。" class="headerlink" title="1.3.2.2.情况说明：x是“黑+黑”节点，且x是根。"></a>1.3.2.2.情况说明：x是“黑+黑”节点，且x是根。</h4><p>  处理方法：什么都不做，结束。此时红黑树性质全部恢复。</p><h4 id="1-3-2-3-情况说明：x是“黑-黑”节点，且x不是根。"><a href="#1-3-2-3-情况说明：x是“黑-黑”节点，且x不是根。" class="headerlink" title="1.3.2.3.情况说明：x是“黑+黑”节点，且x不是根。"></a>1.3.2.3.情况说明：x是“黑+黑”节点，且x不是根。</h4><p>  处理方法：这种情况又可以划分为4种子情况。这4种子情况如下表所示：</p><table><thead><tr><th></th><th><strong>现象说明</strong></th><th><strong>处理策略</strong></th></tr></thead><tbody><tr><td><strong>Case 1</strong></td><td>x是”黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</td><td>(01) 将x的兄弟节点设为“黑色”。 (02) 将x的父节点设为“红色”。 (03) 对x的父节点进行左旋。 (04) 左旋后，重新设置x的兄弟节点。</td></tr><tr><td><strong>Case 2</strong></td><td>x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</td><td>(01) 将x的兄弟节点设为“红色”。 (02) 设置“x的父节点”为“新的x节点”。</td></tr><tr><td><strong>Case 3</strong></td><td>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</td><td>(01) 将x兄弟节点的左孩子设为“黑色”。 (02) 将x兄弟节点设为“红色”。 (03) 对x的兄弟节点进行右旋。 (04) 右旋后，重新设置x的兄弟节点。</td></tr><tr><td><strong>Case 4</strong></td><td>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</td><td>(01) 将x父节点颜色 赋值给 x的兄弟节点。 (02) 将x父节点设为“黑色”。 (03) 将x兄弟节点的右子节设为“黑色”。 (04) 对x的父节点进行左旋。 (05) 设置“x”为“根节点”。</td></tr></tbody></table><h5 id="Case-1-x是”黑-黑”节点，x的兄弟节点是红色"><a href="#Case-1-x是”黑-黑”节点，x的兄弟节点是红色" class="headerlink" title="(Case 1)x是”黑+黑”节点，x的兄弟节点是红色"></a><strong>(Case 1)x是”黑+黑”节点，x的兄弟节点是红色</strong></h5><h6 id="Case1-1-现象说明-1"><a href="#Case1-1-现象说明-1" class="headerlink" title="Case1.1 现象说明"></a><strong>Case1.1 现象说明</strong></h6><p>x是”黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</p><h6 id="Case1-2-处理策略-1"><a href="#Case1-2-处理策略-1" class="headerlink" title="Case1.2 处理策略"></a><strong>Case1.2 处理策略</strong></h6><p>(01) 将x的兄弟节点设为“黑色”。<br>(02) 将x的父节点设为“红色”。<br>(03) 对x的父节点进行左旋。<br>(04) 左旋后，重新设置x的兄弟节点。</p><p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   这样做的目的是将“Case 1”转换为“Case 2”、“Case 3”或“Case 4”，从而进行进一步的处理。对x的父节点进行左旋；左旋后，为了保持红黑树特性，就需要在左旋前“将x的兄弟节点设为黑色”，同时“将x的父节点设为红色”；左旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p><h6 id="Case1-3-示意图-1"><a href="#Case1-3-示意图-1" class="headerlink" title="Case1.3 示意图"></a><strong>Case1.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251813539515702.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljurarvkj30wm08s3z7.jpg" alt="img"></a></p><h5 id="Case-2-x是”黑-黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色"><a href="#Case-2-x是”黑-黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色" class="headerlink" title="(Case 2) x是”黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色"></a><strong>(Case 2) x是”黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色</strong></h5><h6 id="2-1-现象说明"><a href="#2-1-现象说明" class="headerlink" title="2.1 现象说明"></a><strong>2.1 现象说明</strong></h6><p>x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</p><h6 id="2-2-处理策略"><a href="#2-2-处理策略" class="headerlink" title="2.2 处理策略"></a><strong>2.2 处理策略</strong></h6><p>(01) 将x的兄弟节点设为“红色”。<br>(02) 设置“x的父节点”为“新的x节点”。</p><p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   这个情况的处理思想：是将“x中多余的一个黑色属性上移(往根方向移动)”。 x是“黑+黑”节点，我们将x由“黑+黑”节点 变成 “黑”节点，多余的一个“黑”属性移到x的父节点中，即x的父节点多出了一个黑属性(若x的父节点原先是“黑”，则此时变成了“黑+黑”；若x的父节点原先时“红”，则此时变成了“红+黑”)。 此时，需要注意的是：所有经过x的分支中黑节点个数没变化；但是，所有经过x的兄弟节点的分支中黑色节点的个数增加了1(因为x的父节点多了一个黑色属性)！为了解决这个问题，我们需要将“所有经过x的兄弟节点的分支中黑色节点的个数减1”即可，那么就可以通过“将x的兄弟节点由黑色变成红色”来实现。<br>   经过上面的步骤(将x的兄弟节点设为红色)，多余的一个颜色属性(黑色)已经跑到x的父节点中。我们需要将x的父节点设为“新的x节点”进行处理。若“新的x节点”是“黑+红”，直接将“新的x节点”设为黑色，即可完全解决该问题；若“新的x节点”是“黑+黑”，则需要对“新的x节点”进行进一步处理。</p><h6 id="2-3-示意图"><a href="#2-3-示意图" class="headerlink" title="2.3 示意图"></a><strong>2.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251814572322069.jpg" target="_blank" rel="noopener"><strong><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljvz73cnj30wc08z3z9.jpg" alt="img"></strong></a></p><h5 id="Case-3-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的"><a href="#Case-3-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的" class="headerlink" title="(Case 3)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的"></a><strong>(Case 3)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的</strong></h5><h6 id="3-1-现象说明"><a href="#3-1-现象说明" class="headerlink" title="3.1 现象说明"></a><strong>3.1 现象说明</strong></h6><p>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</p><h6 id="3-2-处理策略"><a href="#3-2-处理策略" class="headerlink" title="3.2 处理策略"></a><strong>3.2 处理策略</strong></h6><p>(01) 将x兄弟节点的左孩子设为“黑色”。<br>(02) 将x兄弟节点设为“红色”。<br>(03) 对x的兄弟节点进行右旋。<br>(04) 右旋后，重新设置x的兄弟节点。</p><p>​    <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>​    我们处理“Case 3”的目的是为了将“Case 3”进行转换，转换成“Case 4”,从而进行进一步的处理。转换的方式是对x的兄弟节点进行右旋；为了保证右旋后，它仍然是红黑树，就需要在右旋前“将x的兄弟节点的左孩子设为黑色”，同时“将x的兄弟节点设为红色”；右旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p><h6 id="3-3-示意图"><a href="#3-3-示意图" class="headerlink" title="3.3 示意图"></a><strong>3.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251815496235531.jpg" target="_blank" rel="noopener"><strong><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljwiee5lj30y60ba3zb.jpg" alt="img"></strong></a></p><h5 id="Case-4-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色"><a href="#Case-4-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色" class="headerlink" title="(Case 4)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色"></a><strong>(Case 4)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色</strong></h5><h6 id="4-1-现象说明"><a href="#4-1-现象说明" class="headerlink" title="4.1 现象说明"></a><strong>4.1 现象说明</strong></h6><p>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</p><h6 id="4-2-处理策略"><a href="#4-2-处理策略" class="headerlink" title="4.2 处理策略"></a><strong>4.2 处理策略</strong></h6><p>(01) 将x父节点颜色 赋值给 x的兄弟节点。<br>(02) 将x父节点设为“黑色”。<br>(03) 将x兄弟节点的右子节设为“黑色”。<br>(04) 对x的父节点进行左旋。<br>(05) 设置“x”为“根节点”。</p><p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   我们处理“Case 4”的目的是：去掉x中额外的黑色，将x变成单独的黑色。处理的方式是“：进行颜色修改，然后对x的父节点进行左旋。下面，我们来分析是如何实现的。<br>   为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“兄弟节点的左孩子”为BLS(Brother’s Left Son)，“兄弟节点的右孩子”为BRS(Brother’s Right Son)，“父节点”为F(Father)。<br>   我们要对F进行左旋。但在左旋前，我们需要调换F和B的颜色，并设置BRS为黑色。为什么需要这里处理呢？因为左旋后，F和BLS是父子关系，而我们已知BL是红色，如果F是红色，则违背了“特性(4)”；为了解决这一问题，我们将“F设置为黑色”。 但是，F设置为黑色之后，为了保证满足“特性(5)”，即为了保证左旋之后：<br>   第一，“同时经过根节点和S的分支的黑色节点个数不变”。<br>       若满足“第一”，只需要S丢弃它多余的颜色即可。因为S的颜色是“黑+黑”，而左旋后“同时经过根节点和S的分支的黑色节点个数”增加了1；现在，只需将S由“黑+黑”变成单独的“黑”节点，即可满足“第一”。<br>   第二，“同时经过根节点和BLS的分支的黑色节点数不变”。<br>       若满足“第二”，只需要将“F的原始颜色”赋值给B即可。之前，我们已经将“F设置为黑色”(即，将B的颜色”黑色”，赋值给了F)。至此，我们算是调换了F和B的颜色。<br>   第三，“同时经过根节点和BRS的分支的黑色节点数不变”。<br>       在“第二”已经满足的情况下，若要满足“第三”，只需要将BRS设置为“黑色”即可。<br>经过，上面的处理之后。红黑树的特性全部得到的满足！接着，我们将x设为根节点，就可以跳出while循环(参考伪代码)；即完成了全部处理。</p><p>至此，我们就完成了Case 4的处理。理解Case 4的核心，是了解如何“去掉当前节点额外的黑色”。</p><h6 id="4-3-示意图"><a href="#4-3-示意图" class="headerlink" title="4.3 示意图"></a><strong>4.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251817189983393.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljxatt04j30v108z3z9.jpg" alt="img"></a></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.2.1.平衡二叉树(AVL)</title>
      <link href="/2021/11/17/5.2.1.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(AVL)/"/>
      <url>/2021/11/17/5.2.1.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(AVL)/</url>
      
        <content type="html"><![CDATA[<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><strong>平衡二叉树</strong></h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>平衡二叉树又被称为AVL树，它是一棵<strong>二叉排序树</strong>，且具有以下性质：==它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。==所以它也被称为高度平衡树，<strong>n个结点的AVL树最大深度约1.44log2n</strong>。<strong>查找、插入和删除在平均和最坏情况下都是O（log n）</strong>。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p><p><strong>平衡因子</strong>：左子树高度 - 右子树高度。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlh02ck25j30gq06zgls.jpg" alt="img"></p><p>平衡二叉树的产生是为了解决二叉排序树在插入时发生线性排列的现象。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。</p><p><strong>节点定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLTree</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> AVLTreeNode&lt;T&gt; mRoot;    <span class="hljs-comment">// 根结点</span><br><br>    <span class="hljs-comment">// AVL树的节点(内部类)</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLTreeNode</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        T key;                <span class="hljs-comment">// 关键字(键值)</span><br>        <span class="hljs-keyword">int</span> height;         <span class="hljs-comment">// 高度</span><br>        AVLTreeNode&lt;T&gt; left;    <span class="hljs-comment">// 左孩子</span><br>        AVLTreeNode&lt;T&gt; right;    <span class="hljs-comment">// 右孩子</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AVLTreeNode</span><span class="hljs-params">(T key, AVLTreeNode&lt;T&gt; left, AVLTreeNode&lt;T&gt; right)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>            <span class="hljs-keyword">this</span>.height = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlh71su62j31o90u0acp.jpg" alt="image-20211120115506072"></p><p>平衡二叉树的出现能够解决上述问题，但是在构造平衡二叉树时，却需要采用不同的调整方式，使得二叉树在插入数据后保持平衡。主要的四种调整方式有LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。这里先给大家介绍下简单的单旋转操作，左旋和右旋。LR和RL本质上只是LL和RR的组合。</p><blockquote><p>在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于1时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用<strong>单旋转</strong>进行平衡化，如果这三个结点位于一条折线上，则采用<strong>双旋转</strong>进行平衡化。</p></blockquote><h3 id="左旋："><a href="#左旋：" class="headerlink" title="左旋："></a>左旋：</h3><p>S为当前需要左旋的结点，E为当前结点的父节点。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlhb2zor7j314s0gydgz.jpg" alt="image-20211120115858619"></p><p>左旋的操作可以用一句话简单表示：将当前结点S的左孩子旋转为当前结点父结点E的右孩子，同时将父结点E旋转为当前结点S的左孩子。</p><h3 id="右旋："><a href="#右旋：" class="headerlink" title="右旋："></a>右旋：</h3><p>S为当前需要左旋的结点，E为当前结点的父节点。右单旋是左单旋的镜像旋转。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlhfi56hej321y0tutbt.jpg" alt="image-20211120120313358"></p><p>将当前结点S的左孩子E的右孩子旋转为当前结点S的左孩子，同时将当前结点S旋转为左孩子E的右孩子。</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.2.0.树与二叉树</title>
      <link href="/2021/11/17/5.2.0.%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2021/11/17/5.2.0.%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><h3 id="1-1-1-树"><a href="#1-1-1-树" class="headerlink" title="1.1.1 树"></a>1.1.1 树</h3><p>是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。它具有以下特点：<strong>每个节点有零个或多个子节点</strong>；<strong>没有父节点的节点称为根节点</strong>；<strong>每一个非根节点有且只有一个父节点</strong> ；除了根节点外，每个子节点可以分为多个不相交的子树。</p><p>这意味着树是具备层次关系的，父子关系清晰，家庭血缘关系明朗；这也是树与图之间最主要的区别。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwle2sadf7j314m0jkabr.jpg" alt="image-20211120100712268"></p><p>树的实现就是对链表的指针域进行了扩充，增加了多个地址指向子结点。同时将“链表”竖起来，从而凸显了结点之间的层次关系，更便于分析和理解。</p><h3 id="1-1-2-二叉树"><a href="#1-1-2-二叉树" class="headerlink" title="1.1.2 二叉树"></a>1.1.2 二叉树</h3><p>二叉树是每个节点最多有两棵子树的树结构。通常子树被称作“左子树”和“右子树”。二叉树常被用于实现二叉查找树和二叉堆。</p><p>二叉树的每个结点至多只有2棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。</p><p>二叉树的第i层至多有2(i-1)个结点；深度为k的二叉树至多有2k-1个结点。</p><p>树可以衍生出许多的结构，若将指针域设置为双指针，那么即可形成最常见的二叉树，即每个结点最多有两个子树的树结构。二叉树根据结点的排列和数量还可进一度划分为<strong>完全二叉树、满二叉树、平衡二叉树、红黑树</strong>等。</p><blockquote><h4 id="完全二叉树："><a href="#完全二叉树：" class="headerlink" title="完全二叉树："></a><strong>完全二叉树</strong>：</h4></blockquote><p>除了最后一层结点，其它层的结点数都达到了最大值；同时最后一层的结点都是按照从左到右依次排布。</p><blockquote><h4 id="满二叉树："><a href="#满二叉树：" class="headerlink" title="满二叉树："></a><strong>满二叉树</strong>：</h4></blockquote><p>除了最后一层，其它层的结点都有两个子结点。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwle45lpydj314e0fajsl.jpg" alt="image-20211120100831037"></p><h2 id="1-2-树和二叉树的区别"><a href="#1-2-树和二叉树的区别" class="headerlink" title="1.2 树和二叉树的区别"></a>1.2 <strong>树和二叉树的区别</strong></h2><p>(1) 二叉树每个节点最多有2个子节点，树则无限制。</p><p>(2) 二叉树中节点的子树分为左子树和右子树，即使某节点只有一棵子树，也要指明该子树是左子树还是右子树，即二叉树是有序的。 </p><p>(3) 树决不能为空，它至少有一个节点，而一棵二叉树可以是空的。</p><h2 id="2-1-二叉树的遍历"><a href="#2-1-二叉树的遍历" class="headerlink" title="2.1 二叉树的遍历"></a>2.1 二叉树的遍历</h2><p>(1) <strong>先序遍历</strong> 若二叉树为空，则空操作，否则先访问根节点，再先序遍历左子树，最后先序遍历右子树。==(根左右)==</p><p>(2) <strong>中序遍历</strong> 若二叉树为空，则空操作，否则先中序遍历左子树，再访问根节点，最后中序遍历右子树。==(左根右)==</p><p>(3) <strong>后序遍历</strong> 若二叉树为空，则空操作，否则先后序遍历左子树访问根节点，再后序遍历右子树，最后访问根节点。==(左右根)==</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlei80reej30dq0bmglw.jpg" alt="img"></p><ul><li>二叉树的节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    E element;<br>    TreeNode&lt;E&gt; left;<br>    TreeNode&lt;E&gt; right;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        element = e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>二叉查找树的三种遍历都可以直接用递归的方法来实现：</p><ul><li>先序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode&lt;E&gt; root)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br><br>    System.out.println(root.element + <span class="hljs-string">" "</span>);<br><br>    preorder(root.left);<br><br>    preorder(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>中序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode&lt;E&gt; root)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br><br>    inorder(root.left);<br><br>    System.out.println(root.element + <span class="hljs-string">" "</span>);<br><br>    inorder(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>后序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode&lt;E&gt; root)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br><br>    postorder(root.left);<br><br>    postorder(root.right);<br><br>    System.out.println(root.element + <span class="hljs-string">" "</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-二叉查找树"><a href="#2-2-二叉查找树" class="headerlink" title="2.2 二叉查找树"></a>2.2 二叉查找树</h2><h3 id="2-2-1-定义"><a href="#2-2-1-定义" class="headerlink" title="2.2.1 定义"></a>2.2.1 定义</h3><p>==<strong>二叉查找树就是二叉排序树，也叫二叉搜索树。</strong>==</p><p>二叉查找树或者是一棵空树，或者是具有下列性质的二叉树： </p><ol><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的结点。</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlet0748aj30k908yq3k.jpg" alt="img"></p><p>节点的前驱：是该节点的左子树中的最大节点。<br>节点的后继：是该节点的右子树中的最小节点。</p><h3 id="2-2-2-性能分析"><a href="#2-2-2-性能分析" class="headerlink" title="2.2.2 性能分析"></a>2.2.2 性能分析</h3><p>对于二叉查找树来说，当给定值相同但顺序不同时，所构建的二叉查找树形态是不同的，下面看一个例子。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlevx30tmj30du09n74l.jpg" alt="img"></p><p>可以看到，含有n个节点的二叉查找树的平均查找长度和树的形态有关。最坏情况下，当先后插入的关键字有序时，构成的二叉查找树蜕变为单支树，树的深度为n，其平均查找长度(n+1)/2(和顺序查找相同），最好的情况是二叉查找树的形态和折半查找的判定树相同，其平均查找长度和log2(n)成正比。平均情况下，二叉查找树的平均查找长度和logn是等数量级的，所以为了获得更好的性能，通常在二叉查找树的构建过程需要进行“平衡化处理”，之后我们将介绍平衡二叉树和红黑树，这些均可以使查找树的高度为O(log(n))。</p><ul><li>二叉查找树的简单实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBinSearchTree</span>&lt;<span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">E</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-comment">// 根</span><br>    <span class="hljs-keyword">private</span> TreeNode&lt;E&gt; root;<br><br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyBinSearchTree</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 二叉查找树的搜索</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(E e)</span> </span>&#123;<br><br>        TreeNode&lt;E&gt; current = root;<br><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-keyword">null</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (e.compareTo(current.element) &lt; <span class="hljs-number">0</span>) &#123;<br>                current = current.left;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.compareTo(current.element) &gt; <span class="hljs-number">0</span>) &#123;<br>                current = current.right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 二叉查找树的插入</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insert</span><span class="hljs-params">(E e)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 如果之前是空二叉树 插入的元素就作为根节点</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            root = createNewNode(e);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则就从根节点开始遍历 直到找到合适的父节点</span><br>            TreeNode&lt;E&gt; parent = <span class="hljs-keyword">null</span>;<br>            TreeNode&lt;E&gt; current = root;<br>            <span class="hljs-keyword">while</span> (current != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (e.compareTo(current.element) &lt; <span class="hljs-number">0</span>) &#123;<br>                    parent = current;<br>                    current = current.left;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.compareTo(current.element) &gt; <span class="hljs-number">0</span>) &#123;<br>                    parent = current;<br>                    current = current.right;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 有相同键值，不可插入</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 插入</span><br>            <span class="hljs-keyword">if</span> (e.compareTo(parent.element) &lt; <span class="hljs-number">0</span>) &#123;<br>                parent.left = createNewNode(e);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                parent.right = createNewNode(e);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 创建新的节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> TreeNode&lt;E&gt; <span class="hljs-title">createNewNode</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(e);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 二叉树的节点</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">E</span>&gt;&gt; </span>&#123;<br><br>    E element;<br>    TreeNode&lt;E&gt; left;<br>    TreeNode&lt;E&gt; right;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        element = e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>二叉查找树中删除节点分析</strong></li></ul><p>要在二叉查找树中删除一个元素，首先需要定位包含该元素的节点，以及它的父节点。假设current指向二叉查找树中包含该元素的节点，而parent指向current节点的父节点，current节点可能是parent节点的左孩子，也可能是右孩子。这里需要考虑两种情况：</p><ol><li>current节点没有左孩子，那么只需要将patent节点和current节点的右孩子相连。</li><li>current节点有一个左孩子，假设rightMost指向包含current节点的左子树中最大元素的节点，而parentOfRightMost指向rightMost节点的父节点。那么先使用rightMost节点中的元素值替换current节点中的元素值，将parentOfRightMost节点和rightMost节点的左孩子相连，然后删除rightMost节点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 二叉搜索树删除节点</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">delete</span><span class="hljs-params">(E e)</span> </span>&#123;<br><br>    TreeNode&lt;E&gt; parent = <span class="hljs-keyword">null</span>;<br>    TreeNode&lt;E&gt; current = root;<br><br>    <span class="hljs-comment">// 找到要删除的节点的位置</span><br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (e.compareTo(current.element) &lt; <span class="hljs-number">0</span>) &#123;<br>            parent = current;<br>            current = current.left;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.compareTo(current.element) &gt; <span class="hljs-number">0</span>) &#123;<br>            parent = current;<br>            current = current.right;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 没找到要删除的节点</span><br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 考虑第一种情况</span><br>    <span class="hljs-keyword">if</span> (current.left == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-keyword">null</span>) &#123;<br>            root = current.right;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (e.compareTo(parent.element) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//判断current是左子叶还是右子叶</span><br>                parent.left = current.right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                parent.right = current.right;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 考虑第二种情况</span><br>        TreeNode&lt;E&gt; parentOfRightMost = current;<br>        TreeNode&lt;E&gt; rightMost = current.left;<br>        <span class="hljs-comment">// 找到左子树中最大的元素节点</span><br>        <span class="hljs-keyword">while</span> (rightMost.right != <span class="hljs-keyword">null</span>) &#123;<br>            parentOfRightMost = rightMost;<br>            rightMost = rightMost.right;<br>        &#125;<br><br>        <span class="hljs-comment">// 替换</span><br>        current.element = rightMost.element;<br><br>        <span class="hljs-comment">// parentOfRightMost和rightMost左孩子相连</span><br>        <span class="hljs-keyword">if</span> (parentOfRightMost.right == rightMost) &#123;<br>            parentOfRightMost.right = rightMost.left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parentOfRightMost.left = rightMost.left;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.1.二叉树思维导图</title>
      <link href="/2021/11/16/5.1.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
      <url>/2021/11/16/5.1.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/10/04/08Rsat.jpg" alt="08Rsat.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.2.栈与队列</title>
      <link href="/2021/11/16/4.2.%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2021/11/16/4.2.%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>对于栈来说，访问、插入和删除元素只能在<strong>栈顶</strong>进行，==先进后出==（FILO）。</p><p>栈的常用操作包括入栈push和出栈pop，对应于数据的压入和压出。还有访问栈顶数据、判断栈是否为空和判断栈的大小等。由于栈后进先出的特性，常可以作为数据操作的临时容器，对数据的顺序进行调控，与其它数据结构相结合可获得许多灵活的处理。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwkoj6evu6j306405sq2t.jpg" alt="img"></p><p><strong>1. Java实现一：Java的 Collection集合 中自带的”栈”(stack)的示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Stack;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackTest</span> </span>&#123;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> tmp=<span class="hljs-number">0</span>;<br>        Stack&lt;Integer&gt; astack = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 将10, 20, 30 依次推入栈中</span><br>        astack.push(<span class="hljs-number">10</span>);<br>        astack.push(<span class="hljs-number">20</span>);<br>        astack.push(<span class="hljs-number">30</span>);<br><br>        <span class="hljs-comment">// 将“栈顶元素”赋值给tmp，并删除“栈顶元素”</span><br>        tmp = astack.pop();<br>        <span class="hljs-comment">//System.out.printf("tmp=%d\n", tmp);</span><br><br>        <span class="hljs-comment">// 只将“栈顶”赋值给tmp，不删除该元素.</span><br>        tmp = (<span class="hljs-keyword">int</span>)astack.peek();<br>        <span class="hljs-comment">//System.out.printf("tmp=%d\n", tmp);</span><br><br>        astack.push(<span class="hljs-number">40</span>);<br>        <span class="hljs-keyword">while</span>(!astack.empty()) &#123;<br>            tmp = (<span class="hljs-keyword">int</span>)astack.pop();<br>            System.out.printf(<span class="hljs-string">"tmp=%d\n"</span>, tmp);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tmp</span>=<span class="hljs-number">40</span><br><span class="hljs-attr">tmp</span>=<span class="hljs-number">20</span><br><span class="hljs-attr">tmp</span>=<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>2. Java实现二：数组实现的栈，能存储任意类型的数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Array;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneralArrayStack</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_SIZE = <span class="hljs-number">12</span>;<br>    <span class="hljs-keyword">private</span> T[] mArray;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GeneralArrayStack</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(type, DEFAULT_SIZE);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GeneralArrayStack</span><span class="hljs-params">(Class&lt;T&gt; type, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        <span class="hljs-comment">// 不能直接使用mArray = new T[DEFAULT_SIZE];</span><br>        mArray = (T[]) Array.newInstance(type, size);<br>        count = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将val添加到栈中</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T val)</span> </span>&#123;<br>        mArray[count++] = val;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回“栈顶元素值”</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mArray[count-<span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-comment">// 返回“栈顶元素值”，并删除“栈顶元素”</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        T ret = mArray[count-<span class="hljs-number">1</span>];<br>        count--;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回“栈”的大小</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回“栈”是否为空</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size()==<span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印“栈”</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintArrayStack</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.printf(<span class="hljs-string">"stack is Empty\n"</span>);<br>        &#125;<br><br>        System.out.printf(<span class="hljs-string">"stack size()=%d\n"</span>, size());<br><br>        <span class="hljs-keyword">int</span> i=size()-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i&gt;=<span class="hljs-number">0</span>) &#123;<br>            System.out.println(mArray[i]);<br>            i--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String tmp;<br>        GeneralArrayStack&lt;String&gt; astack = <span class="hljs-keyword">new</span> GeneralArrayStack&lt;String&gt;(String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>        <span class="hljs-comment">// 将10, 20, 30 依次推入栈中</span><br>        astack.push(<span class="hljs-string">"10"</span>);<br>        astack.push(<span class="hljs-string">"20"</span>);<br>        astack.push(<span class="hljs-string">"30"</span>);<br><br>        <span class="hljs-comment">// 将“栈顶元素”赋值给tmp，并删除“栈顶元素”</span><br>        tmp = astack.pop();<br>        System.out.println(<span class="hljs-string">"tmp="</span>+tmp);<br><br>        <span class="hljs-comment">// 只将“栈顶”赋值给tmp，不删除该元素.</span><br>        tmp = astack.peek();<br>        System.out.println(<span class="hljs-string">"tmp="</span>+tmp);<br><br>        astack.push(<span class="hljs-string">"40"</span>);<br>        astack.PrintArrayStack();    <span class="hljs-comment">// 打印栈</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>tmp=<span class="hljs-number">30</span><br><span class="hljs-symbol">2 </span>tmp=<span class="hljs-number">20</span><br><span class="hljs-symbol">3 </span>stack size()=<span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">40</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">20</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>对于队列来说，元素只能从队列尾插入，从队列头访问和删除，先进先出（FIFO）</p><p>它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwkojg560fj30ce035745.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span></span>&#123;<br>  <span class="hljs-keyword">private</span> LinkedList&lt;E&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>&#123;<br>    list.addLast(e);<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> list.removeFirst();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1. Java实现一：Java的 Collection集合中自带的”栈”(Stack)实现队列的示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Stack;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackList</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">// 向队列添加数据时：(01) 将“已有的全部数据”都移到mIn中。 (02) 将“新添加的数据”添加到mIn中。</span><br>    <span class="hljs-keyword">private</span> Stack&lt;T&gt; mIn  = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 从队列获取元素时：(01) 将“已有的全部数据”都移到mOut中。(02) 返回并删除mOut栈顶元素。</span><br>    <span class="hljs-keyword">private</span> Stack&lt;T&gt; mOut = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 统计计数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StackList</span><span class="hljs-params">()</span> </span>&#123;<br>        mIn = <span class="hljs-keyword">new</span> Stack&lt;T&gt;();<br>        mOut = <span class="hljs-keyword">new</span> Stack&lt;T&gt;();<br>        mCount = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T t)</span> </span>&#123;<br>        <span class="hljs-comment">// 将“已有的全部数据”都移到mIn中</span><br>        <span class="hljs-keyword">while</span> (!mOut.empty())<br>            mIn.push(mOut.pop());<br><br>        <span class="hljs-comment">// 将“新添加的数据”添加到mIn中</span><br>        mIn.push(t);<br>        <span class="hljs-comment">// 统计数+1</span><br>        mCount++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 将“已有的全部数据”都移到mOut中</span><br>        <span class="hljs-keyword">while</span> (!mIn.empty())<br>            mOut.push(mIn.pop());<br>        <span class="hljs-comment">// 统计数-1</span><br>        mCount--;<br><br>        <span class="hljs-comment">// 返回并删除mOut栈顶元素</span><br>        <span class="hljs-keyword">return</span> mOut.pop();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mCount;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mCount==<span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        StackList slist = <span class="hljs-keyword">new</span> StackList();<br><br>        <span class="hljs-comment">// 将10, 20, 30 依次推入栈中</span><br>        slist.add(<span class="hljs-number">10</span>);<br>        slist.add(<span class="hljs-number">20</span>);<br>        slist.add(<span class="hljs-number">30</span>);<br><br>        System.out.printf(<span class="hljs-string">"isEmpty()=%b\n"</span>, slist.isEmpty());<br>        System.out.printf(<span class="hljs-string">"size()=%d\n"</span>, slist.size());<br>        <span class="hljs-keyword">while</span>(!slist.isEmpty()) &#123;<br>            System.out.printf(<span class="hljs-string">"%d\n"</span>, slist.get());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tmp=<span class="hljs-number">10</span><br>tmp=<span class="hljs-number">20</span><br><span class="hljs-function"><span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>=false<br><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span>=<span class="hljs-number">3</span><br><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span>=<span class="hljs-number">20</span><br><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span>=<span class="hljs-number">30</span><br><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span>=<span class="hljs-number">40</span><br></code></pre></td></tr></table></figure><p><strong>2. Java实现二：数组实现的队列存储int类型的数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayQueue</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] mArray;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mCount;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sz)</span> </span>&#123;<br>        mArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sz];<br>        mCount = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将val添加到队列的末尾</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        mArray[mCount++] = val;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回“队列开头元素”</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mArray[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-comment">// 返回“栈顶元素值”，并删除“栈顶元素”</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = mArray[<span class="hljs-number">0</span>];<br>        mCount--;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=mCount; i++)<br>            mArray[i-<span class="hljs-number">1</span>] = mArray[i];<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回“栈”的大小</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mCount;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回“栈”是否为空</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size()==<span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> tmp=<span class="hljs-number">0</span>;<br>        ArrayQueue astack = <span class="hljs-keyword">new</span> ArrayQueue(<span class="hljs-number">12</span>);<br><br>        <span class="hljs-comment">// 将10, 20, 30 依次推入栈中</span><br>        astack.add(<span class="hljs-number">10</span>);<br>        astack.add(<span class="hljs-number">20</span>);<br>        astack.add(<span class="hljs-number">30</span>);<br><br>        <span class="hljs-comment">// 将“栈顶元素”赋值给tmp，并删除“栈顶元素”</span><br>        tmp = astack.pop();<br>        System.out.printf(<span class="hljs-string">"tmp=%d\n"</span>, tmp);<br><br>        <span class="hljs-comment">// 只将“栈顶”赋值给tmp，不删除该元素.</span><br>        tmp = astack.front();<br>        System.out.printf(<span class="hljs-string">"tmp=%d\n"</span>, tmp);<br><br>        astack.add(<span class="hljs-number">40</span>);<br><br>        System.out.printf(<span class="hljs-string">"isEmpty()=%b\n"</span>, astack.isEmpty());<br>        System.out.printf(<span class="hljs-string">"size()=%d\n"</span>, astack.size());<br>        <span class="hljs-keyword">while</span> (!astack.isEmpty()) &#123;<br>            System.out.printf(<span class="hljs-string">"size()=%d\n"</span>, astack.pop());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tmp=<span class="hljs-number">10</span><br>tmp=<span class="hljs-number">20</span><br><span class="hljs-function"><span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>=false<br><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span>=<span class="hljs-number">3</span><br><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span>=<span class="hljs-number">20</span><br><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span>=<span class="hljs-number">30</span><br><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span>=<span class="hljs-number">40</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.1.栈与队列思维导图</title>
      <link href="/2021/11/16/4.1.%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
      <url>/2021/11/16/4.1.%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/10/04/08Raxe.jpg" alt="08Raxe.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.2.数组和链表(2)</title>
      <link href="/2021/11/16/3.2.%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8(2)/"/>
      <url>/2021/11/16/3.2.%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8(2)/</url>
      
        <content type="html"><![CDATA[<h2 id="数组实例"><a href="#数组实例" class="headerlink" title="数组实例"></a>数组实例</h2><h5 id="Java"><a href="#Java" class="headerlink" title="++Java++"></a>++Java++</h5><h6 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方式一</span><br><span class="hljs-keyword">int</span>[] intArr;<br>intArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>&#125;;<br><br><span class="hljs-comment">//方式二</span><br>String[] strArr = &#123;<span class="hljs-string">"张三"</span>,<span class="hljs-string">"李四"</span>,<span class="hljs-string">"王二麻"</span>&#125;;<br><br><span class="hljs-comment">//方式三</span><br><span class="hljs-keyword">int</span>[] price = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>]; <span class="hljs-comment">// &#123;0,0,0,0&#125;</span><br></code></pre></td></tr></table></figure><h6 id="多维"><a href="#多维" class="headerlink" title="多维"></a>多维</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String str[][] = <span class="hljs-keyword">new</span> String[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure><p>数组容量如果不够用可以使用 Arrays.copyOf() 进行扩容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Array.copyOf(E[] e,newLength);<br></code></pre></td></tr></table></figure><p>其第一个形参指的是需要扩容的数组，后面是扩容后的大小，其内部实现其实是使用了 System.arrayCopy(); 在内部重新创建一个长度为 newLength 类型是 E 的数组。<br>默认补 0，输出结果为： 10 20 30 40 50 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] a= &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>&#125;;<br>        a= Arrays.copyOf(a,a.length+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++) &#123;<br>            System.out.println(a[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Python"><a href="#Python" class="headerlink" title="++Python++"></a>++Python++</h5><h6 id="一维-1"><a href="#一维-1" class="headerlink" title="一维"></a>一维</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-string">'Google'</span>, <span class="hljs-string">'Runoob'</span>, <span class="hljs-number">1997</span>, <span class="hljs-number">2000</span>]<br>list2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ]<br>list3 = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>]<br><br>a=[<span class="hljs-literal">None</span>]*<span class="hljs-number">4</span> <span class="hljs-comment">#[None, None, None, None]</span><br><br>b=list(range(<span class="hljs-number">10</span>)) <span class="hljs-comment">#[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><br>c = [<span class="hljs-string">'x'</span> <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment">#['x', 'x', 'x', 'x', 'x']</span><br><br>字典：dic=&#123;<span class="hljs-string">'a'</span>:<span class="hljs-number">12</span>, <span class="hljs-string">'b'</span>:<span class="hljs-number">34</span>&#125;<br>集合：s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;        <br>列表：list=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]<br>元组：tup=(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)    <span class="hljs-comment">#元组是不可更改的列表</span><br></code></pre></td></tr></table></figure><h6 id="多维-1"><a href="#多维-1" class="headerlink" title="多维"></a>多维</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 直接赋值</span><br>a = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]<br>n = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>x = [a, n]<br><br><span class="hljs-comment">#列表生成式法</span><br>test = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n)]<br><br><span class="hljs-comment">#使用模块numpy创建</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>test = np.zeros((m, n), dtype=np.int)<br></code></pre></td></tr></table></figure><p>==注意== : A=[[0]<em>m]</em>n 这种初始化方式，改变一个元素，会影响整列！！！</p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表是最常用且最简单的一种数据结构，它是n个数据元素的有限序列。</p><p>实现线性表的方式一般有两种，一种是使用数组存储线性表的元素，即用一组连续的存储单元依次存储线性表的数据元素。另一种是使用链表存储线性表的元素，即用一组任意的存储单元存储线性表的数据元素（存储单元可以是连续的，也可以是不连续的）。</p><p>数组实现的优缺点:</p><ol><li>优点：无须关心表中元素之间的关系，所以不用增加额外的存储空间；可以快速地取表中任意位置的元素。</li><li>缺点：插入和删除操作需要移动大量元素。使用前需事先分配好内存空间，当线性表长度变化较大时，难以确定存储空间的容量。分配空间过大会造成存储空间的巨大浪费，分配的空间过小，难以适应问题的需求。</li></ol><p>链表实现的优缺点:</p><ol><li>存储方式：单链表用一组任意的存储单元存放线性表的数据元素。</li><li>时间性能：采用循序存储结构时查找的时间复杂度为O(1)，插入和删除需要移动平均一半的数据元素，时间复杂度为O(n)。采用单链表存储结构的查找时间复杂度为O(n)，插入和删除不需要移动元素，时间复杂度仅为O(1）。</li><li>空间性能：采用顺序存储结构时需要预先分配存储空间，分配空间过大会造成浪费，过小会造成问题。采用单链表存储结构时，可根据需要进行临时分配，不需要估计问题的规模大小，只要内存够就可以分配，还可以用于一些特殊情况，如一元多项的表示。</li></ol><h2 id="Java-现成的类-："><a href="#Java-现成的类-：" class="headerlink" title="==Java 现成的类==："></a>==Java 现成的类==：</h2><ul><li><p>线性表： ArrayList.</p><blockquote><p>ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。java自带的集合包中有实现双向链表，路径是:java.util.LinkedList</p></blockquote><blockquote><p>详见: <a href="https://www.runoob.com/java/java-arraylist.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-arraylist.html</a></p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;String&gt; sites = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        sites.add(<span class="hljs-string">"Google"</span>);<br>        sites.add(<span class="hljs-string">"Runoob"</span>);<br>        sites.add(<span class="hljs-string">"Taobao"</span>);<br>        sites.add(<span class="hljs-string">"Weibo"</span>);<br>        System.out.println(sites);<br>      <br>      <span class="hljs-comment">//访问 ArrayList 中的元素可以使用 get() 方法：</span><br>        System.out.println(sites.get(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 输出为 Google</span><br>      <br>      <span class="hljs-comment">//如果要修改 ArrayList 中的元素可以使用 set() 方法：</span><br>      sites.set(<span class="hljs-number">2</span>,<span class="hljs-string">"Wiki"</span>);<br>       System.out.println(sites.get(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出为 Wiki</span><br>      <br>      <span class="hljs-comment">//删除 ArrayList 中的元素可以使用 remove() 方法：</span><br>      sites.remove(<span class="hljs-number">2</span>);<br>       System.out.println(sites); <span class="hljs-comment">// 输出为 Google Runoob Weibo</span><br>      <br>      <span class="hljs-comment">//如果要计算 ArrayList 中的元素数量可以使用 size() 方法：</span><br>      System.out.println(sites.size()); <span class="hljs-comment">// 输出为3</span><br>      <br>      <span class="hljs-comment">//Collections 类也是一个非常有用的类，位于 java.util 包中，提供的 sort() 方法可以对字符或数字列表进行排序。</span><br>      Collections.sort(sites);  <span class="hljs-comment">// 字母排序</span><br>      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他的引用类型"><a href="#其他的引用类型" class="headerlink" title="其他的引用类型"></a>其他的引用类型</h3><p>  ArrayList 中的元素实际上是对象，在以上实例中，数组列表元素都是字符串 String 类型。</p><p>  如果我们要存储其他类型，而 <E> 只能为引用数据类型，这时我们就需要使用到基本类型的包装类。</p><p>  基本类型对应的包装类表如下：</p><table><thead><tr><th align="left">基本类型</th><th align="left">引用类型</th></tr></thead><tbody><tr><td align="left">boolean</td><td align="left">Boolean</td></tr><tr><td align="left">byte</td><td align="left">Byte</td></tr><tr><td align="left">short</td><td align="left">Short</td></tr><tr><td align="left">int</td><td align="left">Integer</td></tr><tr><td align="left">long</td><td align="left">Long</td></tr><tr><td align="left">float</td><td align="left">Float</td></tr><tr><td align="left">double</td><td align="left">Double</td></tr><tr><td align="left">char</td><td align="left">Character</td></tr></tbody></table><p>  此外，BigInteger、BigDecimal 用于高精度的运算，BigInteger 支持任意精度的整数，也是引用类型，但它们没有相对应的基本类型。</p></li><li><p>链表: LinkedList.</p><blockquote><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。</p></blockquote><blockquote><p>详见: <a href="https://www.runoob.com/java/java-linkedlist.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-linkedlist.html</a></p><p>与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低。</p><p><strong>以下情况使用 ArrayList :</strong></p><ul><li>频繁访问列表中的某一个元素。</li><li>只需要在列表末尾进行添加和删除元素操作。</li></ul><p><strong>以下情况使用 LinkedList :</strong></p><ul><li>你需要通过循环迭代来访问列表中的某些元素。</li><li>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</li></ul></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 引入 LinkedList 类</span><br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunoobTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LinkedList&lt;String&gt; sites = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>        sites.add(<span class="hljs-string">"Google"</span>);<br>        sites.add(<span class="hljs-string">"Runoob"</span>);<br>        sites.add(<span class="hljs-string">"Taobao"</span>);<br>        <span class="hljs-comment">// 使用 addFirst() 在头部添加元素</span><br>        sites.addFirst(<span class="hljs-string">"Wiki"</span>);<br>        System.out.println(sites); <span class="hljs-comment">// [Wiki, Google, Runoob, Taobao]</span><br>      <span class="hljs-comment">// 使用 addLast() 在尾部添加元素</span><br>        sites.addLast(<span class="hljs-string">"Baidu"</span>);<br>        System.out.println(sites); <span class="hljs-comment">// [Wiki, Google, Runoob, Taobao, Baidu]</span><br>        <span class="hljs-comment">// 使用 removeFirst() 移除头部元素</span><br>        sites.removeFirst();<br>        System.out.println(sites); <span class="hljs-comment">// [Google, Runoob, Taobao, Baidu]</span><br>        <span class="hljs-comment">// 使用 removeLast() 移除尾部元素</span><br>        sites.removeLast();<br>        System.out.println(sites); <span class="hljs-comment">// [Google, Runoob, Taobao]</span><br>        <span class="hljs-comment">// 使用 getFirst() 获取头部元素</span><br>        System.out.println(sites.getFirst()); <span class="hljs-comment">// Google</span><br>        <span class="hljs-comment">// 使用 getLast() 获取尾部元素</span><br>        System.out.println(sites.getLast()); <span class="hljs-comment">// Taobao</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="Python-现成的类-："><a href="#Python-现成的类-：" class="headerlink" title="==Python 现成的类==："></a>==Python 现成的类==：</h2><p>目前没发现, list[]可以append()和insert(),pop()和remove()</p><h2 id="自己实现链表实例"><a href="#自己实现链表实例" class="headerlink" title="自己实现链表实例"></a>自己实现链表实例</h2><h5 id="Java-1"><a href="#Java-1" class="headerlink" title="++Java++"></a>++Java++</h5><p><strong>单向链表</strong></p><h6 id="基础类"><a href="#基础类" class="headerlink" title="基础类"></a>基础类</h6><figure class="highlight Java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">public</span> Object data;<br><br>    <span class="hljs-comment">//指针域，指向下一个节点</span><br>    <span class="hljs-keyword">public</span> Node next;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(Object data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(Object data, Node next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="链表类"><a href="#链表类" class="headerlink" title="链表类"></a>链表类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleLinkedList</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Node head;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-comment">//单向链表构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SingleLinkedList</span><span class="hljs-params">()</span></span>&#123;<br>        head = <span class="hljs-keyword">null</span>;<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//基础方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(Object data)</span></span>&#123; <span class="hljs-comment">// 插入尾部</span><br>        Node newNode = <span class="hljs-keyword">new</span> Node(data);<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123; <br>            head = newNode;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        Node temp = head;<br>        <span class="hljs-keyword">while</span>(temp.next != <span class="hljs-keyword">null</span>)&#123;<br>            temp = temp.next;<br>        &#125;<br>        temp.next = newNode;<br>        newNode.next = <span class="hljs-keyword">null</span>;<br>        size ++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Object data)</span></span>&#123; <span class="hljs-comment">//指定位置插入</span><br>        Node newNode = <span class="hljs-keyword">new</span> Node(data);<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123; <br>            head = newNode;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Node pre = head;<br>        Node temp = head.next;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span> &amp;&amp; j &lt; index)&#123;<br>            pre = temp;<br>            temp = temp.next;<br>            j++;<br>        &#125;<br>      pre.next = newNode;<br>        newNode.next = temp;<br>        size++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>      <br>      <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>)&#123;<br>          size--;<br>          Object result = head.data;<br>          head = <span class="hljs-keyword">null</span>;<br>          <span class="hljs-keyword">return</span> result;<br>        &#125;<br>      <br>        Node pre = head;<br>        Node temp = head.next; <br>      <br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span> &amp;&amp; j &lt; size)&#123;<br>            pre = temp;<br>            temp = temp.next;<br>            j++;<br>        &#125;<br>        pre.next = <span class="hljs-keyword">null</span>;<br>        size--;<br>        <span class="hljs-keyword">return</span> temp.data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">1</span> || index &gt; size) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"Invalid Index"</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>)&#123;<br>            size--;<br>            <span class="hljs-keyword">return</span> head.data;<br>        &#125;<br><br>        Node pre = head;<br>        Node temp = head.next;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span> &amp;&amp; j &lt; index)&#123;<br>            pre = temp;<br>            temp = temp.next;<br>            j++;<br>        &#125;<br>        pre.next = temp.next;<br>        <span class="hljs-keyword">return</span> temp.data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">1</span> || index &gt; size) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"Invalid Index"</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head.data;<br>        &#125;<br><br>        Node temp = head.next;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span> &amp;&amp; j&lt;index)&#123;<br>            temp = temp.next;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp.data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            System.out.println(<span class="hljs-string">""</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>)&#123;<br>                System.out.println(head.data);<br>            &#125;<br>            <span class="hljs-keyword">for</span>(Node temp = head.next; temp != <span class="hljs-keyword">null</span>; temp = temp.next)&#123;<br>                System.out.println(temp.data);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleLinkedListTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>SingleLinkedList singleLinkedList=<span class="hljs-keyword">new</span> SingleLinkedList();<br>System.out.println(<span class="hljs-string">"初始线性表："</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>singleLinkedList.insert(i, i);<br>&#125;<br>singleLinkedList.print();<br><br>System.out.println(<span class="hljs-string">"在位置4插入元素9后的线性表："</span>);<br>singleLinkedList.insert(<span class="hljs-number">4</span>, <span class="hljs-number">9</span>);<br> <br>singleLinkedList.print();<br><br>System.out.println(<span class="hljs-string">"表尾插入元素0后的线性表："</span>);<br>singleLinkedList.append(<span class="hljs-number">0</span>);<br>singleLinkedList.print();<br><br>System.out.println(<span class="hljs-string">"删除第5个元素后的线性表："</span>);<br>singleLinkedList.delete(<span class="hljs-number">5</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>双向链表</strong></p><h6 id="基础类-1"><a href="#基础类-1" class="headerlink" title="基础类"></a>基础类</h6><figure class="highlight Java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">public</span> Object data;<br>    <br>    <span class="hljs-comment">//指针域，指向上一个节点</span><br>    <span class="hljs-keyword">public</span> Node prev;<br><br>    <span class="hljs-comment">//指针域，指向下一个节点</span><br>    <span class="hljs-keyword">public</span> Node next;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(Object data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(Object data, Node next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>        <span class="hljs-keyword">this</span>.next = next;<br>        <span class="hljs-keyword">this</span>.prev = prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="关键操作"><a href="#关键操作" class="headerlink" title="关键操作"></a>关键操作</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(E value)</span></span>&#123;<br>    Node index=<span class="hljs-keyword">this</span>.first;<span class="hljs-comment">//创建index节点指向first节点</span><br>    <span class="hljs-keyword">while</span>(index!=<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(index.e==value)<span class="hljs-keyword">break</span>;<br>        index=index.next;<br>    &#125;<span class="hljs-comment">//while循环用于遍历整个链表来获取指向要删除的节点指针</span><br>    index.previous.next=index.next;<br>    index.next.previous=index.previous;<br>    length--;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>循环链表</strong></p><h6 id="基础类-2"><a href="#基础类-2" class="headerlink" title="基础类"></a>基础类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">public</span> Object data;<br><br>    <span class="hljs-comment">//指针域，指向下一个节点</span><br>    <span class="hljs-keyword">public</span> Node next;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(Object data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(Object data, Node next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="链表类-1"><a href="#链表类-1" class="headerlink" title="链表类"></a>链表类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoopLinkedList</span> </span>&#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> size;<br>     <span class="hljs-keyword">public</span> Node head;<br><br>     <span class="hljs-comment">/**<br>     * 添加元素<br>     * <span class="hljs-doctag">@param</span> obj<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">add</span><span class="hljs-params">(Object obj)</span></span>&#123;<br>         Node newNode = <span class="hljs-keyword">new</span> Node(obj);<br>         <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)&#123;<br>             head = newNode;<br>             head.next = head;<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>             Node target = head;<br>             <span class="hljs-keyword">while</span>(target.next!=head)&#123;<br>                 target = target.next;<br>             &#125;<br>             target.next = newNode;<br>             newNode.next = head;<br>         &#125;<br>         size++;<br>         <span class="hljs-keyword">return</span> newNode;<br>     &#125;<br><br>     <span class="hljs-comment">/**<br>     * 在指定位置插入元素<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index,Object obj)</span></span>&#123;<br>         <span class="hljs-keyword">if</span>(index &gt;= size)&#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>         &#125;<br>         Node newNode = <span class="hljs-keyword">new</span> Node(obj);<br>         <span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>)&#123;<br>             newNode.next = head;<br>             head = newNode;<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>             Node target = head;<br>             Node previous = head;<br>             <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>             <span class="hljs-keyword">while</span>(pos != index)&#123;<br>                 previous = target;<br>                 target = target.next;<br>                 pos++;<br>             &#125;<br>             previous.next = newNode;<br>             newNode.next = target;<br>         &#125;<br>         size++;<br>         <span class="hljs-keyword">return</span> newNode;<br>     &#125;<br><br>     <span class="hljs-comment">/**<br>     * 删除链表头部元素<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">removeHead</span><span class="hljs-params">()</span></span>&#123;<br>         <span class="hljs-keyword">if</span>(size &gt; <span class="hljs-number">0</span>)&#123;<br>             Node node = head;<br>             Node target = head;<br>             <span class="hljs-keyword">while</span>(target.next!=head)&#123;<br>                 target = target.next;<br>             &#125;<br>             head = head.next;<br>             target.next = head;<br>             size--;<br>             <span class="hljs-keyword">return</span> node;<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>         &#125;<br>     &#125;<br><br>     <span class="hljs-comment">/**<br>     * 删除指定位置元素<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123;<br>         <span class="hljs-keyword">if</span>(index &gt;= size)&#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>         &#125;<br>         Node result = head;<br>         <span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>)&#123;<br>             head = head.next;<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>             Node target = head;<br>             Node previous = head;<br>             <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>             <span class="hljs-keyword">while</span>(pos != index)&#123;<br>                 previous = target;<br>                 target = target.next;<br>                 pos++;<br>             &#125;<br>             previous.next = target.next;<br>             result = target;<br>         &#125;<br>         size--;<br>         <span class="hljs-keyword">return</span> result;<br>     &#125;<br><br>     <span class="hljs-comment">/**<br>     * 删除指定元素<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">removeNode</span><span class="hljs-params">(Object obj)</span></span>&#123;<br>         Node target = head;<br>         Node previoust = head;<br>         <span class="hljs-keyword">if</span>(obj.equals(target.data))&#123;<br>             head = head.next;<br>             size--;<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>             <span class="hljs-keyword">while</span>(target.next!=<span class="hljs-keyword">null</span>)&#123;<br>                 <span class="hljs-keyword">if</span>(obj.equals(target.next.data))&#123;<br>                     previoust = target;<br>                     target = target.next;<br>                     size--;<br>                     <span class="hljs-keyword">break</span>;<br>                 &#125;<span class="hljs-keyword">else</span>&#123;<br>                     target = target.next;<br>                     previoust = previoust.next;<br>                 &#125;<br>             &#125;<br>             previoust.next = target.next;<br>         &#125;<br>         <span class="hljs-keyword">return</span> target;<br>     &#125;<br><br>     <span class="hljs-comment">/**<br>     * 返回指定元素<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">findNode</span><span class="hljs-params">(Object obj)</span></span>&#123;<br>         Node target = head;<br>         <span class="hljs-keyword">while</span>(target.next!=<span class="hljs-keyword">null</span>)&#123;<br>             <span class="hljs-keyword">if</span>(obj.equals(target.data))&#123;<br>                 <span class="hljs-keyword">return</span> target;<br>             &#125;<span class="hljs-keyword">else</span>&#123;<br>                 target = target.next;<br>             &#125;<br>         &#125;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>     &#125;<br><br>     <span class="hljs-comment">/**<br>     * 输出链表元素<br>     */</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>         <span class="hljs-keyword">if</span>(size &gt; <span class="hljs-number">0</span>)&#123;<br>             Node node = head;<br>             <span class="hljs-keyword">int</span> length = size;<br>             System.out.print(<span class="hljs-string">"["</span>);<br>             <span class="hljs-keyword">while</span>(length &gt; <span class="hljs-number">0</span>)&#123;<br>                 <span class="hljs-keyword">if</span>(length == <span class="hljs-number">1</span>)&#123;<br>                     System.out.print(node.data);<br>                 &#125;<span class="hljs-keyword">else</span>&#123;<br>                     System.out.print(node.data+<span class="hljs-string">","</span>);<br>                 &#125;<br>                 node = node.next;<br>                 length--;<br>             &#125;<br>             System.out.println(<span class="hljs-string">"]"</span>);<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>             System.out.println(<span class="hljs-string">"[]"</span>);<br>         &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Python-1"><a href="#Python-1" class="headerlink" title="++Python++"></a>++Python++</h5><p><strong>单向链表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,data = None, next = None)</span>:</span><br>        self.data = data<br>        self.next = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleLinkList</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-string">"""单链表"""</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>        self._head = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""判断链表是否为空"""</span><br>        <span class="hljs-keyword">return</span> self._head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""链表长度"""</span><br>        <span class="hljs-comment"># 初始指针指向head</span><br>        cur = self._head<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 指针指向None 表示到达尾部</span><br>        <span class="hljs-keyword">while</span> cur <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            count += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 指针下移</span><br>            cur = cur.next<br>        <span class="hljs-keyword">return</span> count<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">items</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""遍历链表"""</span><br>        <span class="hljs-comment"># 获取head指针</span><br>        cur = self._head<br>        <span class="hljs-comment"># 循环遍历</span><br>        <span class="hljs-keyword">while</span> cur <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 返回生成器</span><br>            <span class="hljs-keyword">yield</span> cur.item<br>            <span class="hljs-comment"># 指针下移</span><br>            cur = cur.next<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-string">"""向链表头部添加元素"""</span><br>        node = Node(item)<br>        <span class="hljs-comment"># 新结点指针指向原头部结点</span><br>        node.next = self._head<br>        <span class="hljs-comment"># 头部结点指针修改为新结点</span><br>        self._head = node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-string">"""尾部添加元素"""</span><br>        node = Node(item)<br>        <span class="hljs-comment"># 先判断是否为空链表</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-comment"># 空链表，_head 指向新结点</span><br>            self._head = node<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 不是空链表，则找到尾部，将尾部next结点指向新结点</span><br>            cur = self._head<br>            <span class="hljs-keyword">while</span> cur.next <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                cur = cur.next<br>            cur.next = node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, index, item)</span>:</span><br>        <span class="hljs-string">"""指定位置插入元素"""</span><br>        <span class="hljs-comment"># 指定位置在第一个元素之前，在头部插入</span><br>        <span class="hljs-keyword">if</span> index &lt;= <span class="hljs-number">0</span>:<br>            self.add(item)<br>        <span class="hljs-comment"># 指定位置超过尾部，在尾部插入</span><br>        <span class="hljs-keyword">elif</span> index &gt; (self.length() - <span class="hljs-number">1</span>):<br>            self.append(item)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 创建元素结点</span><br>            node = Node(item)<br>            cur = self._head<br>            <span class="hljs-comment"># 循环到需要插入的位置</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(index - <span class="hljs-number">1</span>):<br>                cur = cur.next<br>            node.next = cur.next<br>            cur.next = node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-string">"""删除节点"""</span><br>        cur = self._head<br>        pre = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">while</span> cur <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 找到指定元素</span><br>            <span class="hljs-keyword">if</span> cur.item == item:<br>                <span class="hljs-comment"># 如果第一个就是删除的节点</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pre:<br>                    <span class="hljs-comment"># 将头指针指向头节点的后一个节点</span><br>                    self._head = cur.next<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 将删除位置前一个节点的next指向删除位置的后一个节点</span><br>                    pre.next = cur.next<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 继续按链表后移节点</span><br>                pre = cur<br>                cur = cur.next<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-string">"""查找元素是否存在"""</span><br>        <span class="hljs-keyword">return</span> item <span class="hljs-keyword">in</span> self.items()<br></code></pre></td></tr></table></figure><p><strong>双向链表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-string">"""双向链表的结点"""</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-comment"># item存放数据元素</span><br>        self.item = item<br>        <span class="hljs-comment"># next 指向下一个节点的标识</span><br>        self.next = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># prev 指向上一结点</span><br>        self.prev = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BilateralLinkList</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-string">"""双向链表"""</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>        self._head = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""判断链表是否为空"""</span><br>        <span class="hljs-keyword">return</span> self._head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""链表长度"""</span><br>        <span class="hljs-comment"># 初始指针指向head</span><br>        cur = self._head<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 指针指向None 表示到达尾部</span><br>        <span class="hljs-keyword">while</span> cur <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            count += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 指针下移</span><br>            cur = cur.next<br>        <span class="hljs-keyword">return</span> count<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">items</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""遍历链表"""</span><br>        <span class="hljs-comment"># 获取head指针</span><br>        cur = self._head<br>        <span class="hljs-comment"># 循环遍历</span><br>        <span class="hljs-keyword">while</span> cur <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 返回生成器</span><br>            <span class="hljs-keyword">yield</span> cur.item<br>            <span class="hljs-comment"># 指针下移</span><br>            cur = cur.next<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-string">"""向链表头部添加元素"""</span><br>        node = Node(item)<br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-comment"># 头部结点指针修改为新结点</span><br>            self._head = node<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 新结点指针指向原头部结点</span><br>            node.next = self._head<br>            <span class="hljs-comment"># 原头部 prev 指向 新结点</span><br>            self._head.prev = node<br>            <span class="hljs-comment"># head 指向新结点</span><br>            self._head = node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-string">"""尾部添加元素"""</span><br>        node = Node(item)<br>        <span class="hljs-keyword">if</span> self.is_empty():  <span class="hljs-comment"># 链表无元素</span><br>            <span class="hljs-comment"># 头部结点指针修改为新结点</span><br>            self._head = node<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 链表有元素</span><br>            <span class="hljs-comment"># 移动到尾部</span><br>            cur = self._head<br>            <span class="hljs-keyword">while</span> cur.next <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                cur = cur.next<br>            <span class="hljs-comment"># 新结点上一级指针指向旧尾部</span><br>            node.prev = cur<br>            <span class="hljs-comment"># 旧尾部指向新结点</span><br>            cur.next = node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, index, item)</span>:</span><br>        <span class="hljs-string">""" 指定位置插入元素"""</span><br>        <span class="hljs-keyword">if</span> index &lt;= <span class="hljs-number">0</span>:<br>            self.add(item)<br>        <span class="hljs-keyword">elif</span> index &gt; self.length() - <span class="hljs-number">1</span>:<br>            self.append(item)<br>        <span class="hljs-keyword">else</span>:<br>            node = Node(item)<br>            cur = self._head<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(index):<br>                cur = cur.next<br>            <span class="hljs-comment"># 新结点的向下指针指向当前结点</span><br>            node.next = cur<br>            <span class="hljs-comment"># 新结点的向上指针指向当前结点的上一结点</span><br>            node.prev = cur.prev<br>            <span class="hljs-comment"># 当前上一结点的向下指针指向node</span><br>            cur.prev.next = node<br>            <span class="hljs-comment"># 当前结点的向上指针指向新结点</span><br>            cur.prev = node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-string">""" 删除结点 """</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-keyword">return</span><br>        cur = self._head<br>        <span class="hljs-comment"># 删除元素在第一个结点</span><br>        <span class="hljs-keyword">if</span> cur.item == item:<br>            <span class="hljs-comment"># 只有一个元素</span><br>            <span class="hljs-keyword">if</span> cur.next <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                self._head = <span class="hljs-literal">None</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># head 指向下一结点</span><br>                self._head = cur.next<br>                <span class="hljs-comment"># 下一结点的向上指针指向None</span><br>                cur.next.prev = <span class="hljs-literal">None</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-comment"># 移动指针查找元素</span><br>        <span class="hljs-keyword">while</span> cur.next <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> cur.item == item:<br>                <span class="hljs-comment"># 上一结点向下指针指向下一结点</span><br>                cur.prev.next = cur.next<br>                <span class="hljs-comment"># 下一结点向上指针指向上一结点</span><br>                cur.next.prev = cur.prev<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            cur = cur.next<br>        <span class="hljs-comment"># 删除元素在最后一个</span><br>        <span class="hljs-keyword">if</span> cur.item == item:<br>            <span class="hljs-comment"># 上一结点向下指针指向None</span><br>            cur.prev.next = <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-string">"""查找元素是否存在"""</span><br>        <span class="hljs-keyword">return</span> item <span class="hljs-keyword">in</span> self.items()<br></code></pre></td></tr></table></figure><p><strong>循环链表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-string">"""链表的结点"""</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-comment"># item存放数据元素</span><br>        self.item = item<br>        <span class="hljs-comment"># next是下一个节点的标识</span><br>        self.next = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleCycleLinkList</span><span class="hljs-params">(object)</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>        self._head = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""判断链表是否为空"""</span><br>        <span class="hljs-keyword">return</span> self._head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""链表长度"""</span><br>        <span class="hljs-comment"># 链表为空</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 链表不为空</span><br>        count = <span class="hljs-number">1</span><br>        cur = self._head<br>        <span class="hljs-keyword">while</span> cur.next != self._head:<br>            count += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 指针下移</span><br>            cur = cur.next<br>        <span class="hljs-keyword">return</span> count<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">items</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">""" 遍历链表 """</span><br>        <span class="hljs-comment"># 链表为空</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 链表不为空</span><br>        cur = self._head<br>        <span class="hljs-keyword">while</span> cur.next != self._head:<br>            <span class="hljs-keyword">yield</span> cur.item<br>            cur = cur.next<br>        <span class="hljs-keyword">yield</span> cur.item<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-string">""" 头部添加结点"""</span><br>        node = Node(item)<br>        <span class="hljs-keyword">if</span> self.is_empty():  <span class="hljs-comment"># 为空</span><br>            self._head = node<br>            node.next = self._head<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 添加结点指向head</span><br>            node.next = self._head<br>            cur = self._head<br>            <span class="hljs-comment"># 移动结点，将末尾的结点指向node</span><br>            <span class="hljs-keyword">while</span> cur.next != self._head:<br>                cur = cur.next<br>            cur.next = node<br>        <span class="hljs-comment"># 修改 head 指向新结点</span><br>        self._head = node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-string">"""尾部添加结点"""</span><br>        node = Node(item)<br>        <span class="hljs-keyword">if</span> self.is_empty():  <span class="hljs-comment"># 为空</span><br>            self._head = node<br>            node.next = self._head<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 寻找尾部</span><br>            cur = self._head<br>            <span class="hljs-keyword">while</span> cur.next != self._head:<br>                cur = cur.next<br>            <span class="hljs-comment"># 尾部指针指向新结点</span><br>            cur.next = node<br>            <span class="hljs-comment"># 新结点指针指向head</span><br>            node.next = self._head<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, index, item)</span>:</span><br>        <span class="hljs-string">""" 指定位置添加结点"""</span><br>        <span class="hljs-keyword">if</span> index &lt;= <span class="hljs-number">0</span>:  <span class="hljs-comment"># 指定位置小于等于0，头部添加</span><br>            self.add(item)<br>        <span class="hljs-comment"># 指定位置大于链表长度，尾部添加</span><br>        <span class="hljs-keyword">elif</span> index &gt; self.length() - <span class="hljs-number">1</span>:<br>            self.append(item)<br>        <span class="hljs-keyword">else</span>:<br>            node = Node(item)<br>            cur = self._head<br>            <span class="hljs-comment"># 移动到添加结点位置</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(index - <span class="hljs-number">1</span>):<br>                cur = cur.next<br>            <span class="hljs-comment"># 新结点指针指向旧结点</span><br>            node.next = cur.next<br>            <span class="hljs-comment"># 旧结点指针 指向 新结点</span><br>            cur.next = node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-string">""" 删除一个结点 """</span><br>        <span class="hljs-keyword">if</span> self.is_empty():<br>            <span class="hljs-keyword">return</span><br>        cur = self._head<br>        pre = Node<br>        <span class="hljs-comment"># 第一个元素为需要删除的元素</span><br>        <span class="hljs-keyword">if</span> cur.item == item:<br>            <span class="hljs-comment"># 链表不止一个元素</span><br>            <span class="hljs-keyword">if</span> cur.next != self._head:<br>                <span class="hljs-keyword">while</span> cur.next != self._head:<br>                    cur = cur.next<br>                <span class="hljs-comment"># 尾结点指向 头部结点的下一结点</span><br>                cur.next = self._head.next<br>                <span class="hljs-comment"># 调整头部结点</span><br>                self._head = self._head.next<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 只有一个元素</span><br>                self._head = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 不是第一个元素</span><br>            pre = self._head<br>            <span class="hljs-keyword">while</span> cur.next != self._head:<br>                <span class="hljs-keyword">if</span> cur.item == item:<br>                    <span class="hljs-comment"># 删除</span><br>                    pre.next = cur.next<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">else</span>:<br><br>                    pre = cur  <span class="hljs-comment"># 记录前一个指针</span><br>                    cur = cur.next  <span class="hljs-comment"># 调整指针位置</span><br>        <span class="hljs-comment"># 当删除元素在末尾</span><br>        <span class="hljs-keyword">if</span> cur.item == item:<br>            pre.next = self._head<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-string">""" 查找元素是否存在"""</span><br>        <span class="hljs-keyword">return</span> item <span class="hljs-keyword">in</span> self.items()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.1.数组和链表(1)</title>
      <link href="/2021/11/16/3.1.%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8(1)/"/>
      <url>/2021/11/16/3.1.%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8(1)/</url>
      
        <content type="html"><![CDATA[<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组(Array) 每一个数组元素的位置由数字编号，称为下标或者索引(index)。大多数编程语言的数组第一个元素的下标是 0。</p><p>数组的基本操作：</p><ul><li>Insert - 在某个索引处插入元素</li><li>Get - 读取某个索引处的元素</li><li>Delete - 删除某个索引处的元素</li><li>Size - 获取数组的长度</li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表(Linked List)也是线性结构，它与数组看起来非常像，但是它们的内存分配方式、内部结构和插入删除操作方式都不一样。</p><p>链表是一系列节点组成的链，每一个节点保存了数据以及指向下一个节点的指针。由于是通过指针进行下一个数据元素的查找和访问，使得链表的自由度更高。链表头指针指向第一个节点，如果链表为空，则头指针为空或者为 null。</p><p>这表现在对节点进行<strong>增加和删除时，只需要对上一节点的指针地址进行修改，而无需变动其它的节点</strong>。不过事物皆有两极，指针带来高自由度的同时，自然会<strong>牺牲数据查找的效率和多余空间的使用</strong>。</p><p>链表可以用来实现文件系统、哈希表和邻接表。<br><img src="https://s1.ax1x.com/2020/10/04/08WWY6.png" alt="08WWY6.png"></p><p>链表分为 2 种：</p><ul><li>单向链表</li><li>双向链表</li></ul><p>链表的基本操作</p><ul><li>InsertAtEnd：在链表结尾插入元素</li><li>InsertAtHead：在链表开头插入元素</li><li>Delete：删除链表的指定元素</li><li>DeleteAtHead：删除链表第一个元素</li><li>Search：在链表中查询指定元素</li><li>isEmpty：查询链表是否为空</li></ul><p><img src="https://s1.ax1x.com/2020/10/04/08fmX4.png" alt="08fmX4.png"></p><h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p>从上面的对比中可以看出，链表虽然通过增加指针域提升了自由度，但是却导致数据的查询效率恶化。特别是当链表长度很长的时候，对数据的查询还得从头依次查询，这样的效率会更低。跳表的产生就是为了解决链表过长的问题，通过增加链表的多级索引来加快原始链表的查询效率。这样的方式可以让查询的时间复杂度从O(n)提升至O(logn)。</p><p><img src="https://s1.ax1x.com/2020/10/04/08f1tx.png" alt="08f1tx.png"></p><p>跳表通过增加的多级索引能够实现高效的动态插入和删除，其效率和红黑树和平衡二叉树不相上下。目前redis和levelDB都有用到跳表。</p><p>从上图可以看出，索引级的指针域除了指向下一个索引位置的指针，还有一个down指针指向低一级的链表位置，这样才能实现跳跃查询的目的。</p><h4 id="总结图："><a href="#总结图：" class="headerlink" title="总结图："></a>总结图：</h4><p><img src="https://s1.ax1x.com/2020/10/04/08RJ56.jpg" alt="08RJ56.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2.时间复杂度(2) - 各数据结构时间复杂度和各数组排序算法时间复杂度</title>
      <link href="/2021/11/16/2.2.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6(2)%20-%20%E5%90%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E5%90%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2021/11/16/2.2.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6(2)%20-%20%E5%90%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E5%90%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h4 id="各种数据结构的时间复杂度"><a href="#各种数据结构的时间复杂度" class="headerlink" title="各种数据结构的时间复杂度"></a>各种数据结构的时间复杂度</h4><p><img src="https://s1.ax1x.com/2020/10/01/0KvN4A.png" alt="0KvN4A.png"></p><h4 id="数组排序算法的时间复杂度"><a href="#数组排序算法的时间复杂度" class="headerlink" title="数组排序算法的时间复杂度"></a>数组排序算法的时间复杂度</h4><p><img src="https://s1.ax1x.com/2020/10/01/0Kv0jf.png" alt="0Kv0jf.png"></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1.时间复杂度(1) - 计算和比较</title>
      <link href="/2021/11/16/2.1.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6(1)%20-%20%E8%AE%A1%E7%AE%97%E5%92%8C%E6%AF%94%E8%BE%83/"/>
      <url>/2021/11/16/2.1.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6(1)%20-%20%E8%AE%A1%E7%AE%97%E5%92%8C%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h2 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h2><p>用来度量算法的运行时间，记作: T(n) = O(f(n))。它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。</p><blockquote><p>如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))</p></blockquote><ol><li><p>对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个<br>循环的时间复杂度为 O(n×m)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;         <span class="hljs-comment">// 循环次数为 n</span><br>        printf(<span class="hljs-string">"Hello, World!\n"</span>);      <span class="hljs-comment">// 循环体时间复杂度为 O(1)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时时间复杂度为 O(n × 1)，即 O(n).</p></li><li><p>对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c…，则这个循环的时间复杂度为 O(n×a×b×c…)。分析的时候应该由里向外分析这些循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;         <span class="hljs-comment">// 循环次数为 n</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;       <span class="hljs-comment">// 循环次数为 n</span><br>            printf(<span class="hljs-string">"Hello, World!\n"</span>);      <span class="hljs-comment">// 循环体时间复杂度为 O(1)</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时时间复杂度为 O(n × n × 1)，即 O(n^2)。</p></li><li><p>对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 第一部分时间复杂度为 O(n^2)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            printf(<span class="hljs-string">"Hello, World!\n"</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 第二部分时间复杂度为 O(n)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        printf(<span class="hljs-string">"Hello, World!\n"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。</p></li><li><p>对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 第一条路径时间复杂度为 O(n^2)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                printf(<span class="hljs-string">"输入数据大于等于零\n"</span>);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 第二条路径时间复杂度为 O(n)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            printf(<span class="hljs-string">"输入数据小于零\n"</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。</p></li></ol><p><strong>时间复杂度分析的基本策略是：从内向外分析，从最深层开始分析。如果遇到函数调用，要深入函数进行分析。</strong></p><h4 id="练习一下"><a href="#练习一下" class="headerlink" title="练习一下"></a>练习一下</h4><ol><li>基础题</li></ol><p>求该方法的时间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; n; j++) &#123;<br>            printf(<span class="hljs-string">"Hello World\n"</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考答案：</p><p>当 i = 0 时，内循环执行 n 次运算，当 i = 1 时，内循环执行 n - 1 次运算……当 i = n - 1 时，内循环执行 1 次运算。</p><p>所以，执行次数 T(n) = n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2。<br>根据上文说的 大O推导法 可以知道，此时时间复杂度为 O(n^2)。</p><ol start="2"><li>进阶题</li></ol><p>求该方法的时间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>        i *= <span class="hljs-number">2</span>;<br>        printf(<span class="hljs-string">"%i\n"</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考答案：</p><p>假设循环次数为 t，则循环条件满足 2^t &lt; n。</p><p>可以得出，执行次数t = log(2)(n)，即 T(n) = log(2)(n)，可见时间复杂度为 O(log(2)(n))，即 O(log n)。</p><ol start="3"><li>再次进阶<br>求该方法的时间复杂度<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">aFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> aFunc(n - <span class="hljs-number">1</span>) + aFunc(n - <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>参考答案：</li></ol><p>显然运行次数，T(0) = T(1) = 1，同时 T(n) = T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。</p><p>显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n &gt;= 1 时 T(n) &lt; (5/3)^n，同时当 n &gt; 4 时 T(n) &gt;= (3/2)^n。</p><p>所以该方法的时间复杂度可以表示为 O((5/3)^n)，简化后为 O(2^n)。可见这个方法所需的运行时间是以指数的速度增长的。如果大家感兴趣，可以试下分别用 1，10，100 的输入大小来测试下算法的运行时间。</p><h4 id="总结如下，时间复杂度由低到高"><a href="#总结如下，时间复杂度由低到高" class="headerlink" title="总结如下，时间复杂度由低到高:"></a>总结如下，时间复杂度由低到高:</h4><table><thead><tr><th>执行次数函数</th><th>阶</th><th>名称</th></tr></thead><tbody><tr><td>3</td><td>O(1)</td><td>常数阶</td></tr><tr><td>5log2n+2</td><td>O(logN)</td><td>对数阶</td></tr><tr><td>2n+3</td><td>O(n)</td><td>线性阶</td></tr><tr><td>2n+3nlog2n+1</td><td>O(nlogn)</td><td>nlog2n阶</td></tr><tr><td>3n^2+2n+1</td><td>O(n²))</td><td>平方阶</td></tr><tr><td>6n^3+2n^2+3n+4</td><td>O(n³)</td><td>立方阶</td></tr><tr><td>2^n</td><td>O(2^n)</td><td>指数阶</td></tr><tr><td>n!</td><td>O(n!)</td><td>阶乘阶</td></tr><tr><td>n^n</td><td>O(n^n)</td><td>n^n指数阶</td></tr></tbody></table><h4 id="时间复杂度和运行时间关系图"><a href="#时间复杂度和运行时间关系图" class="headerlink" title="时间复杂度和运行时间关系图"></a>时间复杂度和运行时间关系图</h4><p><img src="https://s1.ax1x.com/2020/10/01/0Kv8BD.png" alt="0Kv8BD.png"></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.数据结构导读升级版</title>
      <link href="/2021/11/16/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%BC%E8%AF%BB%EF%BC%88%E5%8D%87%E7%BA%A7%E7%89%88%EF%BC%89/"/>
      <url>/2021/11/16/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%BC%E8%AF%BB%EF%BC%88%E5%8D%87%E7%BA%A7%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、数据结构的存储方式"><a href="#一、数据结构的存储方式" class="headerlink" title="一、数据结构的存储方式"></a>一、数据结构的存储方式</h3><p><strong>数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）</strong>。</p><p>比如说「队列」、「栈」这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针。</p><p>「图」的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。</p><p>「散列表」就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。</p><p>「树」，用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。</p><p>综上，数据结构种类很多，甚至你也可以发明自己的数据结构，但是底层存储无非数组或者链表，<strong>二者的优缺点如下</strong>：</p><p><strong>数组</strong>由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。</p><p><strong>链表</strong>因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。</p><h3 id="二、数据结构的基本操作"><a href="#二、数据结构的基本操作" class="headerlink" title="二、数据结构的基本操作"></a>二、数据结构的基本操作</h3><p><strong>数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改</strong>。</p><p>我们仍然从最高层来看，各种数据结构的遍历 + 访问无非两种形式：线性的和非线性的。</p><p>线性就是 for/while 迭代为代表，非线性就是递归为代表。再具体一步，无非以下几种框架：</p><p><strong>数组</strong>遍历框架，典型的<strong>线性</strong>迭代结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-comment">// 迭代访问 arr[i]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>链表</strong>遍历框架，兼具迭代和递归结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 基本的单链表节点 */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode next;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (ListNode p = head; p != <span class="hljs-keyword">null</span>; p = p.next) &#123;<br>        <span class="hljs-comment">// 迭代访问 p.val</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归访问 head.val</span><br>    traverse(head.next);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二叉树</strong>遍历框架，典型的<strong>非线性</strong>递归遍历结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 基本的二叉树节点 */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode left, right;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    traverse(root.left);<br>    traverse(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><p>你看二叉树的递归遍历方式和链表的递归遍历方式，相似不？再看看二叉树结构和单链表结构，相似不？如果再多几条叉，N 叉树你会不会遍历？</p><p>二叉树框架可以扩展为 N 叉树的遍历框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 基本的 N 叉树节点 */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode[] children;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (TreeNode child : root.children)<br>        traverse(child);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>N</code> 叉树的遍历又可以扩展为图的遍历，因为图就是好几 <code>N</code> 叉棵树的结合体。你说图是可能出现环的？这个很好办，用个布尔数组 <code>visited</code> 做标记就行了，这里就不写代码了。</p><p><strong>所谓框架，就是套路。不管增删查改，这些代码都是永远无法脱离的结构，你可以把这个结构作为大纲，根据具体问题在框架上添加代码就行了，下面会具体举例</strong>。</p><p><strong>二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题</strong>。</p><p><strong>不要小看这几行破代码，几乎所有二叉树的题目都是一套这个框架就出来了</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">// 前序遍历代码位置</span><br>    traverse(root.left);<br>    <span class="hljs-comment">// 中序遍历代码位置</span><br>    traverse(root.right);<br>    <span class="hljs-comment">// 后序遍历代码位置</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.数据结构导读</title>
      <link href="/2021/11/16/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%BC%E8%AF%BB/"/>
      <url>/2021/11/16/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%BC%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h3><p>（1）集合结构：集合的数据元素没有其他关系，仅仅是因为他们挤在一个被称作“集合”的盒子里。</p><p>（2）线性结构：线性的数据元素结构关系是一对一的，并且是一种先后的次序，就像a-b-c-d-e-f-g·····被一根线穿连起来。</p><p>（3）树形结构：树形的数据元素结构关系是一对多的，这就像公司的部门级别，董事长-CEO\CTO-技术部\人事部\市场部…..。</p><p>（4）图结构：图的数据元素结构关系是多对多的。就是我们常见的各大城市的铁路图，一个城市有很多线路连接不同城市。</p><h3 id="数据的存储（物理）结构"><a href="#数据的存储（物理）结构" class="headerlink" title="数据的存储（物理）结构"></a>数据的存储（物理）结构</h3><p>（1）顺序存储结构：是把数据元素存放在一组存储地址连续的存储单元里，其数据元素间的逻辑关系和物理关系是一致的。</p><p>（2）链式存储结果：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的，数据元素的存储关系并不能反映其逻辑关系，因此需要借助指针来表示数据元素之间的逻辑关系。</p><p><img src="https://s1.ax1x.com/2020/10/04/08R8V1.jpg" alt="08R8V1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0.1.数据类型</title>
      <link href="/2021/11/16/0.1.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2021/11/16/0.1.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java数据类型总结：基本类型、引用类型"><a href="#Java数据类型总结：基本类型、引用类型" class="headerlink" title="Java数据类型总结：基本类型、引用类型"></a>Java数据类型总结：基本类型、引用类型</h1><h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h3><p>基本数据类型只有8种，可按照如下分类</p><p>①整数类型：long、int、short、byte </p><p>②浮点类型：float、double </p><p>③字符类型：char </p><p>④布尔类型：boolean</p><table><thead><tr><th align="left">No.</th><th align="left">数据类型</th><th align="left">大小/位</th><th align="left">可表示数据范围</th><th align="right">默认值</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">byte（字节型）</td><td align="left">8</td><td align="left">-128~127</td><td align="right">0</td></tr><tr><td align="left">2</td><td align="left">short（短整型）</td><td align="left">16</td><td align="left">-32768~32767</td><td align="right">0</td></tr><tr><td align="left">3</td><td align="left">int（整型）</td><td align="left">32</td><td align="left">-2147483648~2147483647</td><td align="right">0</td></tr><tr><td align="left">4</td><td align="left">long（长整型）</td><td align="left">64</td><td align="left">-9223372036854775808~9223372036854775807</td><td align="right">0</td></tr><tr><td align="left">5</td><td align="left">float（单精度）</td><td align="left">32</td><td align="left">-3.4E38~3.4E38</td><td align="right">0.0</td></tr><tr><td align="left">6</td><td align="left">double（双精度）</td><td align="left">64</td><td align="left">-1.7E308~1.7E308</td><td align="right">0.0</td></tr><tr><td align="left">7</td><td align="left">char（字符）</td><td align="left">16</td><td align="left">0~255</td><td align="right">‘\u0000’</td></tr><tr><td align="left">8</td><td align="left">boolean（布尔）</td><td align="left">-</td><td align="left">true或false</td><td align="right">false</td></tr></tbody></table><p>基本类型对应的包装类表如下：</p><table><thead><tr><th align="left">基本类型</th><th align="left">引用类型</th></tr></thead><tbody><tr><td align="left">boolean</td><td align="left">Boolean</td></tr><tr><td align="left">byte</td><td align="left">Byte</td></tr><tr><td align="left">short</td><td align="left">Short</td></tr><tr><td align="left">int</td><td align="left">Integer</td></tr><tr><td align="left">long</td><td align="left">Long</td></tr><tr><td align="left">float</td><td align="left">Float</td></tr><tr><td align="left">double</td><td align="left">Double</td></tr><tr><td align="left">char</td><td align="left">Character</td></tr></tbody></table><p>此外，BigInteger、BigDecimal 用于高精度的运算，BigInteger 支持任意精度的整数，也是引用类型，但它们没有相对应的基本类型。</p><p><strong>Java基本类型存储在栈中，因此它们的存取速度要快于存储在堆中的对应包装类的实例对象。</strong>从Java5.0（1.5）开始，JAVA虚拟机可以完成基本类型和它们对应包装类之间的自动转换。因此我们在赋值、参数传递以及数学运算的时候像使用基本类型一样使用它们的包装类，但这并不意味着你可以通过基本类型调用它们的包装类才具有的方法。另外，所有基本类型（包括void）的包装类都使用了final修饰，因此我们无法继承它们扩展新的类，也无法重写它们的任何方法。</p><p><strong>基本类型的优势</strong>：数据存储相对简单，运算效率比较高</p><p><strong>包装类的优势</strong>：有的容易，比如集合的元素必须是对象类型，满足了java一切皆是对象的思想</p><h3 id="2、引用数据类型"><a href="#2、引用数据类型" class="headerlink" title="2、引用数据类型"></a>2、引用数据类型</h3><p>引用数据类型非常多，大致包括：类、 接口类型、 数组类型、 枚举类型、 注解类型、 字符串型</p><p>例如，String 类型就是引用类型。简单来说，所有的非基本数据类型都是引用数据类型。</p><h5 id="引用类型的特征"><a href="#引用类型的特征" class="headerlink" title="引用类型的特征"></a>引用类型的特征</h5><ul><li>对象、数组都是引用数据类型。</li><li>所有引用类型的默认值都是null。</li><li>一个引用变量可以用来引用任何与之兼容的类型。</li></ul><h2 id="二、基本数据类型和引用数据类型的区别"><a href="#二、基本数据类型和引用数据类型的区别" class="headerlink" title="二、基本数据类型和引用数据类型的区别"></a>二、基本数据类型和引用数据类型的区别</h2><h3 id="1、存储位置"><a href="#1、存储位置" class="headerlink" title="1、存储位置"></a>1、存储位置</h3><p>基本变量类型</p><ul><li>在方法中定义的非全局基本数据类型变量的具体内容是存储在栈中的</li></ul><p>引用变量类型</p><ul><li>只要是引用数据类型变量，其具体内容都是存放在堆中的，而栈中存放的是其具体内容所在内存的地址</li></ul><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwj5at0yvbj31910u0416.jpg" alt="image-20211118113223303" style="zoom: 33%;" /><h3 id="2、传递方式"><a href="#2、传递方式" class="headerlink" title="2、传递方式"></a>2、传递方式</h3><ul><li><p>基本变量类型在方法中定义的非全局基本数据类型变量，调用方法时作为参数是按数值传递的</p></li><li><p>引用数据类型变量，调用方法时作为参数是按引用传递的</p></li></ul><p><strong>基本类型保存的值，引用类型保存了是对象的地址</strong>，所有基本类型赋值是按值传递（拷贝赋值），引用类型赋值是按引用传递。</p><h2 id="三、Java的四种引用类型"><a href="#三、Java的四种引用类型" class="headerlink" title="三、Java的四种引用类型"></a>三、Java的四种引用类型</h2><h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><p>所以在 JDK.1.2 之后，Java 对引用的概念进行了扩充，将引用分为了：</p><ul><li>强引用（Strong Reference）</li><li>软引用（Soft Reference）</li><li>弱引用（Weak Reference）</li><li>虚引用（Phantom Reference）</li></ul><p>这 4 种引用的强度依次减弱；</p><h3 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h3><p>Java中默认声明的就是强引用，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Object obj = <span class="hljs-keyword">new</span> Object(); <span class="hljs-comment">//只要obj还指向Object对象，Object对象就不会被回收</span><br>obj = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">//手动置null</span><br></code></pre></td></tr></table></figure><p><strong>只要强引用存在，垃圾回收器将永远不会回收被引用的对象</strong>，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了；</p><h3 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h3><p>软引用是用来描述一些非必需但仍有用的对象，在内存足够的时候，软引用对象不会被回收，只有 在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等等；</p><p>在JDK1.2 以后，用 <code>java.lang.ref.SoftReference</code>类来表示软引用；</p><p>例子：<a href="https://juejin.cn/post/6884507434036133901" target="_blank" rel="noopener">https://juejin.cn/post/6884507434036133901</a></p><h3 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h3><p>弱引用的引用强度比软引用的强度要更弱一些，<strong>无论内存时候足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收，</strong> 在 JDK1.2 之后，用 <code>java.lang.ref.WeakReference</code>来表示弱引用</p><h3 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h3><p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就跟没有任何引用一样，它随时会被回收，在JDK1.2 之后，用 <code>java.lang.ref.PhantomReference</code> 类表示，通过查看这个类的源码，发现它只有一个构造函数和一个<code>get()</code>  方法，而且它的get 方法仅仅是返回一个 <strong>null</strong> ，也就是说永远无法通过虚引用来获取对象，虚引用必须要和 <code>ReferenceQueue</code>  引用对列一起使用。</p><h3 id="引用队列（ReferenceQueue）"><a href="#引用队列（ReferenceQueue）" class="headerlink" title="引用队列（ReferenceQueue）"></a>引用队列（ReferenceQueue）</h3><p>引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。</p><p>与软引用、弱引用不同，虚引用必须和引用队列一起使用。</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 递归返回 None，为嘛呢?</title>
      <link href="/2020/12/19/Python%20%E9%80%92%E5%BD%92%E8%BF%94%E5%9B%9E%20None%EF%BC%8C%E4%B8%BA%E5%98%9B%E5%91%A2/"/>
      <url>/2020/12/19/Python%20%E9%80%92%E5%BD%92%E8%BF%94%E5%9B%9E%20None%EF%BC%8C%E4%B8%BA%E5%98%9B%E5%91%A2/</url>
      
        <content type="html"><![CDATA[<p>首先，我来写一个简化的递归函数，来做用于解释的案例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ex</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">1</span>:<br>        x -= <span class="hljs-number">1</span><br>        ex(x)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> x<br><br>t = ex(<span class="hljs-number">5</span>)<br>print(t)<br></code></pre></td></tr></table></figure><p>上面的程序逻辑超简单：判断输入的书是否大于 1 ，如果大于 1 则把它减 1 ，然后再判断。如此不断递归下去。当 x 不大于 1 的时候，返回 x 的大小。</p><p>很容易认为返回的 x 打印出来的结果是 1 是不？但是不是的。你可以把上面的代码运行下，打印出来的结果是：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">None</span><br></code></pre></td></tr></table></figure><p>为什么是这样的呢？我的理解是：</p><p>当我们在 t = ex(5) 的时候，调用了一次函数。如果函数直接返回 t = 1，那是木有问题的。问题是，程序在这里返回数据。反而又去调用了一次函数本身。这次调用的的是 ex(4) 然后一直调用的 ex(1) 这时候程序终于运行到了 return 这里。那这次 return 给了谁呢？答案是谁都没有给。因为我们没有设置 t = ex(1)， 所以函数的 return 回的数据就这么丢失了。</p><p>而我们调用的 t = ex(5) 呢，因为它的 if &gt; 1 是成立的，所以直接跳过了了 else: return x ，等于这一次调用，是没有用到 return 的。而在 Python 中规定，如果一个函数体没有 return 的时候，那它的 return 就是 None 。这也就是为什么，我们运行上面的程序的时候，得到的结果是 None 。</p><p>为了证明这点，我们可以去写一个程序，去尝试获得递归到 ex(1) 这次调用时 ex(1) 所返回的值。程序如下：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gml">t = &#123;&#125;<br><br>def ex(<span class="hljs-symbol">x</span>):<br>    <span class="hljs-literal">global</span> t<br>    <span class="hljs-keyword">if</span> <span class="hljs-symbol">x</span> &gt; <span class="hljs-number">1</span>:<br>        <span class="hljs-symbol">x</span> -= <span class="hljs-number">1</span><br>        t[<span class="hljs-symbol">x</span>] = ex(<span class="hljs-symbol">x</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-symbol">x</span><br><br>ex(<span class="hljs-number">10</span>)<br>print(t)<br></code></pre></td></tr></table></figure><p>在程序中，我们用字典，把 ex(x) 每次调用所返回的数据记录了下来。结果如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&#123;<span class="hljs-number">1</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: None, <span class="hljs-number">3</span>: None, <span class="hljs-number">4</span>: None, <span class="hljs-number">5</span>: None, <span class="hljs-number">6</span>: None, <span class="hljs-number">7</span>: None, <span class="hljs-number">8</span>: None, <span class="hljs-number">9</span>: None&#125;<br></code></pre></td></tr></table></figure><p>可见：</p><p>在递归中，后调用的函数先返回。<br>除了最后一次调用的函数有了正确的返回外，之前的函数都没有 return ，所以返回的都是 None。</p><p>那如何正确地返回递归出来的数据呢？答案是：一层一层第把最后一次调用返回出来。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ex</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">1</span>:<br>        x -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ex(x)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> x<br><br>t = ex(<span class="hljs-number">5</span>)<br>print(t)<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>为什么这次能正确呢？因为第一次调用 ex(x) 的时候，它返回的是ex(x-1)，下一次调用返回了 ex(x-2) 一路携手交传，最终把 ex(1) return 给了 t ，这个时候就等于 t = ex(1) 了，自然就得到了正确的结果了。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cheat Sheet</title>
      <link href="/2020/05/19/CheatSheet/"/>
      <url>/2020/05/19/CheatSheet/</url>
      
        <content type="html"><![CDATA[<h1 id="在文件中查找字符串"><a href="#在文件中查找字符串" class="headerlink" title="在文件中查找字符串"></a>在文件中查找字符串</h1><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown">C:\Users\&gt;find /?<br>在文件中搜索字符串。<br><br>FIND [<span class="hljs-string">/V</span>] [<span class="hljs-string">/C</span>] [<span class="hljs-string">/N</span>] [<span class="hljs-string">/I</span>] [<span class="hljs-string">/OFF[LINE</span>]] "string" [<span class="hljs-string">[drive:</span>][<span class="hljs-symbol">path</span>]filename[ ...]]<br><br>  /V         显示所有未包含指定字符串的行。<br>  /C         仅显示包含字符串的行数。<br>  /N         显示行号。<br>  /I         搜索字符串时忽略大小写。<br>  /OFF[LINE] 不要跳过具有脱机属性集的文件。<br>  "string" 指定要搜索的文本字符串。<br>  [<span class="hljs-string">drive:</span>][<span class="hljs-symbol">path</span>]filename 指定要搜索的文件。<br><br> /?          在命令提示符显示帮助。<br></code></pre></td></tr></table></figure><p>例如：<br>要从Pencil.ad 显示包含字符串“Pencil Sharpener”的所有行，请键入：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">find</span> <span class="hljs-string">"Pencil Sharpener"</span> pencil.ad<br></code></pre></td></tr></table></figure><p>比如在D盘根目录下的文本文件test.txt中查找含有 abcd这一字符串的所有行。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">find</span> <span class="hljs-string">"abcd"</span> d:\test.txt<br></code></pre></td></tr></table></figure><h2 id="findstr"><a href="#findstr" class="headerlink" title="findstr"></a>findstr</h2><p>假设您想要找到当前目录和所有子目录中每个包含“computer”这个单词的文件，而不考虑字母的大小写。要列出包含单词“computer”的所有文件，请键入</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">findstr <span class="hljs-string">/s</span> <span class="hljs-string">/i</span> <span class="hljs-string">/m</span> <span class="hljs-string">"\&lt;computer\&gt;"</span> *.*<br></code></pre></td></tr></table></figure><p>当你不知道在哪一个具体的文件中搜索指定字符串的时候，一般命令的格式是这样的：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">findstr <span class="hljs-string">/s</span> <span class="hljs-string">/i</span> <span class="hljs-string">/n</span>  <span class="hljs-string">"abc"</span>  *.*<br></code></pre></td></tr></table></figure><p>意思就是（/s）–&gt;在当前目录及其子目录中的 (<em>.</em>) —&gt;所有格式文件 中搜索含有字符串abc的行 (/i)–&gt;搜索忽略字符串中字母的大小写 (/n)–&gt;并显示改行的行号。</p><h1 id="Remote-Debugging-with-Eclipse-WebSphere-7"><a href="#Remote-Debugging-with-Eclipse-WebSphere-7" class="headerlink" title="Remote Debugging with Eclipse + WebSphere 7"></a>Remote Debugging with Eclipse + WebSphere 7</h1><p><a href="https://mkyong.com/websphere/remote-debugging-with-eclipse-websphere-7/" target="_blank" rel="noopener">https://mkyong.com/websphere/remote-debugging-with-eclipse-websphere-7/</a></p><h1 id="破解工作表加密"><a href="#破解工作表加密" class="headerlink" title="破解工作表加密"></a>破解工作表加密</h1><p><a href="https://zhuanlan.zhihu.com/p/26440785" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26440785</a></p><h1 id="Json-Formatter"><a href="#Json-Formatter" class="headerlink" title="Json Formatter"></a>Json Formatter</h1><p><a href="https://jsonformatter.org/" target="_blank" rel="noopener">https://jsonformatter.org/</a></p><h1 id="MacOS-软件下载"><a href="#MacOS-软件下载" class="headerlink" title="MacOS 软件下载"></a>MacOS 软件下载</h1><p><a href="https://xclient.info/" target="_blank" rel="noopener">https://xclient.info/</a></p><h1 id="重启Win10电脑打印机服务"><a href="#重启Win10电脑打印机服务" class="headerlink" title="重启Win10电脑打印机服务"></a>重启Win10电脑打印机服务</h1><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> stop spooler<br><br><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> spooler<br></code></pre></td></tr></table></figure><h1 id="海量电脑桌面-可选分辨率"><a href="#海量电脑桌面-可选分辨率" class="headerlink" title="海量电脑桌面(可选分辨率)"></a>海量电脑桌面(可选分辨率)</h1><p><a href="https://alphacoders.com/" target="_blank" rel="noopener">https://alphacoders.com/</a></p><p><a href="https://www.wallpaperflare.com/" target="_blank" rel="noopener">https://www.wallpaperflare.com/</a></p><h1 id="无水印高清图"><a href="#无水印高清图" class="headerlink" title="无水印高清图"></a>无水印高清图</h1><p><a href="https://unsplash.com/t/textures-patterns" target="_blank" rel="noopener">https://unsplash.com/t/textures-patterns</a></p><h1 id="好用API合集网站"><a href="#好用API合集网站" class="headerlink" title="好用API合集网站"></a>好用API合集网站</h1><p><a href="https://api.btstu.cn/" target="_blank" rel="noopener">https://api.btstu.cn/</a></p><h1 id="API随机图片"><a href="#API随机图片" class="headerlink" title="API随机图片"></a>API随机图片</h1><p><a href="https://source.unsplash.com/" target="_blank" rel="noopener">https://source.unsplash.com/</a></p><h1 id="通过链接下载视频"><a href="#通过链接下载视频" class="headerlink" title="通过链接下载视频"></a>通过链接下载视频</h1><p><a href="https://www.urlgot.com/" target="_blank" rel="noopener">https://www.urlgot.com/</a></p><h1 id="eclipse解决egit-lock-fail-fetch时"><a href="#eclipse解决egit-lock-fail-fetch时" class="headerlink" title="eclipse解决egit lock fail(fetch时)"></a>eclipse解决egit lock fail(fetch时)</h1><p><a href="https://stackoverflow.com/questions/49859734/egit-lock-fail-eclipse/51058122" target="_blank" rel="noopener">https://stackoverflow.com/questions/49859734/egit-lock-fail-eclipse/51058122</a></p><h1 id="微信朋友圈生成器"><a href="#微信朋友圈生成器" class="headerlink" title="微信朋友圈生成器"></a>微信朋友圈生成器</h1><p><a href="https://www.chatfaker.com/zh-cn/index.html#home" target="_blank" rel="noopener">https://www.chatfaker.com/zh-cn/index.html#home</a></p>]]></content>
      
      
      <categories>
          
          <category> Cheat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cheat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker概念梳理</title>
      <link href="/2020/05/07/Docker%E6%A6%82%E5%BF%B5%E6%A2%B3%E7%90%86/"/>
      <url>/2020/05/07/Docker%E6%A6%82%E5%BF%B5%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Docker好处"><a href="#Docker好处" class="headerlink" title="Docker好处:"></a>Docker好处:</h3><ul><li><strong>一致的运行环境</strong> Docker 的镜像提供了==除内核外==完整的运行时环境，确保了应用运行环境一致性.</li><li><strong>更快速的启动时间</strong> 可以做到秒级、甚至毫秒级的启动时间。</li><li><strong>隔离性</strong> 避免公用的服务器，资源会容易受到其他用户的影响.</li><li><strong>弹性伸缩，快速扩展</strong> 善于处理集中爆发的服务器使用压力.</li><li><strong>迁移方便</strong> 可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</li><li><strong>持续交付和部署</strong> 使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。</li></ul><h3 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h3><ul><li><a href="#Repository">仓库</a>（Repository）</li><li><a href="#Image">镜像</a>（Image）</li><li><a href="#Container">容器</a>（Container）</li><li><a href="#Dockerfile">Dockerfile</a>（Dockerfile）</li><li><a href="#DockerCompose">Docker Compose</a>（Docker Compose）</li></ul><p><img src="https://s1.ax1x.com/2020/05/07/Yeowu9.jpg" alt=""></p><h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a><span id = "Repository">仓库</span></h4><p>集中存放镜像文件的地方。比如：DockerHub</p><h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a><span id = "Image">镜像</span></h4><p>一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p><p>有基础镜像，仅仅包含操作系统，比如centos镜像；有中间件镜像，比如redis等数据库镜像；最后是应用镜像，就是指具体的应用服务了，应用镜像可以非常丰富，随时可以发布，这三者之间依次叠加。</p><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a><span id = "Container">容器</span></h4><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。</p><p>打个比方，你首先下载了一个Ubuntu的镜像，然后又安装mysql和Django应用及其依赖，来完成对它Ubutun镜像的修改，一个个人觉得非常完美应用镜像生成了！就把这个镜像分享给大家使用，大家通过这个镜像就生成一个容器。容器启动之后就会运行Django服务了。<br><img src="https://s1.ax1x.com/2020/05/07/YeTFv4.png" alt=""></p><p>容器就是一个个独立的封闭的集装箱，但是也需要对外提供服务的，所以Docker允许公开容器的特定端口，在启动Docker的时候，我们就可以将容器的特定端口映射到宿主机上面的任意一个端口，所以，如果几个服务都需要80端口，那么容器的对外端口是80，但是映射到宿主机上面就是任意端口，就不会产生冲突，所以就不需要通过代理来解决冲突。容器对外端口与宿主机的端口映射可以通过下面的命令来完成。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -d -p <span class="hljs-number">8081</span>:<span class="hljs-number">80</span> <span class="hljs-comment">--name 容器名 镜像名</span><br><br> -d 守护容器，就是后台运行，退出命令窗口容器也不会停止<br> -<span class="hljs-keyword">it</span> 交互式容器 退出命令窗口容器就停止运行了<br> -p 宿主机端口和容器端口映射<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/05/07/YeTM8O.png" alt=""></p><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a><span id = "Dockerfile">Dockerfile</span></h4><p>一个文本文件，用来配置 image。</p><figure class="highlight Docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Docker"><span class="hljs-comment"># Dockerfile</span><br><br><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">16.04</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> apt-get update</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> apt-get install -y vim</span><br><br><span class="hljs-comment"># 告诉Docker默认启动命令</span><br><span class="hljs-keyword">CMD</span><span class="bash">[<span class="hljs-string">"sh"</span>]</span><br></code></pre></td></tr></table></figure><h4 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a><span id = "DockerCompose">Docker Compose</span></h4><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p><p>docker-compose是编排容器的。例如，你有一个php镜像，一个mysql镜像，一个nginx镜像。如果没有docker-compose，那么每次启动的时候，你需要敲各个容器的启动参数，环境变量，容器命名，指定不同容器的链接参数等等一系列的操作，相当繁琐。而用了docker-composer之后，你就可以把这些命令一次性写在docker-composer.yml文件中，以后每次启动这一整个环境（含3个容器）的时候，你只要敲一个docker-composer up命令就ok了</p><p>Compose 使用的三个步骤：</p><ol><li>使用 Dockerfile 定义应用程序的环境。</li><li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li><li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># yaml 配置实例</span><br><span class="hljs-symbol">version:</span> <span class="hljs-string">'3'</span><br><span class="hljs-symbol">services:</span><br><span class="hljs-symbol">  web:</span><br><span class="hljs-symbol">    build:</span> .<br><span class="hljs-symbol">    ports:</span><br>   - <span class="hljs-string">"5000:5000"</span><br><span class="hljs-symbol">    volumes:</span><br>   - .:/code<br>    - logvolume01:<span class="hljs-meta-keyword">/var/</span>log<br><span class="hljs-symbol">    links:</span><br>   - redis<br><span class="hljs-symbol">  redis:</span><br><span class="hljs-symbol">    image:</span> redis<br><span class="hljs-symbol">volumes:</span><br><span class="hljs-symbol">  logvolume01:</span> &#123;&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker与持续集成</title>
      <link href="/2020/05/07/Docker%E4%B8%8E%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
      <url>/2020/05/07/Docker%E4%B8%8E%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>持续集成和自动部署的原理如下图所示：<br><img src="https://s1.ax1x.com/2020/05/07/Ye7HXQ.png" alt=""></p><ol><li>RD推送代码到git 仓库或者svn等代码服务器上面，git服务器就会通过hook通知jenkins。</li><li>jenkine 克隆git代码到本地，并通过dockerFile文件进行编译 。</li><li>打包生成一个新版本的镜像并推送到仓库 ，删除当前容器 ，通过新版本镜像重新运行。</li><li>而在整个过程中 RD只需要敲入三个命令Git add * ;Git commit –m “”;Git push即可完成持续集成、自动交付、自动部署。</li></ol><p>Docker还可以很方便的自动扩容哦，一般的自动扩容的两种方式，一种就是docker容量扩大，另一种就是docker节点数扩充。第一种就修改配置文件即可，第二种通过简单的拷贝，运行就完成了节点的扩容。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Workaround for oracle weblogic install error —— Cyclic dependency detected among featureset libraries</title>
      <link href="/2020/02/03/Workaround%20for%20oracle%20weblogic%20install%20error/"/>
      <url>/2020/02/03/Workaround%20for%20oracle%20weblogic%20install%20error/</url>
      
        <content type="html"><![CDATA[<h3 id="Brief"><a href="#Brief" class="headerlink" title="Brief"></a>Brief</h3><p>This is the workaround for resolving errors during weblogic installation, below are details and resolving steps.</p><h3 id="1-Problem-description"><a href="#1-Problem-description" class="headerlink" title="1. Problem description"></a>1. Problem description</h3><p>When installing weblogic 12.2.1.4, we may facing the problem during progress ‘Generating Libraries’.</p><p><img src="https://s2.ax1x.com/2020/02/03/1NfFh9.png" alt=""></p><p>The error message is </p><blockquote><p>java.lang.Exception: oracle.sysman.oii.oiif.oiifb.OiifbEndIterateException:<br>com.oracle.cie.gdr.libraries.LibraryHandlerException:<br>Cyclic dependency detected among featureset libraries:<br>[C:\Oracle\Middleware\Oracle_Home\server\lib\wljmsclient.jar,<br>C:\Oracle\Middleware\Oracle_Home\server\lib\wljmxclient.jar]</p></blockquote><h3 id="2-Resolving-steps"><a href="#2-Resolving-steps" class="headerlink" title="2. Resolving steps"></a>2. Resolving steps</h3><blockquote><p>This workaround is a <strong><em>Trick</em></strong> to skip Cyclic dependency check for ‘wljmsclient.jar’ and ‘wljmxclient.jar’, after the installation completed, add back these two libraries.</p></blockquote><ol><li>Go to the install package folder.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1Nhfqf.png" alt=""></p><ol start="2"><li>Unzip the jar file.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NhLMq.png" alt=""></p><ol start="3"><li>Using command line to retrieve string ‘wljmsclient.jar’, ‘wljmxclient.jar’ under the extract folder to get details about this two libraries.<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">findstr <span class="hljs-string">/s</span> <span class="hljs-string">/i</span> <span class="hljs-string">/n</span> <span class="hljs-string">"wljmsclient.jar"</span> *.*<br><br>findstr <span class="hljs-string">/s</span> <span class="hljs-string">/i</span> <span class="hljs-string">/n</span> <span class="hljs-string">"wljmxclient.jar"</span> *.*<br></code></pre></td></tr></table></figure>We can find out that the libraries are referenced in <strong><em>wls_sharedLibraries_12.2.1.4.0.xml</em></strong> under folder <strong><em>~\Disk1\stage\featuresets</em></strong></li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NhzoF.png" alt=""></p><ol start="4"><li>Go to folder <strong><em>~\Disk1\stage\featuresets</em></strong> and find file <strong><em>wls_sharedLibraries_12.2.1.4.0.xml</em></strong></li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1N4VeK.png" alt=""></p><ol start="5"><li>Open the file <strong><em>wls_sharedLibraries_12.2.1.4.0.xml</em></strong> and find lines for libraries ‘wljmsclient.jar’, ‘wljmxclient.jar’.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1N4Jw8.png" alt=""></p><ol start="6"><li>Commented out these lines in xml and save the xml.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1N4DO0.png" alt=""></p><ol start="7"><li>Go back to folder <strong><em>~\Disk1\install</em></strong>, run the <strong><em>.ng.cmd</em></strong> script as administrator</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1N5Jj1.png" alt=""></p><p>The installation cmd is running </p><p><img src="https://s2.ax1x.com/2020/02/03/1NIS29.png" alt=""></p><ol start="8"><li>The weblogic installer will be launched and follow the installation steps. </li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NIpvR.png" alt=""></p><ol start="9"><li>Installation completed successfully.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NIBZV.png" alt=""></p><ol start="10"><li>Go to the target folder, find <strong><em>wls_sharedLibraries_12.2.1.4.0.xml</em></strong> under <strong><em>~/Oracle/Middleware/Oracle_Home/inventory/featuresets</em></strong></li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NoUYD.png" alt=""></p><ol start="11"><li>Open <strong><em>wls_sharedLibraries_12.2.1.4.0.xml</em></strong> and we can find out that libraries info for ‘wljmsclient.jar’, ‘wljmxclient.jar’ are not there (Because we commnet out the code when installation).</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1Nohlj.png" alt=""></p><ol start="12"><li>Add these info back.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NT83Q.png" alt=""></p><ol start="13"><li>Go to  <strong><em>~/Oracle/Middleware/Oracle_Home/wlserver/server/lib</em></strong></li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NTJjs.png" alt=""></p><ol start="14"><li>Compared with <strong><em>successfully installed case</em></strong>, we can know that libraries ‘wlclient.jar’ and ‘wljmxclient.jar’ are missing due to the comment out code. Add these two libraries back to folder. </li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NTz8g.png" alt=""></p><ol start="15"><li><p>I copied these two libraries from a <strong><em>successfully installed case</em></strong>, because I installed weblogic in several machines and only some of them have this  Cyclic dependency check problem, if you don’t have these two libraries in your hands, you can get them from internet.</p><blockquote><p><a href="http://find-files.com/" target="_blank" rel="noopener">http://find-files.com/</a></p></blockquote></li><li><p><strong>Done</strong>.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> workaround </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Weblogic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + GitPages Blog Tutorial(教程)</title>
      <link href="/2019/12/19/Hexo-GitPages-Blog-Tutorial-%E6%95%99%E7%A8%8B/"/>
      <url>/2019/12/19/Hexo-GitPages-Blog-Tutorial-%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Brief"><a href="#Brief" class="headerlink" title="Brief"></a>Brief</h2><p>This tutorial is for building free static blogs by using Hexo and Github Pages. We will start at environments set up, customise blog pages, add source project in version control and install plugins for futher features like comments.</p><h3 id="What-is-Hexo"><a href="#What-is-Hexo" class="headerlink" title="What is Hexo"></a>What is Hexo</h3><p>Hexo is a fast, simple and powerful blog framework. You write posts in <a href="https://en.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">Markdown</a> (or other markup languages) and <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> generates static files with a beautiful theme in seconds.</p><h3 id="What-is-Github-Pages"><a href="#What-is-Github-Pages" class="headerlink" title="What is Github Pages"></a>What is Github Pages</h3><p><a href="https://en.wikipedia.org/wiki/GitHub#GitHub_Pages" target="_blank" rel="noopener">GitHub Pages</a> is a static web hosting service offered by GitHub since 2008 to GitHub users for hosting user blogs, project documentation, or even whole books created as a page.</p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>It only takes less than one hour to set up enviroments and get your first blog page deployed. If you encounter a problem, please refer <a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a></p><h3 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h3><ul><li>Git</li><li>Node.js</li></ul><p>If your computer already has these, congratulations! You can skip to the <a href="#installHexo">install Hexo</a> step.</p><h3 id="Install-Git"><a href="#Install-Git" class="headerlink" title="Install Git"></a>Install Git</h3><ul><li>Windows: Download &amp; install <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>.</li><li>Mac: Install it with <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>, <a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> or <a href="http://www.macports.org/" target="_blank" rel="noopener">installer</a>.</li><li>Linux (Ubuntu, Debian):<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> install git-core<br></code></pre></td></tr></table></figure></li><li>Linux (Fedora, Red Hat, CentOS):<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo yum <span class="hljs-keyword">install</span> git-core<br></code></pre></td></tr></table></figure></li></ul><p>Run CMD check git was installed successfully: <code>git --version</code></p><p><img src="https://s2.ax1x.com/2019/12/19/QquIcd.png" alt=""></p><h3 id="Generate-SSH-Key-for-Github"><a href="#Generate-SSH-Key-for-Github" class="headerlink" title="Generate SSH Key for Github"></a>Generate SSH Key for Github</h3><p>Run git bash from Menu</p><p><img src="https://s2.ax1x.com/2019/12/19/QLZN9J.png" alt=""></p><p>Config your git global settings:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global user.name <span class="hljs-string">"your GitHub username"</span><br>git<span class="hljs-built_in"> config </span>--global user.email <span class="hljs-string">"your GitHub regist email"</span><br></code></pre></td></tr></table></figure><p>Generate ssh key:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">"your GitHub regist email"</span><br></code></pre></td></tr></table></figure><p>Press ‘Enter’ three times, no need password by default, find id_rsa.pub key in generated .ssh folder, copy the whole content in this file.</p><p><a href="https://imgchr.com/i/QLmgOI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/19/QLmgOI.md.jpg" alt=""></a></p><p>Go to github <a href="https://github.com/settings/keys" target="_blank" rel="noopener">setting keys page</a>, click New SSH Key</p><p><a href="https://imgchr.com/i/QLmNO1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/19/QLmNO1.md.png" alt=""></a></p><p>Title can be any value, copy the content of id_rsa.pub into Key, then click Add SSH Key.</p><p>Go to git bash, use command <code>ssh git@github.com</code> to verify the key is successfully configured:</p><p><a href="https://imgchr.com/i/QLn64U" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/19/QLn64U.md.png" alt=""></a></p><h3 id="Install-Node-js"><a href="#Install-Node-js" class="headerlink" title="Install Node.js"></a>Install Node.js</h3><p>Node.js <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Official Installer</a></p><blockquote><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>If you use the official installer, make sure Add to PATH is checked (it’s checked by default).</p></blockquote><blockquote><h4 id="Mac-Linux"><a href="#Mac-Linux" class="headerlink" title="Mac / Linux"></a>Mac / Linux</h4><p>If you encounter EACCES permission error when trying to install Hexo, please follow the <a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally" target="_blank" rel="noopener">workaround</a> provided by npmjs; overriding with root/sudo is highly discouraged.</p></blockquote><p>Run CMD check node.js was installed successfully: <code>node -v</code></p><p><img src="https://s2.ax1x.com/2019/12/19/QqKdbt.png" alt=""></p><p>npm will be installed by default when installing node.js, if not, please install npm also.</p><p>Run CMD check npm was installed successfully: <code>npm -v</code></p><p><img src="https://s2.ax1x.com/2019/12/19/QqMFsA.png" alt=""></p><h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a><span id="installHexo">Install Hexo</span></h3><p>Once all the requirements are installed, you can start to install Hexo.</p><ol><li>Create a folder in your local PC, we will install Hexo frame in this folder and the blog pages will also be published in this folder.</li></ol><p><img src="https://s2.ax1x.com/2019/12/19/QqQPYT.png" alt=""></p><ol start="2"><li><code>Shift + right click</code> in &lt;==MyBlog==&gt; folder. Open command window here.</li></ol><p><img src="https://s2.ax1x.com/2019/12/19/Qqa2fs.jpg" alt=""></p><p>3.Use npm command to install Hexo:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><h3 id="Init-Blog-Files"><a href="#Init-Blog-Files" class="headerlink" title="Init Blog Files"></a>Init Blog Files</h3><p>After the installation finished. Use following command in same &lt;==MyBlog==&gt; folder to init blog:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo init blog</span><br></code></pre></td></tr></table></figure><p>Using following commands to verify the generated blog files</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">new test_my_site</span><br><br><span class="hljs-attr">hexo</span> <span class="hljs-string">g</span><br><br><span class="hljs-attr">hexo</span> <span class="hljs-string">s</span><br></code></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/QLPVzV" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/19/QLPVzV.md.png" alt=""></a></p><p>The blog will run on local server, we can preview it on browser <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p><p><a href="https://imgchr.com/i/QLFFg0" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/19/QLFFg0.md.png" alt=""></a></p><h3 id="Create-Github-Repository"><a href="#Create-Github-Repository" class="headerlink" title="Create Github Repository"></a>Create Github Repository</h3><p>We need to create one Github Pages repository for deploying blog web files. Login github, create a new repository,</p><p><a href="https://imgchr.com/i/QLESED" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/19/QLESED.md.png" alt=""></a></p><p>The ==<username>== in repository name must be exactly same as highlighted your login name:</p><p><a href="https://imgchr.com/i/QLEFgI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/19/QLEFgI.md.png" alt=""></a></p><p>When the repository is created, go to repository settings:</p><p><a href="https://imgchr.com/i/QLuzQJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/19/QLuzQJ.md.png" alt=""></a></p><p>Scroll down the page, config source branch abd choose a theme:</p><p><a href="https://imgchr.com/i/QLKnOA" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/19/QLKnOA.md.png" alt=""></a></p><p>By click the provided link, you can view your github pages in browser.</p><h3 id="Deploy-blog-to-Github-Pages"><a href="#Deploy-blog-to-Github-Pages" class="headerlink" title="Deploy blog to Github Pages"></a>Deploy blog to Github Pages</h3><p>Open the <code>_config.yml</code> file under your blog root folder, update the deploy config as follow:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-attribute">deploy</span>:<br>  <span class="hljs-attribute">type</span>: git<br>  <span class="hljs-attribute">repository</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//github.com/username/username.github.io.git</span><br>  <span class="hljs-attribute">branch</span>: master<br></code></pre></td></tr></table></figure><p>Run CMD in this folder, using npm command to install deployment plugins:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>Then using following three hexo commands to deploy your blog on your github pages:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">clean </span><br><span class="hljs-attr">hexo</span> <span class="hljs-string">g </span><br><span class="hljs-attr">hexo</span> <span class="hljs-string">d</span><br></code></pre></td></tr></table></figure><p>Finally, your can access your blog by url:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">username</span><span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
