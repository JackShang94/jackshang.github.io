<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shang Liang Liang&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-02-21T00:54:33.284Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Shang Liang Liang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Workaround for oracle weblogic install error —— Cyclic dependency detected among featureset libraries</title>
    <link href="http://yoursite.com/2022/02/03/%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91/Workaround%20for%20oracle%20weblogic%20install%20error/"/>
    <id>http://yoursite.com/2022/02/03/%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91/Workaround%20for%20oracle%20weblogic%20install%20error/</id>
    <published>2022-02-03T03:26:38.000Z</published>
    <updated>2022-02-21T00:54:33.284Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Brief"><a href="#Brief" class="headerlink" title="Brief"></a>Brief</h3><p>This is the workaround for resolving errors during weblogic installation, below are details and resolving steps.</p><h3 id="1-Problem-description"><a href="#1-Problem-description" class="headerlink" title="1. Problem description"></a>1. Problem description</h3><p>When installing weblogic 12.2.1.4, we may facing the problem during progress ‘Generating Libraries’.</p><p><img src="https://s2.ax1x.com/2020/02/03/1NfFh9.png" alt=""></p><p>The error message is </p><blockquote><p>java.lang.Exception: oracle.sysman.oii.oiif.oiifb.OiifbEndIterateException:<br>com.oracle.cie.gdr.libraries.LibraryHandlerException:<br>Cyclic dependency detected among featureset libraries:<br>[C:\Oracle\Middleware\Oracle_Home\server\lib\wljmsclient.jar,<br>C:\Oracle\Middleware\Oracle_Home\server\lib\wljmxclient.jar]</p></blockquote><h3 id="2-Resolving-steps"><a href="#2-Resolving-steps" class="headerlink" title="2. Resolving steps"></a>2. Resolving steps</h3><blockquote><p>This workaround is a <strong><em>Trick</em></strong> to skip Cyclic dependency check for ‘wljmsclient.jar’ and ‘wljmxclient.jar’, after the installation completed, add back these two libraries.</p></blockquote><ol><li>Go to the install package folder.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1Nhfqf.png" alt=""></p><ol start="2"><li>Unzip the jar file.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NhLMq.png" alt=""></p><ol start="3"><li>Using command line to retrieve string ‘wljmsclient.jar’, ‘wljmxclient.jar’ under the extract folder to get details about this two libraries.<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">findstr <span class="hljs-string">/s</span> <span class="hljs-string">/i</span> <span class="hljs-string">/n</span> <span class="hljs-string">"wljmsclient.jar"</span> *.*<br><br>findstr <span class="hljs-string">/s</span> <span class="hljs-string">/i</span> <span class="hljs-string">/n</span> <span class="hljs-string">"wljmxclient.jar"</span> *.*<br></code></pre></td></tr></table></figure>We can find out that the libraries are referenced in <strong><em>wls_sharedLibraries_12.2.1.4.0.xml</em></strong> under folder <strong><em>~\Disk1\stage\featuresets</em></strong></li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NhzoF.png" alt=""></p><ol start="4"><li>Go to folder <strong><em>~\Disk1\stage\featuresets</em></strong> and find file <strong><em>wls_sharedLibraries_12.2.1.4.0.xml</em></strong></li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1N4VeK.png" alt=""></p><ol start="5"><li>Open the file <strong><em>wls_sharedLibraries_12.2.1.4.0.xml</em></strong> and find lines for libraries ‘wljmsclient.jar’, ‘wljmxclient.jar’.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1N4Jw8.png" alt=""></p><ol start="6"><li>Commented out these lines in xml and save the xml.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1N4DO0.png" alt=""></p><ol start="7"><li>Go back to folder <strong><em>~\Disk1\install</em></strong>, run the <strong><em>.ng.cmd</em></strong> script as administrator</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1N5Jj1.png" alt=""></p><p>The installation cmd is running </p><p><img src="https://s2.ax1x.com/2020/02/03/1NIS29.png" alt=""></p><ol start="8"><li>The weblogic installer will be launched and follow the installation steps. </li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NIpvR.png" alt=""></p><ol start="9"><li>Installation completed successfully.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NIBZV.png" alt=""></p><ol start="10"><li>Go to the target folder, find <strong><em>wls_sharedLibraries_12.2.1.4.0.xml</em></strong> under <strong><em>~/Oracle/Middleware/Oracle_Home/inventory/featuresets</em></strong></li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NoUYD.png" alt=""></p><ol start="11"><li>Open <strong><em>wls_sharedLibraries_12.2.1.4.0.xml</em></strong> and we can find out that libraries info for ‘wljmsclient.jar’, ‘wljmxclient.jar’ are not there (Because we commnet out the code when installation).</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1Nohlj.png" alt=""></p><ol start="12"><li>Add these info back.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NT83Q.png" alt=""></p><ol start="13"><li>Go to  <strong><em>~/Oracle/Middleware/Oracle_Home/wlserver/server/lib</em></strong></li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NTJjs.png" alt=""></p><ol start="14"><li>Compared with <strong><em>successfully installed case</em></strong>, we can know that libraries ‘wlclient.jar’ and ‘wljmxclient.jar’ are missing due to the comment out code. Add these two libraries back to folder. </li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NTz8g.png" alt=""></p><ol start="15"><li><p>I copied these two libraries from a <strong><em>successfully installed case</em></strong>, because I installed weblogic in several machines and only some of them have this  Cyclic dependency check problem, if you don’t have these two libraries in your hands, you can get them from internet.</p><blockquote><p><a href="http://find-files.com/" target="_blank" rel="noopener">http://find-files.com/</a></p></blockquote></li><li><p><strong>Done</strong>.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Brief&quot;&gt;&lt;a href=&quot;#Brief&quot; class=&quot;headerlink&quot; title=&quot;Brief&quot;&gt;&lt;/a&gt;Brief&lt;/h3&gt;&lt;p&gt;This is the workaround for resolving errors during weblogi
      
    
    </summary>
    
    
      <category term="workaround" scheme="http://yoursite.com/categories/workaround/"/>
    
    
      <category term="Weblogic" scheme="http://yoursite.com/tags/Weblogic/"/>
    
  </entry>
  
  <entry>
    <title>9.1 B树,B+树插入删除图解 (copy)</title>
    <link href="http://yoursite.com/2022/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9.1%20B%E6%A0%91,B+%E6%A0%91%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%9B%BE%E8%A7%A3/"/>
    <id>http://yoursite.com/2022/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9.1%20B%E6%A0%91,B+%E6%A0%91%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%9B%BE%E8%A7%A3/</id>
    <published>2022-01-25T04:39:39.000Z</published>
    <updated>2022-02-21T00:54:33.380Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-2-B树插入"><a href="#1-2-B树插入" class="headerlink" title="1.2 B树插入"></a>1.2 B树插入</h4><p>插入的时候，我们需要记住一个规则：<strong>判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。</strong></p><p>例子：在5阶B树中，结点最多有4个key,最少有2个key（注意：下面的节点统一用一个节点表示key和value）。</p><ul><li>插入18，70，50,40</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak8eo65j309h02njra.jpg" alt="img"></p><ul><li>插入22</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nns376j309t02t3yg.jpg" alt="img"></p><p>插入22时，发现这个节点的关键字已经大于4了，所以需要进行分裂，分裂的规则在上面已经讲了，分裂之后，如下。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5np2pe3j30cj05z3yp.jpg" alt="img"></p><ul><li>接着插入23，25，39</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akfwv3cj30g605e74l.jpg" alt="img"></p><p>分裂，得到下面的。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akb91a7j30fv07m0t7.jpg" alt="img"></p><p>更过的插入的过程就不多介绍了，相信有这个例子你已经知道怎么进行插入操作了。</p><h4 id="1-3-B树的删除操作"><a href="#1-3-B树的删除操作" class="headerlink" title="1.3 B树的删除操作"></a>1.3 B树的删除操作</h4><p>B树的删除操作相对于插入操作是相对复杂一些的，但是，你知道记住几种情况，一样可以很轻松的掌握的。</p><ul><li>现在有一个初始状态是下面这样的B树，然后进行删除操作。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akffpjfj30kc09eaay.jpg" alt="img"></p><ul><li>删除15，这种情况是删除叶子节点的元素，如果删除之后，节点数还是大于<code>m/2</code>，这种情况只要直接删除即可。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak7xn76j30kc09zwfg.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak9ef0bj30kc097t9l.jpg" alt="img"></p><ul><li>接着，我们把22删除，这种情况的规则：22是非叶子节点，<strong>对于非叶子节点的删除，我们需要用后继key（元素）覆盖要删除的key，然后在后继key所在的子支中删除该后继key</strong>。对于删除22，需要将后继元素24移到被删除的22所在的节点。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akd800oj30kc0bd3zo.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak7p8itj30kc092756.jpg" alt="img"></p><p>此时发现26所在的节点只有一个元素，小于2个（m/2），这个节点不符合要求，这时候的规则（向兄弟节点借元素）：<strong>如果删除叶子节点，如果删除元素后元素个数少于（m/2），并且它的兄弟节点的元素大于（m/2），也就是说兄弟节点的元素比最少值m/2还多，将先将父节点的元素移到该节点，然后将兄弟节点的元素再移动到父节点</strong>。这样就满足要求了。</p><p>我们看看操作过程就更加明白了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akc4688j30kc092q3x.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akex9s6j30kc094dgp.jpg" alt="img"></p><ul><li>接着删除28，<strong>删除叶子节点</strong>，删除后不满足要求，所以，我们需要考虑向兄弟节点借元素，但是，兄弟节点也没有多的节点（2个），借不了，怎么办呢？如果遇到这种情况，<strong>首先，还是将先将父节点的元素移到该节点，然后，将当前节点及它的兄弟节点中的key合并，形成一个新的节点</strong>。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ake1o66j30kc0arab4.jpg" alt="img"></p><p>移动之后，跟兄弟节点合并。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akastxfj30kc09qaax.jpg" alt="img"></p><p>删除就只有上面的几种情况，根据不同的情况进行删除即可。</p><p>上面的这些介绍，相信对于B树已经有一定的了解了，接下来的一部分，我们接着讲解B+树，我相信加上B+树的对比，就更加清晰明了了。</p><h3 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2 B+树"></a>2 B+树</h3><h4 id="2-1-B-树概述"><a href="#2-1-B-树概述" class="headerlink" title="2.1 B+树概述"></a>2.1 B+树概述</h4><p>B+树其实和B树是非常相似的，我们首先看看<strong>相同点</strong>。</p><ul><li>根节点至少一个元素</li><li>非根节点元素范围：m/2 &lt;= k &lt;= m-1</li></ul><p><strong>不同点</strong>。</p><ul><li>B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。</li><li>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。</li><li>每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。</li><li>父节点存有右孩子的第一个元素的索引。</li></ul><p>下面我们看一个B+树的例子，感受感受它吧！</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak9u8sdj30hg09yjs9.jpg" alt="img"></p><h4 id="2-2-插入操作"><a href="#2-2-插入操作" class="headerlink" title="2.2 插入操作"></a>2.2 插入操作</h4><p>对于插入操作很简单，只需要记住一个技巧即可：<strong>当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的</strong>。</p><p>下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。</p><ul><li>插入5，10，15，20</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nstlpxj309s04agll.jpg" alt="img"></p><ul><li>插入25，此时元素数量大于4个了，分裂</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akckyvaj30f206q74l.jpg" alt="img"></p><ul><li>接着插入26，30，继续分裂</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akbns2mj30gq0650t2.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akegiwcj30j306xjrw.jpg" alt="img"></p><p>有了这几个例子，相信插入操作没什么问题了，下面接着看看删除操作。</p><h4 id="2-3-删除操作"><a href="#2-3-删除操作" class="headerlink" title="2.3 删除操作"></a>2.3 删除操作</h4><p>对于删除操作是比B树简单一些的，因为<strong>叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key</strong>，下面我们看看具体的实例。</p><ul><li>初始状态</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akdj5t5j30kc06rq3l.jpg" alt="img"></p><ul><li>删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak8xabpj30kc06s3z5.jpg" alt="img"></p><ul><li>删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akaazg0j30kc07w3z7.jpg" alt="img"></p><ul><li>发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nv4474j30kc080t9g.jpg" alt="img"></p><p>这样，B+树的删除操作也就完成了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-2-B树插入&quot;&gt;&lt;a href=&quot;#1-2-B树插入&quot; class=&quot;headerlink&quot; title=&quot;1.2 B树插入&quot;&gt;&lt;/a&gt;1.2 B树插入&lt;/h4&gt;&lt;p&gt;插入的时候，我们需要记住一个规则：&lt;strong&gt;判断当前结点key的个数是否小于等于m-1
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>9.0 B树,B+树,B*树</title>
    <link href="http://yoursite.com/2022/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9.0%20B%E6%A0%91,B+%E6%A0%91,B*%E6%A0%91/"/>
    <id>http://yoursite.com/2022/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9.0%20B%E6%A0%91,B+%E6%A0%91,B*%E6%A0%91/</id>
    <published>2022-01-25T04:38:39.000Z</published>
    <updated>2022-02-21T00:54:33.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><h2 id="B-树概述"><a href="#B-树概述" class="headerlink" title="B-树概述"></a>B-树概述</h2><p>B-树,这里的 B 表示 balance( 平衡的意思),B-树是一种多路自平衡的搜索树（B树是<strong>一颗多路平衡查找树</strong>）<br>它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。下图是 B-树的简化图.</p><p><img src="https:////upload-images.jianshu.io/upload_images/1446087-bc023e47bc74cfa1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p><h2 id="为什么数据库s需要用B树，而不是用AVL树，二叉树？"><a href="#为什么数据库s需要用B树，而不是用AVL树，二叉树？" class="headerlink" title="为什么数据库s需要用B树，而不是用AVL树，二叉树？"></a>为什么数据库s需要用B树，而不是用AVL树，二叉树？</h2><p>传统用来搜索的平衡二叉树有很多，如 AVL 树，红黑树等。这些树在一般情况下查询性能非常好，但当数据非常大的时候它们就无能为力了。<strong>原因当数据量非常大时，内存不够用，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。</strong>一般而言内存访问的时间约为 50 ns，而磁盘在 10 ms 左右。速度相差了近 5 个数量级，磁盘读取时间远远超过了数据在内存中比较的时间。这说明程序大部分时间会阻塞在磁盘 IO 上。</p><p><strong>B-树是专门为外部存储器设计的，如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中。</strong></p><h2 id="B树规则："><a href="#B树规则：" class="headerlink" title="B树规则："></a>B树规则：</h2><p>（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则（类似AVL）。</p><p>（2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外。（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</p><p>（3）关键字数：枝节点的<strong>关键字数量大于等于ceil(m/2)-1个且小于等于M-1个</strong>（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</p><p>（4）<strong>所有叶子节点均在同一层</strong>、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null。</p><h3 id="如：（M-3）"><a href="#如：（M-3）" class="headerlink" title="如：（M=3）"></a>如：（M=3）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6aimasktj30hc07gmxn.jpg" alt="img"></p><h2 id="B树有如下特点"><a href="#B树有如下特点" class="headerlink" title="B树有如下特点:"></a>B树有如下特点:</h2><ol><li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；</li><li>在关键字全集内做一次查找,性能逼近二分查找；</li><li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li><li>自动层次控制；</li></ol><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><h2 id="B-树的定义"><a href="#B-树的定义" class="headerlink" title="B+树的定义"></a>B+树的定义</h2><p><strong>B+树是应文件系统所需而出的一种B-树的变型树。一棵m阶的B+树和m阶的B-树的差异在于：</strong></p><p>1.有n棵子树的结点中含有n个关键字，<strong>==每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点==</strong>。</p><p>2.<strong>所有的叶子结点中包含了全部关键字的信息</strong>，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p>3.所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</p><h2 id="B-树规则："><a href="#B-树规则：" class="headerlink" title="B+树规则："></a>B+树规则：</h2><p>（1）B+跟B树不同B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</p><p>（2）B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有关键字都在叶子结点出现；所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</p><p>（3）B+树叶子节点的关键字从小到大有序排列，<strong>左边结尾数据都会保存右边节点开始数据的指针</strong>。</p><p>（4）<strong>非叶子节点的子节点数=关键字数（来源百度百科）</strong>（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</p><h3 id="如：（M-3）-1"><a href="#如：（M-3）-1" class="headerlink" title="如：（M=3）"></a>如：（M=3）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ailuqs1j30ft09lgmd.jpg" alt="img"></p><p>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在</p><p>非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p><h2 id="B-的特性："><a href="#B-的特性：" class="headerlink" title="B+的特性："></a>B+的特性：</h2><p>1、B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</p><p>2、B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p><p>3、B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</p><p>4、B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p><h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h1><p><strong>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ailnqmvj30ft09l0tk.jpg" alt="img"></p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a><strong>规则</strong></h2><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p><p>（1）首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b<em>树的初始化个数为（cei(2/3</em>m)）</p><p>（2）B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h2><p>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；</p><h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><p><strong>B-树：</strong></p><p>多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；</p><p>所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p><p><strong>B+树：</strong></p><p>在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；</p><p>B+树总是到叶子结点才命中；</p><p><strong>B*树：</strong></p><p>在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;B树&quot;&gt;&lt;a href=&quot;#B树&quot; class=&quot;headerlink&quot; title=&quot;B树&quot;&gt;&lt;/a&gt;B树&lt;/h1&gt;&lt;h2 id=&quot;B-树概述&quot;&gt;&lt;a href=&quot;#B-树概述&quot; class=&quot;headerlink&quot; title=&quot;B-树概述&quot;&gt;&lt;/a&gt;B-树概
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>8.2.哈希冲突与解决(拉链法,线性探测法)</title>
    <link href="http://yoursite.com/2022/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.2.%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E4%B8%8E%E8%A7%A3%E5%86%B3(%E6%8B%89%E9%93%BE%E6%B3%95,%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95)/"/>
    <id>http://yoursite.com/2022/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.2.%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E4%B8%8E%E8%A7%A3%E5%86%B3(%E6%8B%89%E9%93%BE%E6%B3%95,%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95)/</id>
    <published>2022-01-22T14:38:39.000Z</published>
    <updated>2022-02-21T00:54:33.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希冲突与解决-拉链法-线性探测法"><a href="#哈希冲突与解决-拉链法-线性探测法" class="headerlink" title="哈希冲突与解决(拉链法,线性探测法)"></a>哈希冲突与解决(拉链法,线性探测法)</h1><p>参考：<a href="https://blog.csdn.net/u012124438/article/details/78230478" target="_blank" rel="noopener">https://blog.csdn.net/u012124438/article/details/78230478</a></p><h2 id="1-线性探测-vs-拉链法"><a href="#1-线性探测-vs-拉链法" class="headerlink" title="1. 线性探测 vs 拉链法"></a>1. 线性探测 vs 拉链法</h2><p>开放寻址法和链表法。这两种冲突解决办法在实际的软件开发中都非常常用。比如，LinkedHashMap 就采用了链表法解决冲突，ThreadLocalMap 是通过线性探测的开放寻址法来解决冲突。那你知道，这两种冲突解决方法各有什么优势和劣势，又各自适用哪些场景吗？</p><p><strong>（1）开放寻址法优缺点</strong></p><ul><li>开放寻址法优点：<ul><li>散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。</li><li>数组实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没那么容易。你可不要小看序列化，很多场合都会用到的。</li></ul></li><li>开放寻址法缺点：<ul><li>用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。</li><li>在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。</li><li>装载因子的上限不能太大，导致这种方法比链表法更浪费内存空间。</li></ul></li></ul><p><strong>总结：</strong> <strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法。</strong>这也是 ThreadLocalMap 使用开放寻址法解决散列冲突的原因。</p><p><strong>（2）拉链法优缺点</strong></p><ul><li>拉链法优点：<ul><li>首先，链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。</li><li>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</li><li>可以将链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。</li></ul></li><li>拉链法缺点：<ul><li>链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。但如果我们存储的是大对象，此时存储对象远远大于指针大小（4 byte 或 8 byte），那链表中指针的内存消耗在大对象面前就可以忽略了。</li><li>因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。</li></ul></li></ul><p><strong>总结：</strong> <strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表。</strong>而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈希冲突与解决-拉链法-线性探测法&quot;&gt;&lt;a href=&quot;#哈希冲突与解决-拉链法-线性探测法&quot; class=&quot;headerlink&quot; title=&quot;哈希冲突与解决(拉链法,线性探测法)&quot;&gt;&lt;/a&gt;哈希冲突与解决(拉链法,线性探测法)&lt;/h1&gt;&lt;p&gt;参考：&lt;a hr
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>8.1.哈希表(散列表)</title>
    <link href="http://yoursite.com/2022/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.1.%E5%93%88%E5%B8%8C%E8%A1%A8(%E6%95%A3%E5%88%97%E8%A1%A8)/"/>
    <id>http://yoursite.com/2022/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.1.%E5%93%88%E5%B8%8C%E8%A1%A8(%E6%95%A3%E5%88%97%E8%A1%A8)/</id>
    <published>2022-01-22T14:37:39.000Z</published>
    <updated>2022-02-21T00:54:33.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="散列表-哈希表"><a href="#散列表-哈希表" class="headerlink" title="散列表(哈希表)"></a><strong>散列表(哈希表)</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>散列表也叫哈希表，是一种通过键值对直接访问数据的机构。<strong>借助散列函数对数组进行扩展，利用的是数组支持按照下标随机访问元素的特性。</strong>散列表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。散列函数有 MD5、SHA、CRC 等哈希算法。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmuu8vpaxj31200eodh1.jpg" alt="image-20211121163245049"></p><p>散列表的实现最关键的就是散列函数的定义和选择。</p><h2 id="2-散列函数"><a href="#2-散列函数" class="headerlink" title="2. 散列函数"></a>2. 散列函数</h2><p>什么才是好的散列函数：</p><ul><li><strong>散列函数的设计不能太复杂</strong>。过于复杂的散列函数，势必会占用更多 CPU，也就间接的影响到散列表的性能。</li><li><strong>散列函数生成的值要尽可能随机并且均匀分布</strong>。这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</li></ul><p><strong>一般常用的有以下几种散列函数：</strong></p><h3 id="2-1-直接定址法"><a href="#2-1-直接定址法" class="headerlink" title="2.1 直接定址法"></a>2.1 直接定址法</h3><blockquote><p>取关键字或关键字的某个线性函数值为散列地址。</p><p>关键码本身和地址之间存在某个线性函数关系时，散列函数取为关键码的线性函数，即：<code>hash(key) = a * key + b</code>（a、b 均为常数）。</p><p>这样的散列函数优点就是简单、均匀，也不会产生冲突，但问题是这需要事先知道关键字的分布情况，适合査找表较小且连续的情况。由于这样的限制，<strong>在现实应用中虽然简单，但却并不常用</strong>。</p></blockquote><h3 id="2-2-余数法"><a href="#2-2-余数法" class="headerlink" title="2.2 余数法"></a>2.2 <strong>余数法</strong></h3><blockquote><p>通过选择适当的正整数 p，按计算公式 <code>hash(K) = K % p</code> 来计算关键码 K 的散列地址。这种方法计算最简单，也不需根据全部关键码的分布情况研究如何从中析取数据，<strong>最常用</strong>。这种方式也可以在用过其他方法后再使用。该函数对 p 的选择很重要，一般取素数或者直接用 n。</p></blockquote><h3 id="2-3-平方取中法"><a href="#2-3-平方取中法" class="headerlink" title="2.3 平方取中法"></a>2.3 平方取中法</h3><blockquote><p>当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</p><p>将关键码 K 平方，取 K^2 中间几位作为其散列地址 hash(K) 的值。</p><p>假如有以下关键字序列 {421，423，436}，平方之后的结果为 {177241，178929，190096}，那么可以取 {72，89，00} 作为 Hash 地址。</p></blockquote><h3 id="2-4-随机数法"><a href="#2-4-随机数法" class="headerlink" title="2.4 随机数法"></a>2.4 随机数法</h3><blockquote><p>采用随机函数作为散列函数 <code>hash(Key) = random(Key)</code>，其中 random 为随机函数。<strong>当关键码长度不等时，采用该方法较恰当。</strong></p></blockquote><h3 id="2-5-数字分析法："><a href="#2-5-数字分析法：" class="headerlink" title="2.5 数字分析法："></a><strong>2.5 数字分析法</strong>：</h3><blockquote><p>通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。 </p></blockquote><h2 id="3-散列冲突"><a href="#3-散列冲突" class="headerlink" title="3. 散列冲突"></a><strong>3. 散列冲突</strong></h2><p>确定好散列函数之后，通过某个<code>key</code>值的确会得到一个唯一的<code>value</code>地址。但是却会出现一些特殊情况。<strong>即通过不同的<code>key</code>值可能会访问到同一个地址，这个现象称之为冲突。</strong></p><p>冲突在发生之后，当在对不同的<code>key</code>值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。</p><p>常用的冲突处理方式有很多，常用的包括以下几种：</p><h3 id="3-1-开放地址法（也叫开放寻址法）："><a href="#3-1-开放地址法（也叫开放寻址法）：" class="headerlink" title="3.1 开放地址法（也叫开放寻址法）："></a><strong>3.1 开放地址法</strong>（也叫开放寻址法）：</h3><p>如果出现了散列冲突，就重新探测一个空闲位置。根据重新探测的方式，又可以分为线性探测、二次探测、双重哈希三种。</p><ul><li><strong>线性探测(Linear Probing)</strong>：从发生冲突位置依次往后查找空闲位置。线性探测会导致数据集中到某一块区域。</li><li><strong>二次探测(Quadratic probing)</strong>：如果说线性探测每次探测的步长是 1，即线性探测的下标序列就是 hash(key) + 0，hash(key) + 1，hash(key) + 2……。而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key) + 02，hash(key) + 12，hash(key) + 22……。</li><li><strong>双重哈希(Double hashing)</strong>：前面的两种探测方式都只使用一个散列函数，而双重哈希则会使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。这种方式的缺点是时间增加了。 </li></ul><h3 id="3-2-链地址法："><a href="#3-2-链地址法：" class="headerlink" title="3.2 链地址法："></a><strong>3.2 链地址法</strong>：</h3><p>链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。使用链表将所有散列值相同的元素我们都放到相同槽位对应的链表中。当然，这个链表可能为简单链表，也可能是红黑树，如 HahMap。</p><p>==<strong>目前比较常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的</strong>==。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmuussdnij314k0l640l.jpg" alt="image-20211121163316703"></p><p>左侧数组的每个成员包括一个指针，指向一个链表的头。每发生一个冲突的数据，就将该数据作为链表的节点链接到链表尾部。这样一来，就可以保证冲突的数据能够区分并顺利访问。</p><p>考虑到链表过长造成的问题，还可以<strong>使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性</strong>。</p><h3 id="3-3-公共溢出区："><a href="#3-3-公共溢出区：" class="headerlink" title="3.3 公共溢出区："></a><strong>3.3 公共溢出区</strong>：</h3><p>这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。很少用。</p><p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子来表示空位的多少。<strong>装载因子（load factor）</strong>的计算公式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">散列表的装载因子 &#x3D; 表中的元素个数 &#x2F; 散列表的长度<br></code></pre></td></tr></table></figure><p>实例参考： <a href="https://www.jianshu.com/p/a89e9487a06c" target="_blank" rel="noopener">https://www.jianshu.com/p/a89e9487a06c</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;散列表-哈希表&quot;&gt;&lt;a href=&quot;#散列表-哈希表&quot; class=&quot;headerlink&quot; title=&quot;散列表(哈希表)&quot;&gt;&lt;/a&gt;&lt;strong&gt;散列表(哈希表)&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; clas
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>7.6.图的最短路径(Djkstra, Floyd)</title>
    <link href="http://yoursite.com/2022/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.6.%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(Djkstra,%20Floyd)/"/>
    <id>http://yoursite.com/2022/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.6.%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(Djkstra,%20Floyd)/</id>
    <published>2022-01-20T14:36:39.000Z</published>
    <updated>2022-02-21T00:54:33.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径-Djkstra-Floyd"><a href="#最短路径-Djkstra-Floyd" class="headerlink" title="最短路径(Djkstra, Floyd)"></a>最短路径(Djkstra, Floyd)</h1><h2 id="迪杰斯特拉算法介绍"><a href="#迪杰斯特拉算法介绍" class="headerlink" title="迪杰斯特拉算法介绍"></a><strong>迪杰斯特拉算法介绍</strong></h2><p>Dijkstra算法功能：给出<strong>加权连通图</strong>中一个顶点，称之为起点，找出起点到其它所有顶点之间的最短距离。</p><p>它的主要特点是以起始点为中心向外层层扩展(BFS广度优先搜索思想)，直到扩展到终点为止。</p><p><strong>基本思想</strong></p><p>   通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。</p><p>   此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。</p><p>   初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。</p><p><strong>操作步骤</strong></p><p><strong>(1)</strong> 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。</p><p><strong>(2)</strong> 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。</p><p><strong>(3)</strong> 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。</p><p><strong>(4)</strong> 重复步骤(2)和(3)，直到遍历完所有顶点。</p><p>单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。</p><h2 id="迪杰斯特拉算法图解"><a href="#迪杰斯特拉算法图解" class="headerlink" title="迪杰斯特拉算法图解"></a><strong>迪杰斯特拉算法图解</strong></h2><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/dijkstra/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwo7enm7kmj30aj07et8v.jpg" alt="img"></a></p><p>以上图G4为例，来对迪杰斯特拉进行算法演示(以第4个顶点D为起点)。(B的权重有错误)</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/dijkstra/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwo7eo046pj30jz184jw8.jpg" alt="img"></a></p><p><strong>初始状态</strong>：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！<br><strong>第1步</strong>：将顶点D加入到S中。<br>  此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。   注:C(3)表示C到起点D的距离是3。</p><p><strong>第2步</strong>：将顶点C加入到S中。<br>  上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。<br>  此时，S={D(0),C(3)}, U={A(∞),B(23),E(4),F(9),G(∞)}。</p><p><strong>第3步</strong>：将顶点E加入到S中。<br>  上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。<br>  此时，S={D(0),C(3),E(4)}, U={A(∞),B(23),F(6),G(12)}。</p><p><strong>第4步</strong>：将顶点F加入到S中。<br>  此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。</p><p><strong>第5步</strong>：将顶点G加入到S中。<br>  此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。</p><p><strong>第6步</strong>：将顶点B加入到S中。<br>  此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。</p><p><strong>第7步</strong>：将顶点A加入到S中。<br>  此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。</p><p>此时，起点D到各个顶点的最短距离就计算出来了：<strong>A(22) B(13) C(3) D(0) E(4) F(6) G(12)</strong>。</p><h2 id="迪杰斯特拉算法的代码说明"><a href="#迪杰斯特拉算法的代码说明" class="headerlink" title="迪杰斯特拉算法的代码说明"></a><strong>迪杰斯特拉算法的代码说明</strong></h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mEdgNum;        <span class="hljs-comment">// 边的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = Integer.MAX_VALUE;   <span class="hljs-comment">// 最大值</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-迪杰斯特拉算法"><a href="#2-迪杰斯特拉算法" class="headerlink" title="2. 迪杰斯特拉算法"></a><strong>2. 迪杰斯特拉算法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * Dijkstra最短路径。<br> * 即，统计图中"顶点vs"到其它各个顶点的最短路径。<br> *<br> * 参数说明：<br> *       vs -- 起始顶点(start vertex)。即计算"顶点vs"到其它顶点的最短路径。<br> *     prev -- 前驱顶点数组。即，prev[i]的值是"顶点vs"到"顶点i"的最短路径所经历的全部顶点中，位于"顶点i"之前的那个顶点。<br> *     dist -- 长度数组。即，dist[i]是"顶点vs"到"顶点i"的最短路径的长度。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vs, <span class="hljs-keyword">int</span>[] prev, <span class="hljs-keyword">int</span>[] dist)</span> </span>&#123;<br>    <span class="hljs-comment">// flag[i]=true表示"顶点vs"到"顶点i"的最短路径已成功获取</span><br>    <span class="hljs-keyword">boolean</span>[] flag = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[mVexs.length];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        flag[i] = <span class="hljs-keyword">false</span>;          <span class="hljs-comment">// 顶点i的最短路径还没获取到。</span><br>        prev[i] = <span class="hljs-number">0</span>;              <span class="hljs-comment">// 顶点i的前驱顶点为0。</span><br>        dist[i] = mMatrix[vs][i];  <span class="hljs-comment">// 顶点i的最短路径为"顶点vs"到"顶点i"的权。</span><br>    &#125;<br><br>    <span class="hljs-comment">// 对"顶点vs"自身进行初始化</span><br>    flag[vs] = <span class="hljs-keyword">true</span>;<br>    dist[vs] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 遍历mVexs.length-1次；每次找出一个顶点的最短路径。</span><br>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; mVexs.length; i++) &#123;<br>        <span class="hljs-comment">// 寻找当前最小的路径；</span><br>        <span class="hljs-comment">// 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。</span><br>        <span class="hljs-keyword">int</span> min = INF;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (flag[j]==<span class="hljs-keyword">false</span> &amp;&amp; dist[j]&lt;min) &#123;<br>                min = dist[j];<br>                k = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 标记"顶点k"为已经获取到最短路径</span><br>        flag[k] = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// 修正当前最短路径和前驱顶点</span><br>        <span class="hljs-comment">// 即，当已经"顶点k的最短路径"之后，更新"未获取最短路径的顶点的最短路径和前驱顶点"。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++) &#123;<br>            <span class="hljs-keyword">int</span> tmp = (mMatrix[k][j]==INF ? INF : (min + mMatrix[k][j]));<br>            <span class="hljs-keyword">if</span> (flag[j]==<span class="hljs-keyword">false</span> &amp;&amp; (tmp&lt;dist[j]) ) &#123;<br>                dist[j] = tmp;<br>                prev[j] = k;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印dijkstra最短路径的结果</span><br>    System.out.printf(<span class="hljs-string">"dijkstra(%c): \n"</span>, mVexs[vs]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; mVexs.length; i++)<br>        System.out.printf(<span class="hljs-string">"  shortest(%c, %c)=%d\n"</span>, mVexs[vs], mVexs[i], dist[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="弗洛伊德算法介绍"><a href="#弗洛伊德算法介绍" class="headerlink" title="弗洛伊德算法介绍"></a><strong>弗洛伊德算法介绍</strong></h2><p><strong>基本思想</strong></p><p>   通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入一个矩阵S，矩阵S中的元素a[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。</p><p>   假设图G中顶点个数为N，则需要对矩阵S进行N次更新。初始时，矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。 接下来开始，对矩阵S进行N次更新。第1次更新时，如果”a[i][j]的距离” &gt; “a[i][0]+a[0][j]”(a[i][0]+a[0][j]表示”i与j之间经过第1个顶点的距离”)，则更新a[i][j]为”a[i][0]+a[0][j]”。 同理，第k次更新时，如果”a[i][j]的距离” &gt; “a[i][k]+a[k][j]”，则更新a[i][j]为”a[i][k]+a[k][j]”。更新N次之后，操作完成！</p><p>   单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。</p><p>   <strong>与Djkstra比较：</strong>最后的邻接矩阵包含以任意顶点喂起点的最短路径。</p><h2 id="弗洛伊德算法图解"><a href="#弗洛伊德算法图解" class="headerlink" title="弗洛伊德算法图解"></a><strong>弗洛伊德算法图解</strong></h2><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/floyd/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwo7sofmklj30rc08fmy6.jpg" alt="img"></a></p><p>以上图G4为例，来对弗洛伊德进行算法演示。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/floyd/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwo7sqfkq5j30rv1r17d3.jpg" alt="img"></a></p><p><strong>初始状态</strong>：S是记录各个顶点间最短路径的矩阵。<br><strong>第1步</strong>：初始化S。<br>  矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。实际上，就是将图的原始矩阵复制到S中。<br>  注:a[i][j]表示矩阵S中顶点i(第i个顶点)到顶点j(第j个顶点)的距离。</p><p><strong>第2步</strong>：以顶点A(第1个顶点)为中介点，若a[i][j] &gt; a[i][0]+a[0][j]，则设置a[i][j]=a[i][0]+a[0][j]。<br>  以顶点a[1]<a href="http://i.cnblogs.com/即顶点B和顶点G之间的距离为例" target="_blank" rel="noopener">6</a>，上一步操作之后，a[1][6]=∞；而将A作为中介点时，(B,A)=12，(A,G)=14，因此B和G之间的距离可以更新为26。</p><p>同理，依次将顶点B,C,D,E,F,G作为中介点，并更新a[i][j]的大小。</p><h2 id="弗洛伊德算法的代码说明"><a href="#弗洛伊德算法的代码说明" class="headerlink" title="弗洛伊德算法的代码说明"></a><strong>弗洛伊德算法的代码说明</strong></h2><h3 id="1-基本定义-1"><a href="#1-基本定义-1" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mEdgNum;        <span class="hljs-comment">// 边的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = Integer.MAX_VALUE;   <span class="hljs-comment">// 最大值</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-弗洛伊德算法"><a href="#2-弗洛伊德算法" class="headerlink" title="2. 弗洛伊德算法"></a><strong>2. 弗洛伊德算法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * floyd最短路径。<br> * 即，统计图中各个顶点间的最短路径。<br> *<br> * 参数说明：<br> *     path -- 路径。path[i][j]=k表示，"顶点i"到"顶点j"的最短路径会经过顶点k。<br> *     dist -- 长度数组。即，dist[i][j]=sum表示，"顶点i"到"顶点j"的最短路径的长度是sum。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] path, <span class="hljs-keyword">int</span>[][] dist)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++) &#123;<br>            dist[i][j] = mMatrix[i][j];    <span class="hljs-comment">// "顶点i"到"顶点j"的路径长度为"i到j的权值"。</span><br>            path[i][j] = j;                <span class="hljs-comment">// "顶点i"到"顶点j"的最短路径是经过顶点j。</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算最短路径</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; mVexs.length; k++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++) &#123;<br><br>                <span class="hljs-comment">// 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]和path[i][j]</span><br>                <span class="hljs-keyword">int</span> tmp = (dist[i][k]==INF || dist[k][j]==INF) ? INF : (dist[i][k] + dist[k][j]);<br>                <span class="hljs-keyword">if</span> (dist[i][j] &gt; tmp) &#123;<br>                    <span class="hljs-comment">// "i到j最短路径"对应的值设，为更小的一个(即经过k)</span><br>                    dist[i][j] = tmp;<br>                    <span class="hljs-comment">// "i到j最短路径"对应的路径，经过k</span><br>                    path[i][j] = path[i][k];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印floyd最短路径的结果</span><br>    System.out.printf(<span class="hljs-string">"floyd: \n"</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++)<br>            System.out.printf(<span class="hljs-string">"%2d  "</span>, dist[i][j]);<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路径-Djkstra-Floyd&quot;&gt;&lt;a href=&quot;#最短路径-Djkstra-Floyd&quot; class=&quot;headerlink&quot; title=&quot;最短路径(Djkstra, Floyd)&quot;&gt;&lt;/a&gt;最短路径(Djkstra, Floyd)&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>7.5.图的最小生成树(Prime, Kruskal)</title>
    <link href="http://yoursite.com/2022/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.5.%E5%9B%BE%E7%9A%84%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91(Prime,%20Kruskal)/"/>
    <id>http://yoursite.com/2022/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.5.%E5%9B%BE%E7%9A%84%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91(Prime,%20Kruskal)/</id>
    <published>2022-01-18T14:35:39.000Z</published>
    <updated>2022-02-21T00:54:33.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小生成树-Prime-Kruskal"><a href="#最小生成树-Prime-Kruskal" class="headerlink" title="最小生成树(Prime, Kruskal)"></a>最小生成树(Prime, Kruskal)</h1><h2 id="最小生成树概念"><a href="#最小生成树概念" class="headerlink" title="最小生成树概念"></a><strong>最小生成树概念</strong></h2><p>在含有n个顶点的连通图中选择n-1条边，构成一棵极小连通子图，并使该连通子图中n-1条边上权值之和达到最小，则称其为连通网的最小生成树。<br><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn1aw8x2lj30aj07et8v.jpg" alt="img"></a></p><p>例如，对于如上图G4所示的连通网可以有多棵权值总和不相同的生成树。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn1awqlhsj30vj07et9l.jpg" alt="img"></a></p><h1 id="克鲁斯卡尔-Kruskal-算法"><a href="#克鲁斯卡尔-Kruskal-算法" class="headerlink" title="克鲁斯卡尔(Kruskal)算法"></a><strong>克鲁斯卡尔(Kruskal)算法</strong></h1><p>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。</p><p><strong>基本思想</strong>：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。<br><strong>具体做法</strong>：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。</p><h2 id="克鲁斯卡尔算法图解"><a href="#克鲁斯卡尔算法图解" class="headerlink" title="克鲁斯卡尔算法图解"></a><strong>克鲁斯卡尔算法图解</strong></h2><p>以上图G4为例，来对克鲁斯卡尔进行演示(假设，用数组R保存最小生成树结果)。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/03.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn1rekeu5j30do11u0vb.jpg" alt="img"></a></p><p><strong>第1步</strong>：将边&lt;E,F&gt;加入R中。<br>  边&lt;E,F&gt;的权值最小，因此将它加入到最小生成树结果R中。<br><strong>第2步</strong>：将边&lt;C,D&gt;加入R中。<br>  上一步操作之后，边&lt;C,D&gt;的权值最小，因此将它加入到最小生成树结果R中。<br><strong>第3步</strong>：将边&lt;D,E&gt;加入R中。<br>  上一步操作之后，边&lt;D,E&gt;的权值最小，因此将它加入到最小生成树结果R中。<br><strong>第4步</strong>：将边&lt;B,F&gt;加入R中。<br>  上一步操作之后，边&lt;C,E&gt;的权值最小，但&lt;C,E&gt;会和已有的边构成回路；因此，跳过边&lt;C,E&gt;。同理，跳过边&lt;C,F&gt;。将边&lt;B,F&gt;加入到最小生成树结果R中。<br><strong>第5步</strong>：将边&lt;E,G&gt;加入R中。<br>  上一步操作之后，边&lt;E,G&gt;的权值最小，因此将它加入到最小生成树结果R中。<br><strong>第6步</strong>：将边&lt;A,B&gt;加入R中。<br>  上一步操作之后，边&lt;F,G&gt;的权值最小，但&lt;F,G&gt;会和已有的边构成回路；因此，跳过边&lt;F,G&gt;。同理，跳过边&lt;B,C&gt;。将边&lt;A,B&gt;加入到最小生成树结果R中。</p><p>此时，最小生成树构造完成！它包括的边依次是：<strong>&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;</strong>。</p><h2 id="克鲁斯卡尔算法分析"><a href="#克鲁斯卡尔算法分析" class="headerlink" title="克鲁斯卡尔算法分析"></a><strong>克鲁斯卡尔算法分析</strong></h2><p>根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题：<br><strong>问题一</strong> 对图的所有边按照权值大小进行排序。<br><strong>问题二</strong> 将边添加到最小生成树中时，怎么样判断是否形成了回路。</p><p>问题一很好解决，采用排序算法进行排序即可。</p><p>问题二处理方式是：<strong>==记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”(<em>关于这一点，后面会通过图片给出说明</em>)。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。==</strong> 以下图来进行说明：</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/04.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn1y7epmpj30aj06c74g.jpg" alt="img"></a></p><p>在将&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt;加入到最小生成树R中之后，这几条边的顶点就都有了终点：</p><blockquote><p><strong>(01)</strong> C的终点是F。<br><strong>(02)</strong> D的终点是F。<br><strong>(03)</strong> E的终点是F。<br><strong>(04)</strong> F的终点是F。</p></blockquote><p>关于终点，就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是”与它连通的最大顶点”。 因此，接下来，虽然&lt;C,E&gt;是权值最小的边。但是C和E的重点都是F，即它们的终点相同，因此，将&lt;C,E&gt;加入最小生成树的话，会形成回路。这就是判断回路的方式。</p><h2 id="克鲁斯卡尔算法的代码说明"><a href="#克鲁斯卡尔算法的代码说明" class="headerlink" title="克鲁斯卡尔算法的代码说明"></a><strong>克鲁斯卡尔算法的代码说明</strong></h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><p>EData是邻接矩阵边对应的结构体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 边的结构体</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EData</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> start; <span class="hljs-comment">// 边的起点</span><br>    <span class="hljs-keyword">char</span> end;   <span class="hljs-comment">// 边的终点</span><br>    <span class="hljs-keyword">int</span> weight; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EData</span><span class="hljs-params">(<span class="hljs-keyword">char</span> start, <span class="hljs-keyword">char</span> end, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.start = start;<br>        <span class="hljs-keyword">this</span>.end = end;<br>        <span class="hljs-keyword">this</span>.weight = weight;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mEdgNum;        <span class="hljs-comment">// 边的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = Integer.MAX_VALUE;   <span class="hljs-comment">// 最大值</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-克鲁斯卡尔算法"><a href="#2-克鲁斯卡尔算法" class="headerlink" title="2. 克鲁斯卡尔算法"></a><strong>2. 克鲁斯卡尔算法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 克鲁斯卡尔（Kruskal)最小生成树<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;                      <span class="hljs-comment">// rets数组的索引</span><br>    <span class="hljs-keyword">int</span>[] vends = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[mEdgNum];     <span class="hljs-comment">// 用于保存"已有最小生成树"中每个顶点在该最小树中的终点。</span><br>    EData[] rets = <span class="hljs-keyword">new</span> EData[mEdgNum];  <span class="hljs-comment">// 结果数组，保存kruskal最小生成树的边</span><br>    EData[] edges;                      <span class="hljs-comment">// 图对应的所有边</span><br><br>    <span class="hljs-comment">// 获取"图中所有的边"</span><br>    edges = getEdges();<br>    <span class="hljs-comment">// 将边按照"权"的大小进行排序(从小到大)</span><br>    sortEdges(edges, mEdgNum);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;mEdgNum; i++) &#123;<br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i].start);      <span class="hljs-comment">// 获取第i条边的"起点"的序号</span><br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i].end);        <span class="hljs-comment">// 获取第i条边的"终点"的序号</span><br><br>        <span class="hljs-keyword">int</span> m = getEnd(vends, p1);                 <span class="hljs-comment">// 获取p1在"已有的最小生成树"中的终点</span><br>        <span class="hljs-keyword">int</span> n = getEnd(vends, p2);                 <span class="hljs-comment">// 获取p2在"已有的最小生成树"中的终点</span><br>        <span class="hljs-comment">// 如果m!=n，意味着"边i"与"已经添加到最小生成树中的顶点"没有形成环路</span><br>        <span class="hljs-keyword">if</span> (m != n) &#123;<br>            vends[m] = n;                       <span class="hljs-comment">// 设置m在"已有的最小生成树"中的终点为n</span><br>            rets[index++] = edges[i];           <span class="hljs-comment">// 保存结果</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 统计并打印"kruskal最小生成树"的信息</span><br>    <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>        length += rets[i].weight;<br>    System.out.printf(<span class="hljs-string">"Kruskal=%d: "</span>, length);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>        System.out.printf(<span class="hljs-string">"(%c,%c) "</span>, rets[i].start, rets[i].end);<br>    System.out.printf(<span class="hljs-string">"\n"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="普里姆-Prim-算法"><a href="#普里姆-Prim-算法" class="headerlink" title="普里姆(Prim)算法"></a>普里姆(Prim)算法</h1><p>普里姆(Prim)算法，是用来求加权连通图的最小生成树的算法。</p><p><strong>基本思想</strong><br>对于图G而言，V是所有顶点的集合；现在，设置两个新的集合U和T，其中U用于存放G的最小生成树中的顶点，T存放G的最小生成树中的边。 从所有uЄU，vЄ(V-U) (V-U表示出去U的所有顶点)的边中选取权值最小的边(u, v)，将顶点v加入集合U中，将边(u, v)加入集合T中，如此不断重复，直到U=V为止，最小生成树构造完毕，这时集合T中包含了最小生成树中的所有边。</p><h2 id="普里姆算法图解"><a href="#普里姆算法图解" class="headerlink" title="普里姆算法图解"></a><strong>普里姆算法图解</strong></h2><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/prim/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn3kzc05yj30aj07et8v.jpg" alt="img"></a></p><p>以上图G4为例，来对普里姆进行演示(从第一个顶点A开始通过普里姆算法生成最小生成树)。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/prim/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn3l4fltij30eq184jv3.jpg" alt="img"></a></p><p><strong>初始状态</strong>：V是所有顶点的集合，即V={A,B,C,D,E,F,G}；U和T都是空！<br><strong>第1步</strong>：将顶点A加入到U中。<br>  此时，U={A}。<br><strong>第2步</strong>：将顶点B加入到U中。<br>  上一步操作之后，U={A}, V-U={B,C,D,E,F,G}；因此，边(A,B)的权值最小。将顶点B添加到U中；此时，U={A,B}。<br><strong>第3步</strong>：将顶点F加入到U中。<br>  上一步操作之后，U={A,B}, V-U={C,D,E,F,G}；因此，边(B,F)的权值最小。将顶点F添加到U中；此时，U={A,B,F}。<br><strong>第4步</strong>：将顶点E加入到U中。<br>  上一步操作之后，U={A,B,F}, V-U={C,D,E,G}；因此，边(F,E)的权值最小。将顶点E添加到U中；此时，U={A,B,F,E}。<br><strong>第5步</strong>：将顶点D加入到U中。<br>  上一步操作之后，U={A,B,F,E}, V-U={C,D,G}；因此，边(E,D)的权值最小。将顶点D添加到U中；此时，U={A,B,F,E,D}。<br><strong>第6步</strong>：将顶点C加入到U中。<br>  上一步操作之后，U={A,B,F,E,D}, V-U={C,G}；因此，边(D,C)的权值最小。将顶点C添加到U中；此时，U={A,B,F,E,D,C}。<br><strong>第7步</strong>：将顶点G加入到U中。<br>  上一步操作之后，U={A,B,F,E,D,C}, V-U={G}；因此，边(F,G)的权值最小。将顶点G添加到U中；此时，U=V。</p><p>此时，最小生成树构造完成！它包括的顶点依次是：<strong>A B F E D C G</strong>。</p><h2 id="普里姆算法的代码说明"><a href="#普里姆算法的代码说明" class="headerlink" title="普里姆算法的代码说明"></a><strong>普里姆算法的代码说明</strong></h2><h3 id="1-基本定义-1"><a href="#1-基本定义-1" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = Integer.MAX_VALUE;   <span class="hljs-comment">// 最大值</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-普里姆算法"><a href="#2-普里姆算法" class="headerlink" title="2. 普里姆算法"></a><strong>2. 普里姆算法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * prim最小生成树<br> *<br> * 参数说明：<br> *   start -- 从图中的第start个元素开始，生成最小树<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num = mVexs.length;         <span class="hljs-comment">// 顶点个数</span><br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;                    <span class="hljs-comment">// prim最小树的索引，即prims数组的索引</span><br>    <span class="hljs-keyword">char</span>[] prims  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[num];  <span class="hljs-comment">// prim最小树的结果数组</span><br>    <span class="hljs-keyword">int</span>[] weights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num];   <span class="hljs-comment">// 顶点间边的权值</span><br><br>    <span class="hljs-comment">// prim最小生成树中第一个数是"图中第start个顶点"，因为是从start开始的。</span><br>    prims[index++] = mVexs[start];<br><br>    <span class="hljs-comment">// 初始化"顶点的权值数组"，</span><br>    <span class="hljs-comment">// 将每个顶点的权值初始化为"第start个顶点"到"该顶点"的权值。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++ )<br>        weights[i] = mMatrix[start][i];<br>    <span class="hljs-comment">// 将第start个顶点的权值初始化为0。</span><br>    <span class="hljs-comment">// 可以理解为"第start个顶点到它自身的距离为0"。</span><br>    weights[start] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>        <span class="hljs-comment">// 由于从start开始的，因此不需要再对第start个顶点进行处理。</span><br>        <span class="hljs-keyword">if</span>(start == i)<br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> min = INF;<br>        <span class="hljs-comment">// 在未被加入到最小生成树的顶点中，找出权值最小的顶点。</span><br>        <span class="hljs-keyword">while</span> (j &lt; num) &#123;<br>            <span class="hljs-comment">// 若weights[j]=0，意味着"第j个节点已经被排序过"(或者说已经加入了最小生成树中)。</span><br>            <span class="hljs-keyword">if</span> (weights[j] != <span class="hljs-number">0</span> &amp;&amp; weights[j] &lt; min) &#123;<br>                min = weights[j];<br>                k = j;<br>            &#125;<br>            j++;<br>        &#125;<br><br>        <span class="hljs-comment">// 经过上面的处理后，在未被加入到最小生成树的顶点中，权值最小的顶点是第k个顶点。</span><br>        <span class="hljs-comment">// 将第k个顶点加入到最小生成树的结果数组中</span><br>        prims[index++] = mVexs[k];<br>        <span class="hljs-comment">// 将"第k个顶点的权值"标记为0，意味着第k个顶点已经排序过了(或者说已经加入了最小树结果中)。</span><br>        weights[k] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 当第k个顶点被加入到最小生成树的结果数组中之后，更新其它顶点的权值。</span><br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span> ; j &lt; num; j++) &#123;<br>            <span class="hljs-comment">// 当第j个节点没有被处理，并且需要更新时才被更新。</span><br>            <span class="hljs-keyword">if</span> (weights[j] != <span class="hljs-number">0</span> &amp;&amp; mMatrix[k][j] &lt; weights[j])<br>                weights[j] = mMatrix[k][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算最小生成树的权值</span><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; index; i++) &#123;<br>        <span class="hljs-keyword">int</span> min = INF;<br>        <span class="hljs-comment">// 获取prims[i]在mMatrix中的位置</span><br>        <span class="hljs-keyword">int</span> n = getPosition(prims[i]);<br>        <span class="hljs-comment">// 在vexs[0...i]中，找出到j的权值最小的顶点。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">int</span> m = getPosition(prims[j]);<br>            <span class="hljs-keyword">if</span> (mMatrix[m][n]&lt;min)<br>                min = mMatrix[m][n];<br>        &#125;<br>        sum += min;<br>    &#125;<br>    <span class="hljs-comment">// 打印最小生成树</span><br>    System.out.printf(<span class="hljs-string">"PRIM(%c)=%d: "</span>, mVexs[start], sum);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>        System.out.printf(<span class="hljs-string">"%c "</span>, prims[i]);<br>    System.out.printf(<span class="hljs-string">"\n"</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最小生成树-Prime-Kruskal&quot;&gt;&lt;a href=&quot;#最小生成树-Prime-Kruskal&quot; class=&quot;headerlink&quot; title=&quot;最小生成树(Prime, Kruskal)&quot;&gt;&lt;/a&gt;最小生成树(Prime, Kruskal)&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>7.4.图的拓扑排序</title>
    <link href="http://yoursite.com/2022/01/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.4.%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2022/01/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.4.%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</id>
    <published>2022-01-16T14:34:39.000Z</published>
    <updated>2022-02-21T00:54:33.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h1><h2 id="一、拓扑排序"><a href="#一、拓扑排序" class="headerlink" title="一、拓扑排序"></a>一、拓扑排序</h2><h3 id="1-拓扑排序介绍"><a href="#1-拓扑排序介绍" class="headerlink" title="1. 拓扑排序介绍"></a><strong>1. 拓扑排序介绍</strong></h3><p>拓扑排序(Topological Order)是指，将一个<strong>有向无环图</strong>(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的线性序列。</p><p>拓扑排序通常用来“排序”具有依赖关系的任务。比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边 表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。</p><p>如果AOV网络有n个顶点，e条边，在拓扑排序的过程中，搜索入度为零的顶点所需的时间是O(n)。在正常情况下，每个顶点进一次栈，出一次栈，所需时间O(n)。每个顶点入度减1的运算共执行了e次。所以总的时间复杂为O(n+e)。</p><h3 id="2-拓扑排序的算法图解"><a href="#2-拓扑排序的算法图解" class="headerlink" title="2. 拓扑排序的算法图解"></a><strong>2. 拓扑排序的算法图解</strong></h3><p>拓扑排序算法的基本步骤：</p><blockquote><p><strong>1.</strong> 构造一个队列Q(queue) 和 拓扑排序的结果队列T(topological)；<br><strong>2.</strong> 把所有没有依赖顶点的节点放入Q；<br><strong>3.</strong> 当Q还有顶点的时候，执行下面步骤：<br><strong>3.1</strong> 从Q中取出一个顶点n(将n从Q中删掉)，并放入T(将n加入到结果集中)；<br><strong>3.2</strong> 对n每一个邻接点m(n是起点，m是终点)；<br><strong>3.2.1</strong> 去掉边&lt;n,m&gt;;<br><strong>3.2.2</strong> 如果m没有依赖顶点，则把m放入Q;<br><em>注：顶点A没有依赖顶点，是指不存在以A为终点的边。</em></p></blockquote><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/topsort/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmtodh85wj308f08ywek.jpg" alt="img"></a></p><p>以上图为例，来对拓扑排序进行演示。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/topsort/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmtonrt51j30aj0tfaax.jpg" alt="img"></a></p><p><strong>第1步</strong>：将B和C加入到排序结果中。<br>  顶点B和顶点C都是没有依赖顶点，因此将C和C加入到结果集T中。假设ABCDEFG按顺序存储，因此先访问B，再访问C。访问B之后，去掉边&lt;B,A&gt;和&lt;B,D&gt;，并将A和D加入到队列Q中。同样的，去掉边&lt;C,F&gt;和&lt;C,G&gt;，并将F和G加入到Q中。<br>  (01) 将B加入到排序结果中，然后去掉边&lt;B,A&gt;和&lt;B,D&gt;；此时，由于A和D没有依赖顶点，因此并将A和D加入到队列Q中。<br>  (02) 将C加入到排序结果中，然后去掉边&lt;C,F&gt;和&lt;C,G&gt;；此时，由于F有依赖顶点D，G有依赖顶点A，因此不对F和G进行处理。<br><strong>第2步</strong>：将A,D依次加入到排序结果中。<br>  第1步访问之后，A,D都是没有依赖顶点的，根据存储顺序，先访问A，然后访问D。访问之后，删除顶点A和顶点D的出边。<br><strong>第3步</strong>：将E,F,G依次加入到排序结果中。</p><p>因此访问顺序是：<strong>B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; F -&gt; G</strong></p><h3 id="3-拓扑排序的代码"><a href="#3-拓扑排序的代码" class="headerlink" title="3. 拓扑排序的代码"></a><strong>3. 拓扑排序的代码</strong></h3><h4 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h4><p>拓扑排序是对有向无环图的排序。下面以邻接表实现的有向图来对拓扑排序进行说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListDG</span> </span>&#123;<br>    <span class="hljs-comment">// 邻接表中表对应的链表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ENode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ivex;       <span class="hljs-comment">// 该边所指向的顶点的位置</span><br>        ENode nextEdge; <span class="hljs-comment">// 指向下一条弧的指针</span><br>    &#125;<br><br>    <span class="hljs-comment">// 邻接表中表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VNode</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> data;          <span class="hljs-comment">// 顶点信息</span><br>        ENode firstEdge;    <span class="hljs-comment">// 指向第一条依附该顶点的弧</span><br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> VNode[] mVexs;  <span class="hljs-comment">// 顶点数组</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>(1)</strong> ListDG是邻接表对应的结构体。 mVexs则是保存顶点信息的一维数组。<br><strong>(2)</strong> VNode是邻接表顶点对应的结构体。 data是顶点所包含的数据，而firstEdge是该顶点所包含链表的表头指针。<br><strong>(3)</strong> ENode是邻接表顶点所包含的链表的节点对应的结构体。 ivex是该节点所对应的顶点在vexs中的索引，而nextEdge是指向下一个节点的。</p><h4 id="2-拓扑排序"><a href="#2-拓扑排序" class="headerlink" title="2. 拓扑排序"></a><strong>2. 拓扑排序</strong></h4><p>说明：<br><strong>(1)</strong> queue的作用就是用来存储没有依赖顶点的顶点。它与前面所说的Q相对应。<br><strong>(2)</strong> tops的作用就是用来存储排序结果。它与前面所说的T相对应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 拓扑排序<br> *<br> * 返回值：<br> *     -1 -- 失败(由于内存不足等原因导致)<br> *      0 -- 成功排序，并输入结果<br> *      1 -- 失败(该有向图是有环的)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">topologicalSort</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> num = mVexs.size();<br>    <span class="hljs-keyword">int</span>[] ins;               <span class="hljs-comment">// 入度数组</span><br>    <span class="hljs-keyword">char</span>[] tops;             <span class="hljs-comment">// 拓扑排序结果数组，记录每个节点的排序后的序号。</span><br>    Queue&lt;Integer&gt; queue;    <span class="hljs-comment">// 辅组队列</span><br><br>    ins   = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num];<br>    tops  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[num];<br>    queue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br><br>    <span class="hljs-comment">// 统计每个顶点的入度数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br><br>        ENode node = mVexs.get(i).firstEdge; <span class="hljs-comment">//获取以该顶点为起点的出边队列</span><br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>            ins[node.ivex]++;<br>            node = node.nextEdge;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将所有入度为0的顶点入队列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i ++)<br>        <span class="hljs-keyword">if</span>(ins[i] == <span class="hljs-number">0</span>)<br>            queue.offer(i);                 <span class="hljs-comment">// 入队列</span><br><br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;              <span class="hljs-comment">// 队列非空</span><br>        <span class="hljs-keyword">int</span> j = queue.poll().intValue();    <span class="hljs-comment">// 出队列。j是顶点的序号</span><br>        tops[index++] = mVexs.get(j).data;  <span class="hljs-comment">// 将该顶点添加到tops中，tops是排序结果</span><br>        ENode node = mVexs.get(j).firstEdge;<span class="hljs-comment">// 获取以该顶点为起点的出边队列</span><br><br>        <span class="hljs-comment">// 将与"node"关联的节点的入度减1；</span><br>        <span class="hljs-comment">// 若减1之后，该节点的入度为0；则将该节点添加到队列中。</span><br>        <span class="hljs-keyword">while</span>(node != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 将节点(序号为node.ivex)的入度减1。</span><br>            ins[node.ivex]--;<br>            <span class="hljs-comment">// 若节点的入度为0，则将其"入队列"</span><br>            <span class="hljs-keyword">if</span>( ins[node.ivex] == <span class="hljs-number">0</span>)<br>                queue.offer(node.ivex);    <span class="hljs-comment">// 入队列</span><br><br>            node = node.nextEdge;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(index != num) &#123;<br>        System.out.printf(<span class="hljs-string">"Graph has a cycle\n"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印拓扑排序结果</span><br>    System.out.printf(<span class="hljs-string">"== TopSort: "</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i ++)<br>        System.out.printf(<span class="hljs-string">"%c "</span>, tops[i]);<br>    System.out.printf(<span class="hljs-string">"\n"</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图的应用&quot;&gt;&lt;a href=&quot;#图的应用&quot; class=&quot;headerlink&quot; title=&quot;图的应用&quot;&gt;&lt;/a&gt;图的应用&lt;/h1&gt;&lt;h2 id=&quot;一、拓扑排序&quot;&gt;&lt;a href=&quot;#一、拓扑排序&quot; class=&quot;headerlink&quot; title=&quot;一、拓扑排
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>7.3.图的遍历(DFS,BFS)</title>
    <link href="http://yoursite.com/2022/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.3.%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86(DFS,BFS)/"/>
    <id>http://yoursite.com/2022/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.3.%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86(DFS,BFS)/</id>
    <published>2022-01-14T14:32:39.000Z</published>
    <updated>2022-02-21T00:54:33.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a><strong>图的遍历</strong></h1><h2 id="一、深度优先搜索-Depth-First-Search-DFS"><a href="#一、深度优先搜索-Depth-First-Search-DFS" class="headerlink" title="一、深度优先搜索(Depth First Search, DFS)"></a>一、深度优先搜索(Depth First Search, DFS)</h2><h3 id="1-深度优先搜索介绍"><a href="#1-深度优先搜索介绍" class="headerlink" title="1. 深度优先搜索介绍"></a><strong>1. 深度优先搜索介绍</strong></h3><p>图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。</p><p>它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>显然，深度优先搜索是一个递归的过程。</p><h3 id="2-深度优先搜索图解"><a href="#2-深度优先搜索图解" class="headerlink" title="2. 深度优先搜索图解"></a><strong>2. 深度优先搜索图解</strong></h3><h4 id="2-1-无向图的深度优先搜索"><a href="#2-1-无向图的深度优先搜索" class="headerlink" title="2.1 无向图的深度优先搜索"></a><strong>2.1 无向图的深度优先搜索</strong></h4><p>下面以”无向图”为例，来对深度优先搜索进行演示。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmlnfvwp5j30bl08f74e.jpg" alt="img"></a></p><p>对上面的图G1进行深度优先遍历，从顶点A开始。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmlngl8zqj30c409h0t0.jpg" alt="img"></a></p><p><strong>第1步</strong>：访问A。<br><strong>第2步</strong>：访问(A的邻接点)C。<br>  在第1步访问A之后，接下来应该访问的是A的邻接点，即”C,D,F”中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在”D和F”的前面，因此，先访问C。<br><strong>第3步</strong>：访问(C的邻接点)B。<br>  在第2步访问C之后，接下来应该访问C的邻接点，即”B和D”中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。<br><strong>第4步</strong>：访问(C的邻接点)D。<br>  在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。<br><strong>第5步</strong>：访问(A的邻接点)F。<br>  前面已经访问了A，并且访问完了”A的邻接点B的所有邻接点(包括递归的邻接点在内)”；因此，此时返回到访问A的另一个邻接点F。<br><strong>第6步</strong>：访问(F的邻接点)G。<br><strong>第7步</strong>：访问(G的邻接点)E。</p><p>因此访问顺序是：<strong>A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E</strong></p><h4 id="2-2-有向图的深度优先搜索"><a href="#2-2-有向图的深度优先搜索" class="headerlink" title="2.2 有向图的深度优先搜索"></a><strong>2.2 有向图的深度优先搜索</strong></h4><p>下面以”有向图”为例，来对深度优先搜索进行演示。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/03.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmlpwnltaj308f08yt8t.jpg" alt="img"></a></p><p>对上面的图G2进行深度优先遍历，从顶点A开始。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/04.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmlpy4gxuj308f0a0wer.jpg" alt="img"></a></p><p><strong>第1步</strong>：访问A。<br><strong>第2步</strong>：访问B。<br>  在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。<br><strong>第3步</strong>：访问C。<br>  在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。<br><strong>第4步</strong>：访问E。<br>  接下来访问C的出边的另一个顶点，即顶点E。<br><strong>第5步</strong>：访问D。<br>  接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。<br><strong>第6步</strong>：访问F。<br>  接下应该回溯”访问A的出边的另一个顶点F”。<br><strong>第7步</strong>：访问G。</p><p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G</strong></p><h4 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><p><strong>邻接矩阵的深度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接矩阵的深度优先遍历</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 深度优先遍历</span><br><span class="hljs-keyword">boolean</span>[] beTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.vertices];<br><span class="hljs-comment">// 保存顶点的遍历状态，默认为false</span><br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>System.out.print(<span class="hljs-string">"深度优先遍历结果："</span>);<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList.get(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">this</span>.dfs(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, beTraversed);<br>System.out.println();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">boolean</span>[] beTraversed)</span> </span>&#123;<br><span class="hljs-comment">// 遍历x的第y个邻接点</span><br><span class="hljs-keyword">while</span> (y &lt; <span class="hljs-keyword">this</span>.vertices) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.edgeMatrix[x][y] != <span class="hljs-number">0</span> &amp;&amp; !beTraversed[y]) &#123;<br>beTraversed[y] = <span class="hljs-keyword">true</span>;<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList.get(y));<br><span class="hljs-keyword">this</span>.dfs(y, <span class="hljs-number">0</span>, beTraversed); <span class="hljs-comment">// 从y的第0个邻接点开始深度优先遍历</span><br>&#125;<br>y++;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>邻接表的深度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接表的深度优先遍历</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 深度优先遍历</span><br><span class="hljs-keyword">boolean</span>[] beTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.vertices];<br><span class="hljs-comment">// 保存顶点的遍历状态，默认为false</span><br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>System.out.print(<span class="hljs-string">"深度优先遍历结果："</span>);<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList[<span class="hljs-number">0</span>].data);<br><span class="hljs-keyword">this</span>.dfs(<span class="hljs-number">0</span>, beTraversed);<br>System.out.println();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">boolean</span>[] beTraversed)</span> </span>&#123;<br><span class="hljs-comment">// 从第i个顶点开始深度优先遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j : <span class="hljs-keyword">this</span>.vertexList[i].adj) &#123;<br><span class="hljs-keyword">if</span> (!beTraversed[j]) &#123;<br>beTraversed[j] = <span class="hljs-keyword">true</span>;<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList[j].data);<br><span class="hljs-keyword">this</span>.dfs(j, beTraversed);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自己构造邻接表的深度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bean.algorithm.graph;<br> <br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DFSGraph</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> V; <span class="hljs-comment">// 定义结点（vertices）</span><br> <br><span class="hljs-comment">// 图的邻接表表示（ Adjacency List）</span><br><span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; adj[];<br> <br><span class="hljs-comment">// 构造图的构造方法</span><br>DFSGraph(<span class="hljs-keyword">int</span> v) &#123;<br>V = v;<br>adj = <span class="hljs-keyword">new</span> LinkedList[v];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i)<br>adj[i] = <span class="hljs-keyword">new</span> LinkedList();<br>&#125;<br> <br><span class="hljs-comment">// 向图中添加边</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>adj[v].add(w); <br>&#125;<br> <br><span class="hljs-comment">// DFS算法工具</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFSUtil</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">boolean</span> visited[])</span> </span>&#123;<br><span class="hljs-comment">// 标记当前结点为已访问（visited）并输出</span><br>visited[v] = <span class="hljs-keyword">true</span>;<br>System.out.print(v + <span class="hljs-string">" "</span>);<br> <br><span class="hljs-comment">// 访问当前的结点的所有邻接结点</span><br>Iterator&lt;Integer&gt; i = adj[v].listIterator();<br><span class="hljs-keyword">while</span> (i.hasNext()) &#123;<br><span class="hljs-keyword">int</span> n = i.next();<br><span class="hljs-keyword">if</span> (!visited[n])<br>DFSUtil(n, visited);<br>&#125;<br>&#125;<br> <br><span class="hljs-comment">// DFS traversal. 用来回溯调用 DFSUtil()工具</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br><span class="hljs-comment">// 标记所有节点为未访问状态（ not visited），设置初始值为false。</span><br><span class="hljs-keyword">boolean</span> visited[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[V];<br> <br><span class="hljs-comment">// 回溯 DFS traversal</span><br>DFSUtil(v, visited);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>DFSGraph g = <span class="hljs-keyword">new</span> DFSGraph(<span class="hljs-number">4</span>);<br> <br>g.addEdge(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>g.addEdge(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>g.addEdge(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>g.addEdge(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>g.addEdge(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>g.addEdge(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br> <br>System.out.println(<span class="hljs-string">"下面是DFS搜索结果 "</span> + <span class="hljs-string">"(从2号结点开始)"</span>);<br> <br>g.DFS(<span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、广度优先搜索-Breadth-First-Search-BFS"><a href="#二、广度优先搜索-Breadth-First-Search-BFS" class="headerlink" title="二、广度优先搜索(Breadth First Search, BFS)"></a><strong>二、广度优先搜索(Breadth First Search, BFS)</strong></h2><h3 id="1-广度优先搜索介绍"><a href="#1-广度优先搜索介绍" class="headerlink" title="1. 广度优先搜索介绍"></a><strong>1. 广度优先搜索介绍</strong></h3><p>广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。</p><p>它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。</p><h3 id="2-广度优先搜索图解"><a href="#2-广度优先搜索图解" class="headerlink" title="2. 广度优先搜索图解"></a><strong>2. 广度优先搜索图解</strong></h3><h4 id="2-1-无向图的广度优先搜索"><a href="#2-1-无向图的广度优先搜索" class="headerlink" title="2.1 无向图的广度优先搜索"></a><strong>2.1 无向图的广度优先搜索</strong></h4><p>下面以”无向图”为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/05.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmltsvygcj30eq0e7dge.jpg" alt="img"></a></p><p><strong>第1步</strong>：访问A。<br><strong>第2步</strong>：依次访问C,D,F。<br>  在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在”D和F”的前面，因此，先访问C。再访问完C之后，再依次访问D,F。<br><strong>第3步</strong>：依次访问B,G。<br>  在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。<br><strong>第4步</strong>：访问E。<br>  在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。</p><p>因此访问顺序是：<strong>A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E</strong></p><h4 id="2-2-有向图的广度优先搜索"><a href="#2-2-有向图的广度优先搜索" class="headerlink" title="2.2 有向图的广度优先搜索"></a><strong>2.2 有向图的广度优先搜索</strong></h4><p>下面以”有向图”为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/06.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmluvpt0jj30fs0cnq3k.jpg" alt="img"></a></p><p><strong>第1步</strong>：访问A。<br><strong>第2步</strong>：访问B。<br><strong>第3步</strong>：依次访问C,E,F。<br>  在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。<br><strong>第4步</strong>：依次访问D,G。<br>  在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。</p><p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G</strong></p><h4 id="2-3-代码实现-1"><a href="#2-3-代码实现-1" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><p><strong>邻接矩阵的广度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接矩阵的广度优先遍历</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 宽度优先遍历</span><br><span class="hljs-keyword">boolean</span>[] beTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.vertices];<br><span class="hljs-comment">// 保存顶点的遍历状态，默认为false</span><br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>Queue queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>queue.offer(<span class="hljs-number">0</span>);<br><br>System.out.print(<span class="hljs-string">"宽度优先遍历："</span>);<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br><span class="hljs-keyword">int</span> index = queue.poll();<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList.get(index));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.vertices; i++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.edgeMatrix[index][i] != <span class="hljs-number">0</span> &amp;&amp; !beTraversed[i]) &#123;<br><span class="hljs-comment">// 找出所有没有访问过的邻接点</span><br>beTraversed[i] = <span class="hljs-keyword">true</span>;<br>queue.offer(i);<br>&#125;<br>&#125;<br>&#125;<br>System.out.println();<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>邻接表的广度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接表的广度优先遍历</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 宽度优先遍历</span><br><span class="hljs-keyword">boolean</span>[] beTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.vertices];<br><span class="hljs-comment">// 保存顶点的遍历状态，默认为false</span><br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>Queue queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>queue.offer(<span class="hljs-number">0</span>);<br><br>System.out.print(<span class="hljs-string">"宽度优先遍历："</span>);<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br><span class="hljs-keyword">int</span> index = queue.poll();<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList[index].data);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : <span class="hljs-keyword">this</span>.vertexList[index].adj) &#123;<br><span class="hljs-comment">// 所有未被访问过的邻接点入队</span><br><span class="hljs-keyword">if</span> (!beTraversed[i]) &#123;<br>beTraversed[i] = <span class="hljs-keyword">true</span>;<br>queue.offer(i);<br>&#125;<br>&#125;<br>&#125;<br>System.out.println();<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图的遍历&quot;&gt;&lt;a href=&quot;#图的遍历&quot; class=&quot;headerlink&quot; title=&quot;图的遍历&quot;&gt;&lt;/a&gt;&lt;strong&gt;图的遍历&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;一、深度优先搜索-Depth-First-Search-DFS&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>7.2.图的概念和储存结构</title>
    <link href="http://yoursite.com/2022/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.2.%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2022/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.2.%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2022-01-12T14:31:39.000Z</published>
    <updated>2022-02-21T00:54:33.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图-graph"><a href="#图-graph" class="headerlink" title="图(graph)"></a>图(graph)</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-图的定义"><a href="#1-图的定义" class="headerlink" title="1. 图的定义"></a><strong>1. 图的定义</strong></h3><p>定义：图(graph)是由一些点(vertex)和这些点之间的连线(edge)所组成的；其中，点通常被成为”顶点(vertex)”，而点与点之间的连线则被成为”边或弧”(edege)。通常记为，G=(V,E)。</p><h3 id="2-图的种类"><a href="#2-图的种类" class="headerlink" title="2. 图的种类"></a><strong>2. 图的种类</strong></h3><p>根据边是否有方向，将图可以划分为：<strong>无向图</strong>和<strong>有向图</strong></p><h4 id="2-1-无向图"><a href="#2-1-无向图" class="headerlink" title="2.1 无向图"></a><strong>2.1 无向图</strong></h4><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmg3skx7zj308f08fjrg.jpg" alt="img"></a></p><p>上面的图G0是无向图，无向图的所有的边都是不区分方向的。G0=(V1,{E1})。其中，</p><p><strong>(1)</strong> V1={A,B,C,D,E,F}。 V1表示由”A,B,C,D,E,F”几个顶点组成的集合。<br><strong>(2)</strong> E1={(A,B),(A,C),(B,C),(B,E),(B,F),(C,F), (C,D),(E,F),(C,E)}。 E1是由边(A,B),边(A,C)…等等组成的集合。其中，(A,C)表示由顶点A和顶点C连接成的边。</p><p><strong>无向完全图</strong>：在一个无向图中，如果任意两顶点都有一条直接边相连接，则称该图为无向完全图。可以证明，在一个含有n个顶点的无向完全图中，有n（n-1）/2条边。</p><h4 id="2-2-有向图"><a href="#2-2-有向图" class="headerlink" title="2.2 有向图"></a><strong>2.2 有向图</strong></h4><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmg8f6ii6j308f08yt8t.jpg" alt="img"></a></p><p>上面的图G2是有向图。和无向图不同，有向图的所有的边都是有方向的！ G2=(V2,{A2})。其中，</p><p><strong>(1)</strong> V2={A,C,B,F,D,E,G}。 V2表示由”A,B,C,D,E,F,G”几个顶点组成的集合。<br><strong>(2)</strong> A2={&lt;A,B&gt;,&lt;B,C&gt;,&lt;B,F&gt;,&lt;B,E&gt;,&lt;C,E&gt;,&lt;E,D&gt;,&lt;D,C&gt;,&lt;E,B&gt;,&lt;F,G&gt;}。 E1是由矢量&lt;A,B&gt;,矢量&lt;B,C&gt;…等等组成的集合。其中，矢量&lt;A,B&gt;表示由”顶点A”指向”顶点C”的有向边。</p><p><strong>有向完全图</strong>：在有一个有向图中，如果任意两顶点之间都有方向互为相反的两条弧相连接，则称该图为有向完全图。在一个含有n个顶点的有向完全图中，有n(n-1)条边。</p><h3 id="3-邻接点和度"><a href="#3-邻接点和度" class="headerlink" title="3. 邻接点和度"></a><strong>3. 邻接点和度</strong></h3><h4 id="3-1-邻接点"><a href="#3-1-邻接点" class="headerlink" title="3.1 邻接点"></a><strong>3.1 邻接点</strong></h4><p>一条边上的两个顶点叫做邻接点。<br><em>例如，上面无向图G0中的顶点A和顶点C就是邻接点。</em></p><p>在有向图中，除了邻接点之外；还有”入边”和”出边”的概念。<br>顶点的入边，是指以该顶点为终点的边。而顶点的出边，则是指以该顶点为起点的边。<br><em>例如，上面有向图G2中的B和E是邻接点；&lt;B,E&gt;是B的出边，还是E的入边。</em></p><h4 id="3-2-度"><a href="#3-2-度" class="headerlink" title="3.2 度"></a><strong>3.2 度</strong></h4><p>在无向图中，某个顶点的度是邻接到该顶点的边(或弧)的数目。<br><em>例如，上面无向图G0中顶点A的度是2。</em></p><p>在有向图中，度还有”入度”和”出度”之分。<br>某个顶点的入度，是指以该顶点为终点的边的数目。而顶点的出度，则是指以该顶点为起点的边的数目。<br><strong>顶点的度=入度+出度。</strong><br><em>例如，上面有向图G2中，顶点B的入度是2，出度是3；顶点B的度=2+3=5。</em></p><h3 id="4-路径和回路"><a href="#4-路径和回路" class="headerlink" title="4. 路径和回路"></a><strong>4. 路径和回路</strong></h3><p><strong>路径</strong>：如果顶点(Vm)到顶点(Vn)之间存在一个顶点序列。则表示Vm到Vn是一条路径。<br><strong>路径长度</strong>：路径中”边的数量”。<br><strong>简单路径</strong>：若一条路径上顶点不重复出现，则是简单路径。<br><strong>回路</strong>：若路径的第一个顶点和最后一个顶点相同，则是回路。<br><strong>简单回路</strong>：第一个顶点和最后一个顶点相同，其它各顶点都不重复的回路则是简单回路。</p><h3 id="5-连通图和连通分量"><a href="#5-连通图和连通分量" class="headerlink" title="5. 连通图和连通分量"></a><strong>5. 连通图和连通分量</strong></h3><p><strong>连通图</strong>：对无向图而言，<strong>任意两个顶点之间都存在一条无向路径</strong>，则称该无向图为连通图。 对有向图而言，若图中<strong>任意两个顶点之间都存在一条有向路径</strong>，则称该有向图为强连通图。</p><p><strong>连通分量</strong>：<strong>非连通图中的各个连通子图称为该图的连通分量</strong>。</p><h3 id="6-权"><a href="#6-权" class="headerlink" title="6. 权"></a><strong>6. 权</strong></h3><p>在学习”哈夫曼树”的时候，了解过”权”的概念。图中权的概念与此类似。</p><p>边的权、网：与边有关的数据信息称为权(Weight)。在实际应用中，权值可以有某种含义。例如，在一个反映城市交通线路的图中，边上的权值可以表示该条线路的长度或等级；对于一个电子线路图，边上的权值可以表示两个端点之间的电阻、电流或电压值；对于反映工程进度的图而言，边上的权值可以表示从前一个工程到后一个工程所需要的时间或其他代价等。边上带权的图称为网或网络（network）。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/03.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmgsy4rtpj308f08faa6.jpg" alt="img"></a></p><p>上面就是一个带权的图。</p><h3 id="7-生成树"><a href="#7-生成树" class="headerlink" title="7. 生成树"></a>7. 生成树</h3><p>所谓连通图G的生成树，是G的包含其全部n个顶点的一个极小连通子图，所谓极小连通子图是指在包含所有顶点且保证连通的前提下尽可能少地包含原图中的边。生成树必定包含且仅包含连通图G的n-1条边。在生成树中添加任意一条属于原图中的边必定会产生回路，因为新添加的边使其所依附的两个顶点之间有了第二条路径。若生成树中减少任意一条边，则必然成为非连通的。</p><h3 id="8-生成森林"><a href="#8-生成森林" class="headerlink" title="8. 生成森林"></a>8. 生成森林</h3><p>在非连通图中，由每个连通分量都可得到一个极小连通子图，即一棵生成树。这些连通分量的生成树就组成了一个非连通图的生成森林。</p><h2 id="二、图的存储结构"><a href="#二、图的存储结构" class="headerlink" title="二、图的存储结构"></a>二、图的存储结构</h2><h3 id="1-邻接矩阵"><a href="#1-邻接矩阵" class="headerlink" title="1. 邻接矩阵"></a><strong>1. 邻接矩阵</strong></h3><p>邻接矩阵是指用矩阵来表示图。它是采用矩阵来描述图中顶点之间的关系(及弧或边的权)。<br>假设图中顶点数为n，则邻接矩阵定义为：</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/04.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh21hzetj30bl035gln.jpg" alt="img"></a><br>下面通过示意图来进行解释。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/05.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh227kinj30lk08ymxu.jpg" alt="img"></a></p><p>图中的G1是无向图和它对应的邻接矩阵。</p><p>无向图的邻接矩阵是一个对称矩阵，是因为边不具有方向性，所以在邻接矩阵中对角线上皆为0。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/06.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh2xdkz2j30l108ygmb.jpg" alt="img"></a></p><p>图中的G2是无向图和它对应的邻接矩阵。</p><p>有向图由于边具有方向性，因此彼此顶点之间并不能相互达到，所以其邻接矩阵的对称性不再。</p><p>通常采用两个数组来实现邻接矩阵：一个一维数组用来保存顶点信息，一个二维数组来用保存边的信息。而根据实际情况可以分析得，图中的顶点并不是任意两个顶点间都会相连，不是都需要对其边上权重进行存储。那么存储的邻接矩阵实际上会存在大量的0。虽然可以通过稀疏表示等方式对稀疏性高的矩阵进行关键信息的存储，但是却增加了图存储的复杂性。<br><strong>缺点</strong>:就是比较耗费空间。</p><h3 id="2-邻接表"><a href="#2-邻接表" class="headerlink" title="2. 邻接表"></a><strong>2. 邻接表</strong></h3><p>邻接表是图的一种链式存储表示方法。它是改进后的”邻接矩阵”。</p><p><strong>缺点：是不方便判断两个顶点之间是否有边。</strong></p><p><strong>优点：相对邻接矩阵来说更省空间。</strong></p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/07.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh65wupuj30n409hmxw.jpg" alt="img"></a></p><p>图中的G1是无向图和它对应的邻接矩阵。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/08.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh97vnlnj30lk09hdgh.jpg" alt="img"></a></p><p>图中的G2是无向图和它对应的邻接矩阵。</p><p>由此看出，<strong>在对有向图进行表示时，邻接表只能求出图的出度，而无法求出入度。</strong>这个问题很好解决，那就是增加一个表用来存储能够到达某个顶点的相邻顶点。这个表称作逆邻接表。</p><h3 id="3-逆邻接表"><a href="#3-逆邻接表" class="headerlink" title="3. 逆邻接表"></a>3. <strong>逆邻接表</strong></h3><p>逆邻接表与邻接表结构类似，只不过图的顶点链接着能够到达该顶点的相邻顶点。也就是说，邻接表时顺着图中的箭头寻找相邻顶点，而逆邻接表时逆着图中的箭头寻找相邻顶点。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmhhjp483j314o0jedha.jpg" alt="image-20211121085043748"></p><p>邻接表和逆邻接表的共同使用下，就能够把一个完整的有向图结构进行表示。可以发现，邻接表和逆邻接表实际上有一部分数据时重合的，因此可以将两个表合二为一，从而得到了所谓的十字链表。</p><h3 id="4-十字链表"><a href="#4-十字链表" class="headerlink" title="4. 十字链表"></a>4. <strong>十字链表</strong></h3><p>十字链表似乎很简单，只需要通过相同的顶点分别链向以该顶点为终点和起点的相邻顶点即可。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmhjkii88j314e0icgns.jpg" alt="image-20211121085241805"></p><p>但这并不是最优的表示方式。虽然这样的方式共用了中间的顶点存储空间，但是邻接表和逆邻接表的链表节点中重复出现的顶点并没有得到重复利用，反而是进行了再次存储。因此，上图的表示方式还可以进行进一步优化。</p><p>十字链表优化后，可通过扩展的顶点结构和边结构来进行正逆邻接表的存储：（下面的弧头可看作是边的箭头那端，弧尾可看作是边的圆点那端）</p><p><strong>顶点结构</strong></p><blockquote><p><strong>data</strong>：用于存储该顶点中的数据； </p><p><strong>firstin指针</strong>：用于连接以当前顶点为弧头的其他顶点构成的链表，即从别的顶点指进来的顶点；</p><p><strong>firstout指针</strong>：用于连接以当前顶点为弧尾的其他顶点构成的链表，即从该顶点指出去的顶点;</p></blockquote><p><strong>边结构</strong>通过存储两个顶点来确定一条边，同时通过分别代表这两个顶点的指针来与相邻顶点进行链接：</p><blockquote><p><strong>tailvex</strong>：用于存储作为弧尾的顶点的编号； </p><p><strong>headvex</strong>：用于存储作为弧头的顶点的编号； </p><p><strong>headlink 指针</strong>：用于链接下一个存储作为弧头的顶点的节点； </p><p><strong>taillink 指针</strong>：用于链接下一个存储作为弧尾的顶点的节点；</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmhunyr03j31q90u0q7p.jpg" alt="image-20211121090318141"></p><p>以上图为例子，对于顶点A而言，其作为起点能够到达顶点E。因此在邻接表中顶点A要通过边<code>AE</code>（即边04）指向顶点E，顶点A的<code>firstout</code>指针需要指向边04的<code>tailvex</code>。同时，从B出发能够到达A，所以在逆邻接表中顶点A要通过边<code>AB</code>（即边10）指向B，顶点A的<code>firstin</code>指针需要指向边10的弧头，即<code>headlink</code>指针。依次类推。</p><p>十字链表采用了一种看起来比较繁乱的方式对边的方向性进行了表示，能够在尽可能降低存储空间的情况下增加指针保留顶点之间的方向性。具体的操作可能一时间不好弄懂，建议多看几次上图，弄清指针指向的意义，明白正向和逆向邻接表的表示。</p><h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><h3 id="1-邻接矩阵无向图"><a href="#1-邻接矩阵无向图" class="headerlink" title="1. 邻接矩阵无向图"></a>1. 邻接矩阵无向图</h3><p><strong>基本定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里介绍提供了两个创建矩阵的方法。一个是<strong>用已知数据</strong>，另一个则<strong>需要用户手动输入数据</strong>。</p><h4 id="1-1-创建图-用已提供的矩阵"><a href="#1-1-创建图-用已提供的矩阵" class="headerlink" title="1.1 创建图(用已提供的矩阵)"></a><strong>1.1 创建图(用已提供的矩阵)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 创建图(用已提供的矩阵)<br> *<br> * 参数说明：<br> *     vexs  -- 顶点数组<br> *     edges -- 边数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MatrixUDG</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vexs, <span class="hljs-keyword">char</span>[][] edges)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span><br>    <span class="hljs-keyword">int</span> vlen = vexs.length;<br>    <span class="hljs-keyword">int</span> elen = edges.length;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++)<br>        mVexs[i] = vexs[i];<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    mMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vlen][vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i][<span class="hljs-number">1</span>]);<br><br>        mMatrix[p1][p2] = <span class="hljs-number">1</span>;<br>        mMatrix[p2][p1] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是利用已知数据来创建一个邻接矩阵无向图。 实际上，在本文的测试程序源码中，该方法创建的无向图就是上面图G1。具体的调用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] vexs = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;;<br>    <span class="hljs-keyword">char</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[][]&#123;<br>        &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>&#125;, <br>        &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'D'</span>&#125;, <br>        &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'F'</span>&#125;, <br>        &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>&#125;, <br>        &#123;<span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>&#125;, <br>        &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'G'</span>&#125;, <br>        &#123;<span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;&#125;;<br>    MatrixUDG pG;<br><br>    pG = <span class="hljs-keyword">new</span> MatrixUDG(vexs, edges);<br></code></pre></td></tr></table></figure><h4 id="1-2-创建图-自己输入"><a href="#1-2-创建图-自己输入" class="headerlink" title="1.2 创建图(自己输入)"></a><strong>1.2 创建图(自己输入)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 创建图(自己输入数据)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MatrixUDG</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 输入"顶点数"和"边数"</span><br>    System.out.printf(<span class="hljs-string">"input vertex number: "</span>);<br>    <span class="hljs-keyword">int</span> vlen = readInt();<br>    System.out.printf(<span class="hljs-string">"input edge number: "</span>);<br>    <span class="hljs-keyword">int</span> elen = readInt();<br>    <span class="hljs-keyword">if</span> ( vlen &lt; <span class="hljs-number">1</span> || elen &lt; <span class="hljs-number">1</span> || (elen &gt; (vlen*(vlen - <span class="hljs-number">1</span>)))) &#123;<br>        System.out.printf(<span class="hljs-string">"input error: invalid parameters!\n"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        System.out.printf(<span class="hljs-string">"vertex(%d): "</span>, i);<br>        mVexs[i] = readChar();<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    mMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vlen][vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        System.out.printf(<span class="hljs-string">"edge(%d):"</span>, i);<br>        <span class="hljs-keyword">char</span> c1 = readChar();<br>        <span class="hljs-keyword">char</span> c2 = readChar();<br>        <span class="hljs-keyword">int</span> p1 = getPosition(c1);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(c2);<br><br>        <span class="hljs-keyword">if</span> (p1==-<span class="hljs-number">1</span> || p2==-<span class="hljs-number">1</span>) &#123;<br>            System.out.printf(<span class="hljs-string">"input error: invalid edge!\n"</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        mMatrix[p1][p2] = <span class="hljs-number">1</span>;<br>        mMatrix[p2][p1] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-邻接矩阵有向图"><a href="#2-邻接矩阵有向图" class="headerlink" title="2. 邻接矩阵有向图"></a><strong>2. 邻接矩阵有向图</strong></h3><p><strong>基本定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里介绍提供了两个创建矩阵的方法。一个是<strong>用已知数据</strong>，另一个则<strong>需要用户手动输入数据</strong>。</p><h4 id="2-1-创建图-用已提供的矩阵"><a href="#2-1-创建图-用已提供的矩阵" class="headerlink" title="2.1 创建图(用已提供的矩阵)"></a><strong>2.1 创建图(用已提供的矩阵)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 创建图(用已提供的矩阵)<br> *<br> * 参数说明：<br> *     vexs  -- 顶点数组<br> *     edges -- 边数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MatrixDG</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vexs, <span class="hljs-keyword">char</span>[][] edges)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span><br>    <span class="hljs-keyword">int</span> vlen = vexs.length;<br>    <span class="hljs-keyword">int</span> elen = edges.length;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++)<br>        mVexs[i] = vexs[i];<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    mMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vlen][vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i][<span class="hljs-number">1</span>]);<br><br>        mMatrix[p1][p2] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是创建一个邻接矩阵有向图。实际上，该方法创建的有向图，就是上面的图G2。它的调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] vexs = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;;<br><span class="hljs-keyword">char</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[][]&#123;<br>    &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>&#125;, <br>    &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>&#125;, <br>    &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'E'</span>&#125;, <br>    &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'F'</span>&#125;, <br>    &#123;<span class="hljs-string">'C'</span>, <span class="hljs-string">'E'</span>&#125;, <br>    &#123;<span class="hljs-string">'D'</span>, <span class="hljs-string">'C'</span>&#125;, <br>    &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'B'</span>&#125;, <br>    &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'D'</span>&#125;, <br>    &#123;<span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;&#125;; <br>MatrixDG pG;<br><br>pG = <span class="hljs-keyword">new</span> MatrixDG(vexs, edges);<br></code></pre></td></tr></table></figure><h4 id="2-2-创建图-自己输入"><a href="#2-2-创建图-自己输入" class="headerlink" title="2.2 创建图(自己输入)"></a><strong>2.2 创建图(自己输入)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 创建图(自己输入数据)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MatrixDG</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 输入"顶点数"和"边数"</span><br>    System.out.printf(<span class="hljs-string">"input vertex number: "</span>);<br>    <span class="hljs-keyword">int</span> vlen = readInt();<br>    System.out.printf(<span class="hljs-string">"input edge number: "</span>);<br>    <span class="hljs-keyword">int</span> elen = readInt();<br>    <span class="hljs-keyword">if</span> ( vlen &lt; <span class="hljs-number">1</span> || elen &lt; <span class="hljs-number">1</span> || (elen &gt; (vlen*(vlen - <span class="hljs-number">1</span>)))) &#123;<br>        System.out.printf(<span class="hljs-string">"input error: invalid parameters!\n"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        System.out.printf(<span class="hljs-string">"vertex(%d): "</span>, i);<br>        mVexs[i] = readChar();<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    mMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vlen][vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        System.out.printf(<span class="hljs-string">"edge(%d):"</span>, i);<br>        <span class="hljs-keyword">char</span> c1 = readChar();<br>        <span class="hljs-keyword">char</span> c2 = readChar();<br>        <span class="hljs-keyword">int</span> p1 = getPosition(c1);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(c2);<br><br>        <span class="hljs-keyword">if</span> (p1==-<span class="hljs-number">1</span> || p2==-<span class="hljs-number">1</span>) &#123;<br>            System.out.printf(<span class="hljs-string">"input error: invalid edge!\n"</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        mMatrix[p1][p2] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-邻接表无向图"><a href="#3-邻接表无向图" class="headerlink" title="3. 邻接表无向图"></a><strong>3. 邻接表无向图</strong></h3><p><strong>基本定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListUDG</span> </span>&#123;<br>    <span class="hljs-comment">// 邻接表中表对应的链表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ENode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ivex;       <span class="hljs-comment">// 该边所指向的顶点的位置</span><br>        ENode nextEdge; <span class="hljs-comment">// 指向下一条弧的指针</span><br>    &#125;<br><br>    <span class="hljs-comment">// 邻接表中表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VNode</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> data;          <span class="hljs-comment">// 顶点信息</span><br>        ENode firstEdge;    <span class="hljs-comment">// 指向第一条依附该顶点的弧</span><br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> VNode[] mVexs;  <span class="hljs-comment">// 顶点数组</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>(1)</strong> ListUDG是邻接表对应的结构体。mVexs则是保存顶点信息的一维数组。<br><strong>(2)</strong> VNode是邻接表顶点对应的结构体。 data是顶点所包含的数据，而firstEdge是该顶点所包含链表的表头指针。<br><strong>(3)</strong> ENode是邻接表顶点所包含的链表的节点对应的结构体。 ivex是该节点所对应的顶点在vexs中的索引，而nextEdge是指向下一个节点的。</p><h4 id="3-1-创建图-用已提供的矩阵"><a href="#3-1-创建图-用已提供的矩阵" class="headerlink" title="3.1 创建图(用已提供的矩阵)"></a><strong>3.1 创建图(用已提供的矩阵)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 创建图(用已提供的矩阵)<br> *<br> * 参数说明：<br> *     vexs  -- 顶点数组<br> *     edges -- 边数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListUDG</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vexs, <span class="hljs-keyword">char</span>[][] edges)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span><br>    <span class="hljs-keyword">int</span> vlen = vexs.length;<br>    <span class="hljs-keyword">int</span> elen = edges.length;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> VNode[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        mVexs[i] = <span class="hljs-keyword">new</span> VNode();<br>        mVexs[i].data = vexs[i];<br>        mVexs[i].firstEdge = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">char</span> c1 = edges[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">char</span> c2 = edges[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i][<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 初始化node1</span><br>        ENode node1 = <span class="hljs-keyword">new</span> ENode();<br>        node1.ivex = p2;<br>        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p1].firstEdge = node1;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p1].firstEdge, node1);<br>        <span class="hljs-comment">// 初始化node2</span><br>        ENode node2 = <span class="hljs-keyword">new</span> ENode();<br>        node2.ivex = p1;<br>        <span class="hljs-comment">// 将node2链接到"p2所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p2].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p2].firstEdge = node2;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p2].firstEdge, node2);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是创建一个邻接表无向图。实际上，该方法创建的无向图，就是上面图G1。调用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] vexs = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;;<br><span class="hljs-keyword">char</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[][]&#123;<br>    &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>&#125;, <br>    &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'D'</span>&#125;, <br>    &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'F'</span>&#125;, <br>    &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>&#125;, <br>    &#123;<span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>&#125;, <br>    &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'G'</span>&#125;, <br>    &#123;<span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;&#125;;<br>ListUDG pG;<br><br>pG = <span class="hljs-keyword">new</span> ListUDG(vexs, edges);<br></code></pre></td></tr></table></figure><h4 id="3-2-创建图-自己输入"><a href="#3-2-创建图-自己输入" class="headerlink" title="3.2 创建图(自己输入)"></a><strong>3.2 创建图(自己输入)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 创建图(自己输入数据)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListUDG</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 输入"顶点数"和"边数"</span><br>    System.out.printf(<span class="hljs-string">"input vertex number: "</span>);<br>    <span class="hljs-keyword">int</span> vlen = readInt();<br>    System.out.printf(<span class="hljs-string">"input edge number: "</span>);<br>    <span class="hljs-keyword">int</span> elen = readInt();<br>    <span class="hljs-keyword">if</span> ( vlen &lt; <span class="hljs-number">1</span> || elen &lt; <span class="hljs-number">1</span> || (elen &gt; (vlen*(vlen - <span class="hljs-number">1</span>)))) &#123;<br>        System.out.printf(<span class="hljs-string">"input error: invalid parameters!\n"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> VNode[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        System.out.printf(<span class="hljs-string">"vertex(%d): "</span>, i);<br>        mVexs[i] = <span class="hljs-keyword">new</span> VNode();<br>        mVexs[i].data = readChar();<br>        mVexs[i].firstEdge = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    <span class="hljs-comment">//mMatrix = new int[vlen][vlen];</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        System.out.printf(<span class="hljs-string">"edge(%d):"</span>, i);<br>        <span class="hljs-keyword">char</span> c1 = readChar();<br>        <span class="hljs-keyword">char</span> c2 = readChar();<br>        <span class="hljs-keyword">int</span> p1 = getPosition(c1);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(c2);<br>        <span class="hljs-comment">// 初始化node1</span><br>        ENode node1 = <span class="hljs-keyword">new</span> ENode();<br>        node1.ivex = p2;<br>        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p1].firstEdge = node1;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p1].firstEdge, node1);<br>        <span class="hljs-comment">// 初始化node2</span><br>        ENode node2 = <span class="hljs-keyword">new</span> ENode();<br>        node2.ivex = p1;<br>        <span class="hljs-comment">// 将node2链接到"p2所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p2].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p2].firstEdge = node2;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p2].firstEdge, node2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-邻接表有向图"><a href="#4-邻接表有向图" class="headerlink" title="4. 邻接表有向图"></a><strong>4. 邻接表有向图</strong></h3><p><strong>基本定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListDG</span> </span>&#123;<br>    <span class="hljs-comment">// 邻接表中表对应的链表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ENode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ivex;       <span class="hljs-comment">// 该边所指向的顶点的位置</span><br>        ENode nextEdge; <span class="hljs-comment">// 指向下一条弧的指针</span><br>    &#125;<br><br>    <span class="hljs-comment">// 邻接表中表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VNode</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> data;          <span class="hljs-comment">// 顶点信息</span><br>        ENode firstEdge;    <span class="hljs-comment">// 指向第一条依附该顶点的弧</span><br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> VNode[] mVexs;  <span class="hljs-comment">// 顶点数组</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>(1)</strong> ListDG是邻接表对应的结构体。 mVexs则是保存顶点信息的一维数组。<br><strong>(2)</strong> VNode是邻接表顶点对应的结构体。 data是顶点所包含的数据，而firstEdge是该顶点所包含链表的表头指针。<br><strong>(3)</strong> ENode是邻接表顶点所包含的链表的节点对应的结构体。 ivex是该节点所对应的顶点在vexs中的索引，而nextEdge是指向下一个节点的。</p><h4 id="4-1-创建图-用已提供的矩阵"><a href="#4-1-创建图-用已提供的矩阵" class="headerlink" title="4.1 创建图(用已提供的矩阵)"></a><strong>4.1 创建图(用已提供的矩阵)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 创建图(用已提供的矩阵)<br> *<br> * 参数说明：<br> *     vexs  -- 顶点数组<br> *     edges -- 边数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListDG</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vexs, <span class="hljs-keyword">char</span>[][] edges)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span><br>    <span class="hljs-keyword">int</span> vlen = vexs.length;<br>    <span class="hljs-keyword">int</span> elen = edges.length;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> VNode[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        mVexs[i] = <span class="hljs-keyword">new</span> VNode();<br>        mVexs[i].data = vexs[i];<br>        mVexs[i].firstEdge = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">char</span> c1 = edges[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">char</span> c2 = edges[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i][<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-comment">// 初始化node1</span><br>        ENode node1 = <span class="hljs-keyword">new</span> ENode();<br>        node1.ivex = p2;<br>        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p1].firstEdge = node1;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p1].firstEdge, node1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是创建一个邻接表有向图。实际上，该方法创建的有向图，就是上面的图G2。该函数的调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] vexs = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;;<br>    <span class="hljs-keyword">char</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[][]&#123;<br>        &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>&#125;, <br>        &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>&#125;, <br>        &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'E'</span>&#125;, <br>        &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'F'</span>&#125;, <br>        &#123;<span class="hljs-string">'C'</span>, <span class="hljs-string">'E'</span>&#125;, <br>        &#123;<span class="hljs-string">'D'</span>, <span class="hljs-string">'C'</span>&#125;, <br>        &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'B'</span>&#125;, <br>        &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'D'</span>&#125;, <br>        &#123;<span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;&#125;; <br>    ListDG pG;<br><br>    pG = <span class="hljs-keyword">new</span> ListDG(vexs, edges);<br></code></pre></td></tr></table></figure><h4 id="4-2-创建图-自己输入"><a href="#4-2-创建图-自己输入" class="headerlink" title="4.2 创建图(自己输入)"></a><strong>4.2 创建图(自己输入)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 创建图(自己输入数据)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListDG</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 输入"顶点数"和"边数"</span><br>    System.out.printf(<span class="hljs-string">"input vertex number: "</span>);<br>    <span class="hljs-keyword">int</span> vlen = readInt();<br>    System.out.printf(<span class="hljs-string">"input edge number: "</span>);<br>    <span class="hljs-keyword">int</span> elen = readInt();<br>    <span class="hljs-keyword">if</span> ( vlen &lt; <span class="hljs-number">1</span> || elen &lt; <span class="hljs-number">1</span> || (elen &gt; (vlen*(vlen - <span class="hljs-number">1</span>)))) &#123;<br>        System.out.printf(<span class="hljs-string">"input error: invalid parameters!\n"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> VNode[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        System.out.printf(<span class="hljs-string">"vertex(%d): "</span>, i);<br>        mVexs[i] = <span class="hljs-keyword">new</span> VNode();<br>        mVexs[i].data = readChar();<br>        mVexs[i].firstEdge = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    <span class="hljs-comment">//mMatrix = new int[vlen][vlen];</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        System.out.printf(<span class="hljs-string">"edge(%d):"</span>, i);<br>        <span class="hljs-keyword">char</span> c1 = readChar();<br>        <span class="hljs-keyword">char</span> c2 = readChar();<br>        <span class="hljs-keyword">int</span> p1 = getPosition(c1);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(c2);<br>        <span class="hljs-comment">// 初始化node1</span><br>        ENode node1 = <span class="hljs-keyword">new</span> ENode();<br>        node1.ivex = p2;<br>        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p1].firstEdge = node1;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p1].firstEdge, node1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图-graph&quot;&gt;&lt;a href=&quot;#图-graph&quot; class=&quot;headerlink&quot; title=&quot;图(graph)&quot;&gt;&lt;/a&gt;图(graph)&lt;/h1&gt;&lt;h2 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>7.1.图的思维导图</title>
    <link href="http://yoursite.com/2022/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.1.%E5%9B%BE%E7%9A%84%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://yoursite.com/2022/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.1.%E5%9B%BE%E7%9A%84%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</id>
    <published>2022-01-12T14:30:39.000Z</published>
    <updated>2022-02-21T00:54:33.464Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/10/04/08RwKH.jpg" alt="08RwKH.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/10/04/08RwKH.jpg&quot; alt=&quot;08RwKH.jpg&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>6.5.斐波那契堆</title>
    <link href="http://yoursite.com/2022/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.5.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86/"/>
    <id>http://yoursite.com/2022/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.5.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86/</id>
    <published>2022-01-11T14:38:39.000Z</published>
    <updated>2022-02-21T00:54:33.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="斐波那契堆-Fibonacci-heap"><a href="#斐波那契堆-Fibonacci-heap" class="headerlink" title="斐波那契堆(Fibonacci heap)"></a>斐波那契堆(Fibonacci heap)</h1><h2 id="斐波那契堆介绍"><a href="#斐波那契堆介绍" class="headerlink" title="斐波那契堆介绍"></a>斐波那契堆介绍</h2><p>斐波那契堆(Fibonacci heap)是一种可合并堆，可用于实现合并优先队列。</p><p>它比二项堆具有更好的平摊分析性能，它的合并操作的时间复杂度是O(1)。<br>与二项堆一样，它也是由一组堆最小有序树组成，并且是一种可合并堆。<br>与二项堆不同的是，斐波那契堆中的树不一定是二项树；而且二项堆中的树是有序排列的，但是斐波那契堆中的树都是有根而无序的。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/111642221538159.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm26qa506j30qa098aaq.jpg" alt="img"></a></p><h2 id="斐波那契堆的基本操作"><a href="#斐波那契堆的基本操作" class="headerlink" title="斐波那契堆的基本操作"></a><strong>斐波那契堆的基本操作</strong></h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FibHeap</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> keyNum;         <span class="hljs-comment">// 堆中节点的总数</span><br>    <span class="hljs-keyword">private</span> FibNode min;        <span class="hljs-comment">// 最小节点(某个最小堆的根节点)</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FibNode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> key;            <span class="hljs-comment">// 关键字(键值)</span><br>        <span class="hljs-keyword">int</span> degree;         <span class="hljs-comment">// 度数</span><br>        FibNode left;       <span class="hljs-comment">// 左兄弟</span><br>        FibNode right;      <span class="hljs-comment">// 右兄弟</span><br>        FibNode child;      <span class="hljs-comment">// 第一个孩子节点</span><br>        FibNode parent;     <span class="hljs-comment">// 父节点</span><br>        <span class="hljs-keyword">boolean</span> marked;     <span class="hljs-comment">// 是否被删除第一个孩子</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FibNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key    = key;<br>            <span class="hljs-keyword">this</span>.degree = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>.marked = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">this</span>.left   = <span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">this</span>.right  = <span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">this</span>.child  = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>FibNode</strong>是斐波那契堆的节点类，它包含的信息较多。key是用于比较节点大小的，degree是记录节点的度，left和right分别是指向节点的左右兄弟，child是节点的第一个孩子，parent是节点的父节点，marked是记录该节点是否被删除第1个孩子(marked在删除节点时有用)。<br><strong>FibHeap</strong>是斐波那契堆对应的类。min是保存当前堆的最小节点，keyNum用于记录堆中节点的总数，maxDegree用于记录堆中最大度，而cons在删除节点时来暂时保存堆数据的临时空间。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/111643182933476.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm29eesmsj31080u0mzh.jpg" alt="img"></a></p><p>上面是斐波那契堆的两种不同结构图的对比。从中可以看出，斐波那契堆是由一组最小堆组成，这些最小堆的根节点组成了双向链表(后文称为”<strong>根链表</strong>“)；斐波那契堆中的最小节点就是”根链表中的最小节点”！</p><h3 id="2-插入操作"><a href="#2-插入操作" class="headerlink" title="2. 插入操作"></a><strong>2. 插入操作</strong></h3><p>插入操作非常简单：插入一个节点到堆中，直接将该节点插入到”根链表的min节点”之前即可；若被插入节点比”min节点”小，则更新”min节点”为被插入节点。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/111644494183536.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm29vi11lj30eq0f9wez.jpg" alt="img"></a></p><p><em>上面是插入操作的示意图。</em></p><p>斐波那契堆的根链表是”双向链表”，这里将min节点看作双向联表的表头(后文也是如此)。在插入节点时，每次都是”将节点插入到min节点之前(即插入到双链表末尾)”。此外，对于根链表中最小堆都只有一个节点的情况，插入操作就很演化成双向链表的插入操作。</p><p>插入操作代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 将node堆结点加入root结点之前(循环链表中)<br> *   a …… root<br> *   a …… node …… root<br>*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(FibNode node, FibNode root)</span> </span>&#123;<br>    node.left        = root.left;<br>    root.left.right  = node;<br>    node.right       = root;<br>    root.left        = node;<br>&#125;<br> <br><span class="hljs-comment">/*<br> * 将节点node插入到斐波那契堆中<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(FibNode node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (keyNum == <span class="hljs-number">0</span>)<br>        min = node;<br>    <span class="hljs-keyword">else</span> &#123;<br>        addNode(node, min);<br>        <span class="hljs-keyword">if</span> (node.key &lt; min.key)<br>            min = node;<br>    &#125;<br><br>    keyNum++;<br>&#125;<br> <br><span class="hljs-comment">/* <br> * 新建键值为key的节点，并将其插入到斐波那契堆中<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    FibNode node;<br><br>    node = <span class="hljs-keyword">new</span> FibNode(key);<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> ;<br><br>    insert(node);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-合并操作"><a href="#3-合并操作" class="headerlink" title="3. 合并操作"></a><strong>3. 合并操作</strong></h3><p>合并操作和插入操作的原理非常类似：将一个堆的根链表插入到另一个堆的根链表上即可。简单来说，就是将两个双链表拼接成一个双向链表。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/111646216536924.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm2albn5kj30pr0ix3zv.jpg" alt="img"></a></p><p>合并操作代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br>* 将双向链表b链接到双向链表a的后面<br>*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">catList</span><span class="hljs-params">(FibNode a, FibNode b)</span> </span>&#123;<br>    FibNode tmp;<br><br>    tmp           = a.right;<br>    a.right       = b.right;<br>    b.right.left  = a;<br>    b.right       = tmp;<br>    tmp.left      = b;<br>&#125;<br><br><span class="hljs-comment">/*<br> * 将other合并到当前堆中<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(FibHeap other)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (other==<span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-keyword">if</span>((<span class="hljs-keyword">this</span>.min) == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// this无"最小节点"</span><br>        <span class="hljs-keyword">this</span>.min = other.min;<br>        <span class="hljs-keyword">this</span>.keyNum = other.keyNum;<br>        other = <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((other.min) == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// this有"最小节点" &amp;&amp; other无"最小节点"</span><br>        other = <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">// this有"最小节点" &amp;&amp; other有"最小节点"</span><br>        <span class="hljs-comment">// 将"other中根链表"添加到"this"中</span><br>    catList(<span class="hljs-keyword">this</span>.min, other.min) ;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.min.key &gt; other.min.key)<br>            <span class="hljs-keyword">this</span>.min = other.min;<br>        <span class="hljs-keyword">this</span>.keyNum += other.keyNum;<br>        other = <span class="hljs-keyword">null</span>;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-取出最小节点"><a href="#4-取出最小节点" class="headerlink" title="4. 取出最小节点"></a><strong>4. 取出最小节点</strong></h3><p>抽取最小结点的操作是斐波那契堆中较复杂的操作。<br>(1）将要抽取最小结点的子树都直接串联在根表中；<br>(2）合并所有degree相等的树，直到没有相等的degree的树。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm2bg4704j30sw3h2wqi.jpg" alt="img"></p><p>取出最小节点代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 将node链接到root根结点<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">link</span><span class="hljs-params">(FibNode node, FibNode root)</span> </span>&#123;<br>    <span class="hljs-comment">// 将node从双链表中移除</span><br>    removeNode(node);<br>    <span class="hljs-comment">// 将node设为root的孩子</span><br>    <span class="hljs-keyword">if</span> (root.child == <span class="hljs-keyword">null</span>)<br>        root.child = node;<br>    <span class="hljs-keyword">else</span><br>        addNode(node, root.child);<br><br>    node.parent = root;<br>    root.degree++;<br>    node.marked = <span class="hljs-keyword">false</span>;<br>&#125;<br> <br><span class="hljs-comment">/* <br> * 合并斐波那契堆的根链表中左右相同度数的树<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consolidate</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 计算log2(keyNum)，floor意味着向上取整！</span><br><span class="hljs-comment">// ex. log2(13) = 3，向上取整为4。</span><br>    <span class="hljs-keyword">int</span> maxDegree = (<span class="hljs-keyword">int</span>) Math.floor(Math.log(keyNum) / Math.log(<span class="hljs-number">2.0</span>));<br>    <span class="hljs-keyword">int</span> D = maxDegree + <span class="hljs-number">1</span>;<br>    FibNode[] cons = <span class="hljs-keyword">new</span> FibNode[D+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; D; i++)<br>        cons[i] = <span class="hljs-keyword">null</span>;<br> <br>    <span class="hljs-comment">// 合并相同度的根节点，使每个度数的树唯一</span><br>    <span class="hljs-keyword">while</span> (min != <span class="hljs-keyword">null</span>) &#123;<br>        FibNode x = extractMin();            <span class="hljs-comment">// 取出堆中的最小树(最小节点所在的树)</span><br>        <span class="hljs-keyword">int</span> d = x.degree;                        <span class="hljs-comment">// 获取最小树的度数</span><br>        <span class="hljs-comment">// cons[d] != null，意味着有两棵树(x和y)的"度数"相同。</span><br>        <span class="hljs-keyword">while</span> (cons[d] != <span class="hljs-keyword">null</span>) &#123;<br>            FibNode y = cons[d];                <span class="hljs-comment">// y是"与x的度数相同的树" </span><br>            <span class="hljs-keyword">if</span> (x.key &gt; y.key) &#123;    <span class="hljs-comment">// 保证x的键值比y小</span><br>                FibNode tmp = x;<br>                x = y;<br>                y = tmp;<br>            &#125;<br><br>            link(y, x);    <span class="hljs-comment">// 将y链接到x中</span><br>            cons[d] = <span class="hljs-keyword">null</span>;<br>            d++;<br>        &#125;<br>        cons[d] = x;<br>    &#125;<br>    min = <span class="hljs-keyword">null</span>;<br> <br>    <span class="hljs-comment">// 将cons中的结点重新加到根表中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;D; i++) &#123;<br><br>        <span class="hljs-keyword">if</span> (cons[i] != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-keyword">null</span>)<br>                min = cons[i];<br>            <span class="hljs-keyword">else</span> &#123;<br>                addNode(cons[i], min);<br>                <span class="hljs-keyword">if</span> ((cons[i]).key &lt; min.key)<br>                    min = cons[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">/*<br> * 移除最小节点<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeMin</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> ;<br><br>    FibNode m = min;<br>    <span class="hljs-comment">// 将min每一个儿子(儿子和儿子的兄弟)都添加到"斐波那契堆的根链表"中</span><br>    <span class="hljs-keyword">while</span> (m.child != <span class="hljs-keyword">null</span>) &#123;<br>        FibNode child = m.child;<br><br>        removeNode(child);<br>        <span class="hljs-keyword">if</span> (child.right == child)<br>            m.child = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">else</span><br>            m.child = child.right;<br><br>        addNode(child, min);<br>        child.parent = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将m从根链表中移除</span><br>    removeNode(m);<br>    <span class="hljs-comment">// 若m是堆中唯一节点，则设置堆的最小节点为null；</span><br>    <span class="hljs-comment">// 否则，设置堆的最小节点为一个非空节点(m.right)，然后再进行调节。</span><br>    <span class="hljs-keyword">if</span> (m.right == m)<br>        min = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        min = m.right;<br>        consolidate();<br>    &#125;<br>    keyNum--;<br><br>    m = <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-减小节点值"><a href="#5-减小节点值" class="headerlink" title="5. 减小节点值"></a><strong>5. 减小节点值</strong></h3><p>减少斐波那契堆中的节点的键值，这个操作的难点是：如果减少节点后破坏了”最小堆”性质，如何去维护呢？下面对一般性情况进行分析。<br>(1) 首先，将”被减小节点”从”它所在的最小堆”剥离出来；然后将”该节点”关联到”根链表”中。 倘若被减小的节点不是单独一个节点，而是包含子树的树根。则是将以”被减小节点”为根的子树从”最小堆”中剥离出来，然后将该树关联到根链表中。<br>(2) 接着，对”被减少节点”的原父节点进行”级联剪切”。所谓”级联剪切”，就是在被减小节点破坏了最小堆性质，并被切下来之后；再从”它的父节点”进行递归级联剪切操作。<br>   而级联操作的具体动作则是：若父节点(被减小节点的父节点)的marked标记为false，则将其设为true，然后退出。<br>                             否则，将父节点从最小堆中切下来(方式和”切被减小节点的方式”一样)；然后递归对祖父节点进行”级联剪切”。<br>   marked标记的作用就是用来标记”该节点的子节点是否有被删除过”，它的作用是来实现级联剪切。而级联剪切的真正目的是为了防止”最小堆”由二叉树演化成链表。<br>(3) 最后，别忘了对根链表的最小节点进行更新。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm2cc7b3xj30gb0qata7.jpg" alt="img"></p><p>减小节点值的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 修改度数<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">renewDegree</span><span class="hljs-params">(FibNode parent, <span class="hljs-keyword">int</span> degree)</span> </span>&#123;<br>    parent.degree -= degree;<br>    <span class="hljs-keyword">if</span> (parent. parent != <span class="hljs-keyword">null</span>)<br>        renewDegree(parent.parent, degree);<br>&#125;<br> <br><span class="hljs-comment">/* <br> * 将node从父节点parent的子链接中剥离出来，<br> * 并使node成为"堆的根链表"中的一员。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(FibNode node, FibNode parent)</span> </span>&#123;<br>    removeNode(node);<br>    renewDegree(parent, node.degree);<br>    <span class="hljs-comment">// node没有兄弟</span><br>    <span class="hljs-keyword">if</span> (node == node.right) <br>        parent.child = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">else</span> <br>        parent.child = node.right;<br><br>    node.parent = <span class="hljs-keyword">null</span>;<br>    node.left = node.right = node;<br>    node.marked = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 将"node所在树"添加到"根链表"中</span><br>    addNode(node, min);<br>&#125;<br><br><span class="hljs-comment">/* <br> * 对节点node进行"级联剪切"<br> *<br> * 级联剪切：如果减小后的结点破坏了最小堆性质，<br> *     则把它切下来(即从所在双向链表中删除，并将<br> *     其插入到由最小树根节点形成的双向链表中)，<br> *     然后再从"被切节点的父节点"到所在树根节点递归执行级联剪枝<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cascadingCut</span><span class="hljs-params">(FibNode node)</span> </span>&#123;<br>    FibNode parent = node.parent;<br><br>    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node.marked == <span class="hljs-keyword">false</span>) <br>            node.marked = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cut(node, parent);<br>            cascadingCut(parent);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* <br> * 将斐波那契堆中节点node的值减少为key<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(FibNode node, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span> ||node==<span class="hljs-keyword">null</span>) <br>        <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-keyword">if</span> (key &gt; node.key) &#123;<br>    System.out.printf(<span class="hljs-string">"decrease failed: the new key(%d) is no smaller than current key(%d)\n"</span>, key, node.key);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    FibNode parent = node.parent;<br>    node.key = key;<br>    <span class="hljs-keyword">if</span> (parent!=<span class="hljs-keyword">null</span> &amp;&amp; (node.key &lt; parent.key)) &#123;<br>        <span class="hljs-comment">// 将node从父节点parent中剥离出来，并将node添加到根链表中</span><br>        cut(node, parent);<br>        cascadingCut(parent);<br>    &#125;<br><br>    <span class="hljs-comment">// 更新最小节点</span><br>    <span class="hljs-keyword">if</span> (node.key &lt; min.key)<br>        min = node;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-增加节点值"><a href="#6-增加节点值" class="headerlink" title="6. 增加节点值"></a><strong>6. 增加节点值</strong></h3><p>增加节点值和减少节点值类似，这个操作的难点也是如何维护”最小堆”性质。思路如下：<br>(1) 将”被增加节点”的”左孩子和左孩子的所有兄弟”都链接到根链表中。<br>(2) 接下来，把”被增加节点”添加到根链表；但是别忘了对其进行级联剪切。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/111650112008396.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm2d0uo2wj30ic0xmtav.jpg" alt="img"></a></p><p>增加节点值的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 将斐波那契堆中节点node的值增加为key<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">(FibNode node, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span> ||node==<span class="hljs-keyword">null</span>) <br>        <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-keyword">if</span> ( key &lt;= node.key) &#123;<br>    System.out.printf(<span class="hljs-string">"increase failed: the new key(%d) is no greater than current key(%d)\n"</span>, key, node.key);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 将node每一个儿子(不包括孙子,重孙,...)都添加到"斐波那契堆的根链表"中</span><br>    <span class="hljs-keyword">while</span> (node.child != <span class="hljs-keyword">null</span>) &#123;<br>        FibNode child = node.child;<br>        removeNode(child);               <span class="hljs-comment">// 将child从node的子链表中删除</span><br>        <span class="hljs-keyword">if</span> (child.right == child)<br>            node.child = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">else</span><br>            node.child = child.right;<br><br>        addNode(child, min);       <span class="hljs-comment">// 将child添加到根链表中</span><br>        child.parent = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    node.degree = <span class="hljs-number">0</span>;<br>    node.key = key;<br><br>    <span class="hljs-comment">// 如果node不在根链表中，</span><br>    <span class="hljs-comment">//     则将node从父节点parent的子链接中剥离出来，</span><br>    <span class="hljs-comment">//     并使node成为"堆的根链表"中的一员，</span><br>    <span class="hljs-comment">//     然后进行"级联剪切"</span><br>    <span class="hljs-comment">// 否则，则判断是否需要更新堆的最小节点</span><br>    FibNode parent = node.parent;<br>    <span class="hljs-keyword">if</span>(parent != <span class="hljs-keyword">null</span>) &#123;<br>        cut(node, parent);<br>        cascadingCut(parent);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(min == node) &#123;<br>        FibNode right = node.right;<br>        <span class="hljs-keyword">while</span>(right != node) &#123;<br>            <span class="hljs-keyword">if</span>(node.key &gt; right.key)<br>                min = right;<br>            right = right.right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-删除节点"><a href="#7-删除节点" class="headerlink" title="7. 删除节点"></a><strong>7. 删除节点</strong></h3><p>删除节点，本文采用了操作是：”取出最小节点”和”减小节点值”的组合。<br>(1) 先将被删除节点的键值减少。减少后的值要比”原最小节点的值”即可。<br>(2) 接着，取出最小节点即可。</p><p>删除节点值的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 删除结点node<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(FibNode node)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = min.key;<br>    decrease(node, m-<span class="hljs-number">1</span>);<br>    removeMin();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="斐波那契堆的Java实现"><a href="#斐波那契堆的Java实现" class="headerlink" title="斐波那契堆的Java实现"></a><strong>斐波那契堆的Java实现</strong></h2><h3 id="斐波那契堆的实现文件-FibHeap-java"><a href="#斐波那契堆的实现文件-FibHeap-java" class="headerlink" title="斐波那契堆的实现文件(FibHeap.java)"></a>斐波那契堆的实现文件(FibHeap.java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FibHeap</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> keyNum;         <span class="hljs-comment">// 堆中节点的总数</span><br>    <span class="hljs-keyword">private</span> FibNode min;        <span class="hljs-comment">// 最小节点(某个最小堆的根节点)</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FibNode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> key;            <span class="hljs-comment">// 关键字(键值)</span><br>        <span class="hljs-keyword">int</span> degree;            <span class="hljs-comment">// 度数</span><br>        FibNode left;        <span class="hljs-comment">// 左兄弟</span><br>        FibNode right;        <span class="hljs-comment">// 右兄弟</span><br>        FibNode child;        <span class="hljs-comment">// 第一个孩子节点</span><br>        FibNode parent;        <span class="hljs-comment">// 父节点</span><br>        <span class="hljs-keyword">boolean</span> marked;     <span class="hljs-comment">// 是否被删除第一个孩子</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FibNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key    = key;<br>            <span class="hljs-keyword">this</span>.degree = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>.marked = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">this</span>.left   = <span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">this</span>.right  = <span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">this</span>.child  = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FibHeap</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.keyNum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.min = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将node从双链表移除<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(FibNode node)</span> </span>&#123;<br>        node.left.right = node.right;<br>        node.right.left = node.left;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将node堆结点加入root结点之前(循环链表中)<br>     *   a …… root<br>     *   a …… node …… root<br>    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(FibNode node, FibNode root)</span> </span>&#123;<br>        node.left        = root.left;<br>        root.left.right  = node;<br>        node.right       = root;<br>        root.left        = node;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将节点node插入到斐波那契堆中<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(FibNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (keyNum == <span class="hljs-number">0</span>)<br>            min = node;<br>        <span class="hljs-keyword">else</span> &#123;<br>            addNode(node, min);<br>            <span class="hljs-keyword">if</span> (node.key &lt; min.key)<br>                min = node;<br>        &#125;<br><br>        keyNum++;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 新建键值为key的节点，并将其插入到斐波那契堆中<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        FibNode node;<br><br>        node = <span class="hljs-keyword">new</span> FibNode(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        insert(node);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将双向链表b链接到双向链表a的后面<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">catList</span><span class="hljs-params">(FibNode a, FibNode b)</span> </span>&#123;<br>        FibNode tmp;<br><br>        tmp           = a.right;<br>        a.right       = b.right;<br>        b.right.left  = a;<br>        b.right       = tmp;<br>        tmp.left      = b;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将other合并到当前堆中<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(FibHeap other)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (other==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">this</span>.min) == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// this无"最小节点"</span><br>            <span class="hljs-keyword">this</span>.min = other.min;<br>            <span class="hljs-keyword">this</span>.keyNum = other.keyNum;<br>            other = <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((other.min) == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// this有"最小节点" &amp;&amp; other无"最小节点"</span><br>            other = <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">// this有"最小节点" &amp;&amp; other有"最小节点"</span><br>            <span class="hljs-comment">// 将"other中根链表"添加到"this"中</span><br>            catList(<span class="hljs-keyword">this</span>.min, other.min) ;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.min.key &gt; other.min.key)<br>                <span class="hljs-keyword">this</span>.min = other.min;<br>            <span class="hljs-keyword">this</span>.keyNum += other.keyNum;<br>            other = <span class="hljs-keyword">null</span>;;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将"堆的最小结点"从根链表中移除，<br>     * 这意味着"将最小节点所属的树"从堆中移除!<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> FibNode <span class="hljs-title">extractMin</span><span class="hljs-params">()</span> </span>&#123;<br>        FibNode p = min;<br><br>        <span class="hljs-keyword">if</span> (p == p.right)<br>            min = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            removeNode(p);<br>            min = p.right;<br>        &#125;<br>        p.left = p.right = p;<br><br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将node链接到root根结点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">link</span><span class="hljs-params">(FibNode node, FibNode root)</span> </span>&#123;<br>        <span class="hljs-comment">// 将node从双链表中移除</span><br>        removeNode(node);<br>        <span class="hljs-comment">// 将node设为root的孩子</span><br>        <span class="hljs-keyword">if</span> (root.child == <span class="hljs-keyword">null</span>)<br>            root.child = node;<br>        <span class="hljs-keyword">else</span><br>            addNode(node, root.child);<br><br>        node.parent = root;<br>        root.degree++;<br>        node.marked = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 合并斐波那契堆的根链表中左右相同度数的树<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consolidate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 计算log2(keyNum)，floor意味着向上取整！</span><br>        <span class="hljs-comment">// ex. log2(13) = 3，向上取整为4。</span><br>        <span class="hljs-keyword">int</span> maxDegree = (<span class="hljs-keyword">int</span>) Math.floor(Math.log(keyNum) / Math.log(<span class="hljs-number">2.0</span>));<br>        <span class="hljs-keyword">int</span> D = maxDegree + <span class="hljs-number">1</span>;<br>        FibNode[] cons = <span class="hljs-keyword">new</span> FibNode[D+<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; D; i++)<br>            cons[i] = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 合并相同度的根节点，使每个度数的树唯一</span><br>        <span class="hljs-keyword">while</span> (min != <span class="hljs-keyword">null</span>) &#123;<br>            FibNode x = extractMin();            <span class="hljs-comment">// 取出堆中的最小树(最小节点所在的树)</span><br>            <span class="hljs-keyword">int</span> d = x.degree;                        <span class="hljs-comment">// 获取最小树的度数</span><br>            <span class="hljs-comment">// cons[d] != null，意味着有两棵树(x和y)的"度数"相同。</span><br>            <span class="hljs-keyword">while</span> (cons[d] != <span class="hljs-keyword">null</span>) &#123;<br>                FibNode y = cons[d];                <span class="hljs-comment">// y是"与x的度数相同的树"</span><br>                <span class="hljs-keyword">if</span> (x.key &gt; y.key) &#123;    <span class="hljs-comment">// 保证x的键值比y小</span><br>                    FibNode tmp = x;<br>                    x = y;<br>                    y = tmp;<br>                &#125;<br><br>                link(y, x);    <span class="hljs-comment">// 将y链接到x中</span><br>                cons[d] = <span class="hljs-keyword">null</span>;<br>                d++;<br>            &#125;<br>            cons[d] = x;<br>        &#125;<br>        min = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 将cons中的结点重新加到根表中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;D; i++) &#123;<br><br>            <span class="hljs-keyword">if</span> (cons[i] != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (min == <span class="hljs-keyword">null</span>)<br>                    min = cons[i];<br>                <span class="hljs-keyword">else</span> &#123;<br>                    addNode(cons[i], min);<br>                    <span class="hljs-keyword">if</span> ((cons[i]).key &lt; min.key)<br>                        min = cons[i];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 移除最小节点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        FibNode m = min;<br>        <span class="hljs-comment">// 将min每一个儿子(儿子和儿子的兄弟)都添加到"斐波那契堆的根链表"中</span><br>        <span class="hljs-keyword">while</span> (m.child != <span class="hljs-keyword">null</span>) &#123;<br>            FibNode child = m.child;<br><br>            removeNode(child);<br>            <span class="hljs-keyword">if</span> (child.right == child)<br>                m.child = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">else</span><br>                m.child = child.right;<br><br>            addNode(child, min);<br>            child.parent = <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 将m从根链表中移除</span><br>        removeNode(m);<br>        <span class="hljs-comment">// 若m是堆中唯一节点，则设置堆的最小节点为null；</span><br>        <span class="hljs-comment">// 否则，设置堆的最小节点为一个非空节点(m.right)，然后再进行调节。</span><br>        <span class="hljs-keyword">if</span> (m.right == m)<br>            min = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            min = m.right;<br>            consolidate();<br>        &#125;<br>        keyNum--;<br><br>        m = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 获取斐波那契堆中最小键值；失败返回-1<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimum</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">return</span> min.key;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 修改度数<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">renewDegree</span><span class="hljs-params">(FibNode parent, <span class="hljs-keyword">int</span> degree)</span> </span>&#123;<br>        parent.degree -= degree;<br>        <span class="hljs-keyword">if</span> (parent. parent != <span class="hljs-keyword">null</span>)<br>            renewDegree(parent.parent, degree);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将node从父节点parent的子链接中剥离出来，<br>     * 并使node成为"堆的根链表"中的一员。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(FibNode node, FibNode parent)</span> </span>&#123;<br>        removeNode(node);<br>        renewDegree(parent, node.degree);<br>        <span class="hljs-comment">// node没有兄弟</span><br>        <span class="hljs-keyword">if</span> (node == node.right)<br>            parent.child = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">else</span><br>            parent.child = node.right;<br><br>        node.parent = <span class="hljs-keyword">null</span>;<br>        node.left = node.right = node;<br>        node.marked = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 将"node所在树"添加到"根链表"中</span><br>        addNode(node, min);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 对节点node进行"级联剪切"<br>     *<br>     * 级联剪切：如果减小后的结点破坏了最小堆性质，<br>     *     则把它切下来(即从所在双向链表中删除，并将<br>     *     其插入到由最小树根节点形成的双向链表中)，<br>     *     然后再从"被切节点的父节点"到所在树根节点递归执行级联剪枝<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cascadingCut</span><span class="hljs-params">(FibNode node)</span> </span>&#123;<br>        FibNode parent = node.parent;<br><br>        <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (node.marked == <span class="hljs-keyword">false</span>)<br>                node.marked = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cut(node, parent);<br>                cascadingCut(parent);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将斐波那契堆中节点node的值减少为key<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(FibNode node, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span> ||node==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span> (key &gt; node.key) &#123;<br>            System.out.printf(<span class="hljs-string">"decrease failed: the new key(%d) is no smaller than current key(%d)\n"</span>, key, node.key);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        FibNode parent = node.parent;<br>        node.key = key;<br>        <span class="hljs-keyword">if</span> (parent!=<span class="hljs-keyword">null</span> &amp;&amp; (node.key &lt; parent.key)) &#123;<br>            <span class="hljs-comment">// 将node从父节点parent中剥离出来，并将node添加到根链表中</span><br>            cut(node, parent);<br>            cascadingCut(parent);<br>        &#125;<br><br>        <span class="hljs-comment">// 更新最小节点</span><br>        <span class="hljs-keyword">if</span> (node.key &lt; min.key)<br>            min = node;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将斐波那契堆中节点node的值增加为key<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">(FibNode node, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span> ||node==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span> ( key &lt;= node.key) &#123;<br>            System.out.printf(<span class="hljs-string">"increase failed: the new key(%d) is no greater than current key(%d)\n"</span>, key, node.key);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-comment">// 将node每一个儿子(不包括孙子,重孙,...)都添加到"斐波那契堆的根链表"中</span><br>        <span class="hljs-keyword">while</span> (node.child != <span class="hljs-keyword">null</span>) &#123;<br>            FibNode child = node.child;<br>            removeNode(child);               <span class="hljs-comment">// 将child从node的子链表中删除</span><br>            <span class="hljs-keyword">if</span> (child.right == child)<br>                node.child = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">else</span><br>                node.child = child.right;<br><br>            addNode(child, min);       <span class="hljs-comment">// 将child添加到根链表中</span><br>            child.parent = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        node.degree = <span class="hljs-number">0</span>;<br>        node.key = key;<br><br>        <span class="hljs-comment">// 如果node不在根链表中，</span><br>        <span class="hljs-comment">//     则将node从父节点parent的子链接中剥离出来，</span><br>        <span class="hljs-comment">//     并使node成为"堆的根链表"中的一员，</span><br>        <span class="hljs-comment">//     然后进行"级联剪切"</span><br>        <span class="hljs-comment">// 否则，则判断是否需要更新堆的最小节点</span><br>        FibNode parent = node.parent;<br>        <span class="hljs-keyword">if</span>(parent != <span class="hljs-keyword">null</span>) &#123;<br>            cut(node, parent);<br>            cascadingCut(parent);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(min == node) &#123;<br>            FibNode right = node.right;<br>            <span class="hljs-keyword">while</span>(right != node) &#123;<br>                <span class="hljs-keyword">if</span>(node.key &gt; right.key)<br>                    min = right;<br>                right = right.right;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 更新斐波那契堆的节点node的键值为key<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(FibNode node, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(key &lt; node.key)<br>            decrease(node, key);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; node.key)<br>            increase(node, key);<br>        <span class="hljs-keyword">else</span><br>            System.out.printf(<span class="hljs-string">"No need to update!!!\n"</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> oldkey, <span class="hljs-keyword">int</span> newkey)</span> </span>&#123;<br>        FibNode node;<br><br>        node = search(oldkey);<br>        <span class="hljs-keyword">if</span> (node!=<span class="hljs-keyword">null</span>)<br>            update(node, newkey);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 在最小堆root中查找键值为key的节点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> FibNode <span class="hljs-title">search</span><span class="hljs-params">(FibNode root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        FibNode t = root;    <span class="hljs-comment">// 临时节点</span><br>        FibNode p = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 要查找的节点</span><br><br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> (t.key == key) &#123;<br>                p = t;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> ((p = search(t.child, key)) != <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            t = t.right;<br>        &#125; <span class="hljs-keyword">while</span> (t != root);<br><br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 在斐波那契堆中查找键值为key的节点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> FibNode <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">return</span> search(min, key);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 在斐波那契堆中是否存在键值为key的节点。<br>     * 存在返回true，否则返回false。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> search(key)!=<span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span>: <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 删除结点node<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(FibNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = min.key;<br>        decrease(node, m-<span class="hljs-number">1</span>);<br>        removeMin();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        FibNode node = search(key);<br>        <span class="hljs-keyword">if</span> (node==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        remove(node);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 销毁斐波那契堆<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroyNode</span><span class="hljs-params">(FibNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span>;<br><br>        FibNode start = node;<br>        <span class="hljs-keyword">do</span> &#123;<br>            destroyNode(node.child);<br>            <span class="hljs-comment">// 销毁node，并将node指向下一个</span><br>            node = node.right;<br>            node.left = <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">while</span>(node != start);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>        destroyNode(min);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 打印"斐波那契堆"<br>     *<br>     * 参数说明：<br>     *     node       -- 当前节点<br>     *     prev       -- 当前节点的前一个节点(父节点or兄弟节点)<br>     *     direction  --  1，表示当前节点是一个左孩子;<br>     *                    2，表示当前节点是一个兄弟节点。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(FibNode node, FibNode prev, <span class="hljs-keyword">int</span> direction)</span> </span>&#123;<br>        FibNode start=node;<br><br>        <span class="hljs-keyword">if</span> (node==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> (direction == <span class="hljs-number">1</span>)<br>                System.out.printf(<span class="hljs-string">"%8d(%d) is %2d's child\n"</span>, node.key, node.degree, prev.key);<br>            <span class="hljs-keyword">else</span><br>                System.out.printf(<span class="hljs-string">"%8d(%d) is %2d's next\n"</span>, node.key, node.degree, prev.key);<br><br>            <span class="hljs-keyword">if</span> (node.child != <span class="hljs-keyword">null</span>)<br>                print(node.child, node, <span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// 兄弟节点</span><br>            prev = node;<br>            node = node.right;<br>            direction = <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">while</span>(node != start);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (min==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        FibNode p = min;<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆的详细信息: ==\n"</span>);<br>        <span class="hljs-keyword">do</span> &#123;<br>            i++;<br>            System.out.printf(<span class="hljs-string">"%2d. %4d(%d) is root\n"</span>, i, p.key, p.degree);<br><br>            print(p.child, p, <span class="hljs-number">1</span>);<br>            p = p.right;<br>        &#125; <span class="hljs-keyword">while</span> (p != min);<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="斐波那契堆的测试程序-Main-java"><a href="#斐波那契堆的测试程序-Main-java" class="headerlink" title="斐波那契堆的测试程序(Main.java)"></a>斐波那契堆的测试程序(Main.java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> DEBUG = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">// 共8个</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">12</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">25</span>, <span class="hljs-number">15</span>, <span class="hljs-number">28</span>, <span class="hljs-number">33</span>, <span class="hljs-number">41</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-comment">// 共14个</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b[] = &#123;<span class="hljs-number">18</span>, <span class="hljs-number">35</span>, <span class="hljs-number">20</span>, <span class="hljs-number">42</span>,  <span class="hljs-number">9</span>,<br>                                 <span class="hljs-number">31</span>, <span class="hljs-number">23</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">48</span>, <span class="hljs-number">11</span>,<br>                              <span class="hljs-number">24</span>, <span class="hljs-number">52</span>, <span class="hljs-number">13</span>,  <span class="hljs-number">2</span> &#125;;<br><br>    <span class="hljs-comment">// 验证"基本信息(斐波那契堆的结构)"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testBasic</span><span class="hljs-params">()</span> </span>&#123;<br>        FibHeap hb=<span class="hljs-keyword">new</span> FibHeap();<br><br>        <span class="hljs-comment">// 斐波那契堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)删除最小节点\n"</span>);<br>        hb.removeMin();<br>        hb.print(); <span class="hljs-comment">// 打印斐波那契堆hb</span><br>    &#125;<br><br>    <span class="hljs-comment">// 验证"插入操作"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsert</span><span class="hljs-params">()</span> </span>&#123;<br>        FibHeap ha=<span class="hljs-keyword">new</span> FibHeap();<br><br>        <span class="hljs-comment">// 斐波那契堆ha</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(ha)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            ha.insert(a[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(ha)删除最小节点\n"</span>);<br>        ha.removeMin();<br>        ha.print(); <span class="hljs-comment">// 打印斐波那契堆ha</span><br><br>        System.out.printf(<span class="hljs-string">"== 插入50\n"</span>);<br>        ha.insert(<span class="hljs-number">50</span>);<br>        ha.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"合并操作"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUnion</span><span class="hljs-params">()</span> </span>&#123;<br>        FibHeap ha=<span class="hljs-keyword">new</span> FibHeap();<br>        FibHeap hb=<span class="hljs-keyword">new</span> FibHeap();<br><br>        <span class="hljs-comment">// 斐波那契堆ha</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(ha)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            ha.insert(a[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(ha)删除最小节点\n"</span>);<br>        ha.removeMin();<br>        ha.print(); <span class="hljs-comment">// 打印斐波那契堆ha</span><br><br>        <span class="hljs-comment">// 斐波那契堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)删除最小节点\n"</span>);<br>        hb.removeMin();<br>        hb.print(); <span class="hljs-comment">// 打印斐波那契堆hb</span><br><br>        <span class="hljs-comment">// 将"斐波那契堆hb"合并到"斐波那契堆ha"中。</span><br>        System.out.printf(<span class="hljs-string">"== 合并ha和hb\n"</span>);<br>        ha.union(hb);<br>        ha.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"删除最小节点"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRemoveMin</span><span class="hljs-params">()</span> </span>&#123;<br>        FibHeap ha=<span class="hljs-keyword">new</span> FibHeap();<br>        FibHeap hb=<span class="hljs-keyword">new</span> FibHeap();<br><br>        <span class="hljs-comment">// 斐波那契堆ha</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(ha)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            ha.insert(a[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(ha)删除最小节点\n"</span>);<br>        ha.removeMin();<br>        <span class="hljs-comment">//ha.print(); // 打印斐波那契堆ha</span><br><br>        <span class="hljs-comment">// 斐波那契堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)删除最小节点\n"</span>);<br>        hb.removeMin();<br>        <span class="hljs-comment">//hb.print(); // 打印斐波那契堆hb</span><br><br>        <span class="hljs-comment">// 将"斐波那契堆hb"合并到"斐波那契堆ha"中。</span><br>        System.out.printf(<span class="hljs-string">"== 合并ha和hb\n"</span>);<br>        ha.union(hb);<br>        ha.print();<br><br>        System.out.printf(<span class="hljs-string">"== 删除最小节点\n"</span>);<br>        ha.removeMin();<br>        ha.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"减小节点"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDecrease</span><span class="hljs-params">()</span> </span>&#123;<br>        FibHeap hb=<span class="hljs-keyword">new</span> FibHeap();<br><br>        <span class="hljs-comment">// 斐波那契堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)删除最小节点\n"</span>);<br>        hb.removeMin();<br>        hb.print(); <span class="hljs-comment">// 打印斐波那契堆hb</span><br><br>        System.out.printf(<span class="hljs-string">"== 将20减小为2\n"</span>);<br>        hb.update(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>);<br>        hb.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"增大节点"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIncrease</span><span class="hljs-params">()</span> </span>&#123;<br>        FibHeap hb=<span class="hljs-keyword">new</span> FibHeap();<br><br>        <span class="hljs-comment">// 斐波那契堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)删除最小节点\n"</span>);<br>        hb.removeMin();<br>        hb.print(); <span class="hljs-comment">// 打印斐波那契堆hb</span><br><br>        System.out.printf(<span class="hljs-string">"== 将20增加为60\n"</span>);<br>        hb.update(<span class="hljs-number">20</span>, <span class="hljs-number">60</span>);<br>        hb.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"删除节点"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span> </span>&#123;<br>        FibHeap hb=<span class="hljs-keyword">new</span> FibHeap();<br><br>        <span class="hljs-comment">// 斐波那契堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 斐波那契堆(hb)删除最小节点\n"</span>);<br>        hb.removeMin();<br>        hb.print(); <span class="hljs-comment">// 打印斐波那契堆hb</span><br><br>        System.out.printf(<span class="hljs-string">"== 删除节点20\n"</span>);<br>        hb.remove(<span class="hljs-number">20</span>);<br>        hb.print();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 验证"基本信息(斐波那契堆的结构)"</span><br>        testBasic();<br>        <span class="hljs-comment">// 验证"插入操作"</span><br>        <span class="hljs-comment">//testInsert();</span><br>        <span class="hljs-comment">// 验证"合并操作"</span><br>        <span class="hljs-comment">//testUnion();</span><br>        <span class="hljs-comment">// 验证"删除最小节点"</span><br>        <span class="hljs-comment">//testRemoveMin();</span><br>        <span class="hljs-comment">// 验证"减小节点"</span><br>        <span class="hljs-comment">//testDecrease();</span><br>        <span class="hljs-comment">// 验证"增大节点"</span><br>        <span class="hljs-comment">//testIncrease();</span><br>        <span class="hljs-comment">// 验证"删除节点"</span><br>        <span class="hljs-comment">//testDelete();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">== 斐波那契堆(hb)中依次添加: 18 35 20 42 9 31 23 6 48 11 24 52 13 2 </span><br><span class="hljs-section">== 斐波那契堆(hb)删除最小节点</span><br><span class="hljs-section">== 斐波那契堆的详细信息: ==</span><br><span class="hljs-code"> 1.    6(3) is root</span><br><span class="hljs-code">       9(0) is  6's child</span><br><span class="hljs-code">      18(1) is  9's next</span><br><span class="hljs-code">      35(0) is 18's child</span><br><span class="hljs-code">      20(2) is 18's next</span><br><span class="hljs-code">      42(0) is 20's child</span><br><span class="hljs-code">      23(1) is 42's next</span><br><span class="hljs-code">      31(0) is 23's child</span><br><span class="hljs-code"> 2.   11(2) is root</span><br><span class="hljs-code">      48(0) is 11's child</span><br><span class="hljs-code">      24(1) is 48's next</span><br><span class="hljs-code">      52(0) is 24's child</span><br><span class="hljs-code"> 3.   13(0) is root</span><br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;斐波那契堆-Fibonacci-heap&quot;&gt;&lt;a href=&quot;#斐波那契堆-Fibonacci-heap&quot; class=&quot;headerlink&quot; title=&quot;斐波那契堆(Fibonacci heap)&quot;&gt;&lt;/a&gt;斐波那契堆(Fibonacci heap)&lt;/h1
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>6.4.二项堆</title>
    <link href="http://yoursite.com/2022/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.4.%E4%BA%8C%E9%A1%B9%E5%A0%86/"/>
    <id>http://yoursite.com/2022/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.4.%E4%BA%8C%E9%A1%B9%E5%A0%86/</id>
    <published>2022-01-10T14:37:39.000Z</published>
    <updated>2022-02-21T00:54:33.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二项堆"><a href="#二项堆" class="headerlink" title="二项堆"></a>二项堆</h1><p>二项堆是二项树的集合。在了解二项堆之前，先对二项树进行介绍。</p><h2 id="二项树的介绍"><a href="#二项树的介绍" class="headerlink" title="二项树的介绍"></a>二项树的介绍</h2><h3 id="二项树的定义"><a href="#二项树的定义" class="headerlink" title="二项树的定义"></a><strong>二项树的定义</strong></h3><p>二项堆是二项树的集合。在了解二项堆之前，先对二项树进行介绍。</p><p>二项树是一种递归定义的有序树。它的递归定义如下：<br>(01) 二项树B0只有一个结点；<br>(02) 二项树Bk由两棵二项树B(k-1)组成的，其中一棵树是另一棵树根的最左孩子。<br>如下图所示：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/101009066844094.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm1jxjzu1j312v0cdab5.jpg" alt="img"></a></p><p>上图的B0、B1、B2、B3、B4都是二项树。对比前面提到的二项树的定义：B0只有一个节点，B1由两个B0所组成，B2由两个B1所组成，B3由两个B2所组成，B4由两个B3所组成；而且，当两颗相同的二项树组成另一棵树时，其中一棵树是另一棵树的最左孩子。</p><h3 id="二项树的性质"><a href="#二项树的性质" class="headerlink" title="二项树的性质"></a><strong>二项树的性质</strong></h3><p>二项树有以下性质：<br>[性质一] Bk共有2k个节点。<br>        如上图所示，B0有20=1节点，B1有21=2个节点，B2有22=4个节点，…<br>[性质二] Bk的高度为k。<br>        如上图所示，B0的高度为0，B1的高度为1，B2的高度为2，…<br>[性质三] Bk在深度i处恰好有C(k,i)个节点，其中i=0,1,2,…,k。<br>       C(k,i)是高中数学中阶乘元素，例如，C(10,3)=(10<em>9</em>8) / (3<em>2</em>1)=240<br>       B4中深度为0的节点C(4,0)=1<br>       B4中深度为1的节点C(4,1)= 4 / 1 = 4<br>       B4中深度为2的节点C(4,2)= (4<em>3) / (2</em>1) = 6<br>       B4中深度为3的节点C(4,3)= (4<em>3</em>2) / (3<em>2</em>1) = 4<br>       B4中深度为4的节点C(4,4)= (4<em>3</em>2<em>1) / (4</em>3<em>2</em>1) = 1<br>       合计得到B4的节点分布是(1,4,6,4,1)。<br>[性质四] 根的度数为k，它大于任何其它节点的度数。<br>       节点的度数是该结点拥有的子树的数目。</p><h2 id="二项堆的介绍"><a href="#二项堆的介绍" class="headerlink" title="二项堆的介绍"></a>二项堆的介绍</h2><p>二项堆和之前所讲的堆(<a href="http://www.cnblogs.com/skywang12345/p/3610390.html" target="_blank" rel="noopener">二叉堆</a>、<a href="http://www.cnblogs.com/skywang12345/p/3638384.html" target="_blank" rel="noopener">左倾堆</a>、<a href="http://www.cnblogs.com/skywang12345/p/3638552.html" target="_blank" rel="noopener">斜堆</a>)一样，也是用于实现优先队列的。</p><p>二项堆是指满足以下性质的二项树的集合：<br>(1) 每棵二项树都满足最小堆性质。即，父节点的关键字 &lt;= 它的孩子的关键字。<br>(2) 不能有两棵或以上的二项树具有相同的度数(包括度数为0)。换句话说，具有度数k的二项树有0个或1个。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/101016180284317.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm1m0qzx7j30gu0a4mxl.jpg" alt="img"></a></p><p>上图就是一棵二项堆，它由二项树B0、B2和B3组成。</p><p>对比二项堆的定义：</p><p>(1)二项树B0、B2、B3都是最小堆；</p><p>(0)二项堆不包含相同度数的二项树。</p><p>​     二项堆的第(1)个性质保证了二项堆的最小节点就是某个二项树的根节点，第(2)个性质则说明结点数为n的二项堆最多只有log{n} + 1棵二项树。实际上，将包含n个节点的二项堆，表示成若干个2的指数和(或者转换成二进制)，则每一个2个指数都对应一棵二项树。例如，13(二进制是1101)的2个指数和为13=23 + 22+ 20, 因此具有13个节点的二项堆由度数为3, 2, 0的三棵二项树组成。</p><h2 id="二项堆的基本操作"><a href="#二项堆的基本操作" class="headerlink" title="二项堆的基本操作"></a>二项堆的基本操作</h2><p>二项堆是可合并堆，它的合并操作的复杂度是O(log n)。</p><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinomialHeap</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; mRoot;    <span class="hljs-comment">// 根结点</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinomialNode</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        T key;                <span class="hljs-comment">// 关键字(键值)</span><br>        <span class="hljs-keyword">int</span> degree;            <span class="hljs-comment">// 度数</span><br>        BinomialNode&lt;T&gt; child;    <span class="hljs-comment">// 左孩子</span><br>        BinomialNode&lt;T&gt; parent;    <span class="hljs-comment">// 父节点</span><br>        BinomialNode&lt;T&gt; next;    <span class="hljs-comment">// 兄弟节点</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinomialNode</span><span class="hljs-params">(T key)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.degree = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>.child = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"key:"</span>+key;<br>        &#125;<br>    &#125;<br>        <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>BinomialNode是二项堆的节点。它包括了关键字(key)，用于比较节点大小；度数(degree)，用来表示当前节点的度数；左孩子(child)、父节点(parent)以及兄弟节点(next)。<br>BinomialHeap是二项堆对应的类，它包括了二项堆的根节点mRoot以及二项堆的基本操作的定义。</p><p>下面是一棵二项堆的树形图和它对应的内存结构关系图。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/101021406063534.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm1obcyadj30u00ux40c.jpg" alt="img"></a></p><h3 id="2-合并操作"><a href="#2-合并操作" class="headerlink" title="2. 合并操作"></a><strong>2. 合并操作</strong></h3><p>合并操作是二项堆的重点，它的添加操作也是基于合并操作来实现的。合并两个二项堆，需要的步骤概括起来如下：<br>(1) 将两个二项堆的根链表合并成一个链表。合并后的新链表按照”节点的度数”单调递增排列。<br>(2) 将新链表中”根节点度数相同的二项树”连接起来，直到所有根节点度数都不相同。</p><p>下面，先看看合并操作的代码；然后再通过示意图对合并操作进行说明。</p><p>merge()代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 将h1, h2中的根表合并成一个按度数递增的链表，返回合并后的根节点<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">merge</span><span class="hljs-params">(BinomialNode&lt;T&gt; h1, BinomialNode&lt;T&gt; h2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (h1 == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> h2;<br>    <span class="hljs-keyword">if</span> (h2 == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> h1;<br><br>    <span class="hljs-comment">// root是新堆的根，h3用来遍历h1和h3的。</span><br>    BinomialNode&lt;T&gt; pre_h3, h3, root=<span class="hljs-keyword">null</span>;<br><br>    pre_h3 = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//整个while，h1, h2, pre_h3, h3都在往后顺移</span><br>    <span class="hljs-keyword">while</span> ((h1!=<span class="hljs-keyword">null</span>) &amp;&amp; (h2!=<span class="hljs-keyword">null</span>)) &#123;<br><br>        <span class="hljs-keyword">if</span> (h1.degree &lt;= h2.degree) &#123;<br>            h3 = h1;<br>            h1 = h1.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            h3 = h2;<br>            h2 = h2.next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (pre_h3 == <span class="hljs-keyword">null</span>) &#123;<br>            pre_h3 = h3;<br>            root = h3;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pre_h3.next = h3;<br>            pre_h3 = h3;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (h1 != <span class="hljs-keyword">null</span>) &#123;<br>            h3.next = h1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            h3.next = h2;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>link()代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 合并两个二项堆：将child合并到root中<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">link</span><span class="hljs-params">(BinomialNode&lt;T&gt; child, BinomialNode&lt;T&gt; root)</span> </span>&#123;<br>    child.parent = root;<br>    child.next   = root.child;<br>    root.child = child;<br>    root.degree++;<br>&#125;<br></code></pre></td></tr></table></figure><p>合并操作代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 合并二项堆：将h1, h2合并成一个堆，并返回合并后的堆<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">union</span><span class="hljs-params">(BinomialNode&lt;T&gt; h1, BinomialNode&lt;T&gt; h2)</span> </span>&#123;<br>    BinomialNode&lt;T&gt; root;<br><br>    <span class="hljs-comment">// 将h1, h2中的根表合并成一个按度数递增的链表root</span><br>    root = merge(h1, h2);<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    BinomialNode&lt;T&gt; prev_x = <span class="hljs-keyword">null</span>;<br>    BinomialNode&lt;T&gt; x      = root;<br>    BinomialNode&lt;T&gt; next_x = x.next;<br>    <span class="hljs-keyword">while</span> (next_x != <span class="hljs-keyword">null</span>) &#123;<br><br>        <span class="hljs-keyword">if</span> (   (x.degree != next_x.degree)<br>            || ((next_x.next != <span class="hljs-keyword">null</span>) &amp;&amp; (next_x.degree == next_x.next.degree))) &#123;<br>            <span class="hljs-comment">// Case 1: x.degree != next_x.degree</span><br>            <span class="hljs-comment">// Case 2: x.degree == next_x.degree == next_x.next.degree</span><br>            prev_x = x;<br>            x = next_x;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.key.compareTo(next_x.key) &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Case 3: x.degree == next_x.degree != next_x.next.degree</span><br>            <span class="hljs-comment">//      &amp;&amp; x.key    &lt;= next_x.key</span><br>            x.next = next_x.next;<br>            link(next_x, x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Case 4: x.degree == next_x.degree != next_x.next.degree</span><br>            <span class="hljs-comment">//      &amp;&amp; x.key    &gt;  next_x.key</span><br>            <span class="hljs-keyword">if</span> (prev_x == <span class="hljs-keyword">null</span>) &#123;<br>                root = next_x;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prev_x.next = next_x;<br>            &#125;<br>            link(x, next_x);<br>            x = next_x;<br>        &#125;<br>        next_x = x.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-comment">/*<br> * 将二项堆other合并到当前堆中<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(BinomialHeap&lt;T&gt; other)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (other!=<span class="hljs-keyword">null</span> &amp;&amp; other.mRoot!=<span class="hljs-keyword">null</span>)<br>        mRoot = union(mRoot, other.mRoot);<br>&#125;<br></code></pre></td></tr></table></figure><p>合并函数combine(h1, h2)的作用是将h1和h2合并，并返回合并后的二项堆。在combine(h1, h2)中，涉及到了两个函数merge(h1, h2)和link(child, root)。<br>merge(h1, h2)就是我们前面所说的”两个二项堆的根链表合并成一个链表，合并后的新链表按照’节点的度数’单调递增排序”。<br>link(child, root)则是为了合并操作的辅助函数，它的作用是将”二项堆child的根节点”设为”二项堆root的左孩子”，从而将child整合到root中去。</p><p>​    在combine(h1, h2)中对h1和h2进行合并时；首先通过 merge(h1, h2) 将h1和h2的根链表合并成一个”按节点的度数单调递增”的链表；然后进入while循环，对合并得到的新链表进行遍历，将新链表中”根节点度数相同的二项树”连接起来，直到所有根节点度数都不相同为止。在将新联表中”根节点度数相同的二项树”连接起来时，可以将被连接的情况概括为4种。</p><p><em>x是根链表的当前节点，next_x是x的下一个(兄弟)节点。</em><br><strong>Case 1</strong>: x-&gt;degree != next_x-&gt;degree<br>       即，”当前节点的度数”与”下一个节点的度数”相等时。此时，不需要执行任何操作，继续查看后面的节点。<br><strong>Case 2</strong>: x-&gt;degree == next_x-&gt;degree == next_x-&gt;next-&gt;degree<br>       即，”当前节点的度数”、”下一个节点的度数”和”下下一个节点的度数”都相等时。此时，暂时不执行任何操作，还是继续查看后面的节点。实际上，这里是将”下一个节点”和”下下一个节点”等到后面再进行整合连接。<br><strong>Case 3</strong>: x-&gt;degree == next_x-&gt;degree != next_x-&gt;next-&gt;degree<br>    &amp;&amp; x-&gt;key &lt;= next_x-&gt;key<br>       即，”当前节点的度数”与”下一个节点的度数”相等，并且”当前节点的键值”&lt;=”下一个节点的度数”。此时，将”下一个节点(对应的二项树)”作为”当前节点(对应的二项树)的左孩子”。<br><strong>Case 4</strong>: x-&gt;degree == next_x-&gt;degree != next_x-&gt;next-&gt;degree<br>    &amp;&amp; x-&gt;key &gt; next_x-&gt;key<br>       即，”当前节点的度数”与”下一个节点的度数”相等，并且”当前节点的键值”&gt;”下一个节点的度数”。此时，将”当前节点(对应的二项树)”作为”下一个节点(对应的二项树)的左孩子”。</p><p>下面通过示意图来对合并操作进行说明。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/101030524817766.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm1qyz43wj30u01r3q82.jpg" alt="img"></a></p><p><strong>第1步</strong>：将两个二项堆的根链表合并成一个链表<br>     执行完第1步之后，得到的新链表中有许多度数相同的二项树。实际上，此时得到的是对应”Case 4”的情况，”树41”(根节点为41的二项树)和”树13”的度数相同，且”树41”的键值 &gt; “树13”的键值。此时，将”树41”作为”树13”的左孩子。<br><strong>第2步</strong>：合并”树41”和”树13”<br>     执行完第2步之后，得到的是对应”Case 3”的情况，”树13”和”树28”的度数相同，且”树13”的键值 &lt; “树28”的键值。此时，将”树28”作为”树13”的左孩子。<br><strong>第3步</strong>：合并”树13”和”树28”<br>     执行完第3步之后，得到的是对应”Case 2”的情况，”树13”、”树28”和”树7”这3棵树的度数都相同。此时，将x设为下一个节点。<br><strong>第4步</strong>：将x和next_x往后移<br>     执行完第4步之后，得到的是对应”Case 3”的情况，”树7”和”树11”的度数相同，且”树7”的键值 &lt; “树11”的键值。此时，将”树11”作为”树7”的左孩子。<br><strong>第5步</strong>：合并”树7”和”树11”<br>     执行完第5步之后，得到的是对应”Case 4”的情况，”树7”和”树6”的度数相同，且”树7”的键值 &gt; “树6”的键值。此时，将”树7”作为”树6”的左孩子。<br><strong>第6步</strong>：合并”树7”和”树6”<br>     此时，合并操作完成！</p><p>PS. 合并操作的图文解析过程与”测试程序(Main.java)中的testUnion()函数”是对应的！</p><h3 id="3-插入操作"><a href="#3-插入操作" class="headerlink" title="3. 插入操作"></a><strong>3. 插入操作</strong></h3><p>理解了”合并”操作之后，插入操作就相当简单了。插入操作可以看作是将”要插入的节点”和当前已有的堆进行合并。</p><p>插入操作代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 新建key对应的节点，并将其插入到二项堆中。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T key)</span> </span>&#123;<br>    BinomialNode&lt;T&gt; node;<br><br>    <span class="hljs-comment">// 禁止插入相同的键值</span><br>    <span class="hljs-keyword">if</span> (contains(key)==<span class="hljs-keyword">true</span>) &#123;<br>        System.out.printf(<span class="hljs-string">"insert failed: the key(%s) is existed already!\n"</span>, key);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    node = <span class="hljs-keyword">new</span> BinomialNode&lt;T&gt;(key);<br>    <span class="hljs-keyword">if</span> (node==<span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> ;<br><br>    mRoot = union(mRoot, node);<br>&#125;<br></code></pre></td></tr></table></figure><p>在插入时，首先通过contains(key)查找键值为key的节点。存在的话，则直接返回；不存在的话，则新建BinomialNode对象node，然后将node和heap进行合并。</p><p>注意：这里实现的二项堆是”进制插入相同节点的”！若想允许插入相同键值的节点，则屏蔽掉插入操作中的contains(key)部分代码即可。</p><h3 id="4-删除操作"><a href="#4-删除操作" class="headerlink" title="4. 删除操作"></a><strong>4. 删除操作</strong></h3><p>删除二项堆中的某个节点，需要的步骤概括起来如下：<br>(1) 将”该节点”交换到”它所在二项树”的根节点位置。方法是，从”该节点”不断向上(即向树根方向)”遍历，不断交换父节点和子节点的数据，直到被删除的键值到达树根位置。<br>(2) 将”该节点所在的二项树”从二项堆中移除；将该二项堆记为heap。<br>(3) 将”该节点所在的二项树”进行反转。反转的意思，就是将根的所有孩子独立出来，并将这些孩子整合成二项堆，将该二项堆记为child。<br>(4) 将child和heap进行合并操作。</p><p>下面，先看看删除操作的代码；再进行图文说明。</p><p>删除操作代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 删除节点：删除键值为key的节点<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">remove</span><span class="hljs-params">(BinomialNode&lt;T&gt; root, T key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> root;<br><br>    BinomialNode&lt;T&gt; node;<br><br>    <span class="hljs-comment">// 查找键值为key的节点</span><br>    <span class="hljs-keyword">if</span> ((node = search(root, key)) == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> root;<br><br>    <span class="hljs-comment">// 将被删除的节点的数据数据上移到它所在的二项树的根节点</span><br>    BinomialNode&lt;T&gt; parent = node.parent;<br>    <span class="hljs-keyword">while</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 交换数据</span><br>        T tmp = node.key;<br>        node.key = parent.key;<br>        parent.key = tmp;<br><br>        <span class="hljs-comment">// 下一个父节点</span><br>        node   = parent;<br>        parent = node.parent;<br>    &#125;<br><br>    <span class="hljs-comment">// 找到node的前一个根节点(prev)</span><br>    BinomialNode&lt;T&gt; prev = <span class="hljs-keyword">null</span>;<br>    BinomialNode&lt;T&gt; pos  = root;<br>    <span class="hljs-keyword">while</span> (pos != node) &#123;<br>        prev = pos;<br>        pos  = pos.next;<br>    &#125;<br>    <span class="hljs-comment">// 移除node节点</span><br>    <span class="hljs-keyword">if</span> (prev!=<span class="hljs-keyword">null</span>)<br>        prev.next = node.next;<br>    <span class="hljs-keyword">else</span><br>        root = node.next;<br><br>    root = union(root, reverse(node.child));<br><br>    <span class="hljs-comment">// help GC</span><br>    node = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(T key)</span> </span>&#123;<br>    mRoot = remove(mRoot, key);<br>&#125;<br></code></pre></td></tr></table></figure><p>remove(key)的作用是删除二项堆中键值为key的节点，并返回删除节点后的二项堆。</p><p>下面通过示意图来对删除操作进行说明(<em>删除二项堆中的节点20</em>)。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/101033308568748.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm1tskf8tj30ix1imtbz.jpg" alt="img"></a></p><p>总的思想，就是将被”删除节点”从它所在的二项树中孤立出来，然后再对二项树进行相应的处理。</p><p>PS. 删除操作的图文解析过程与”测试程序(Main.java)中的testDelete()函数”是对应的！</p><h3 id="5-更新操作"><a href="#5-更新操作" class="headerlink" title="5. 更新操作"></a><strong>5. 更新操作</strong></h3><p>更新二项堆中的某个节点，就是修改节点的值，它包括两部分分：”减少节点的值” 和 “增加节点的值” 。</p><p>更新操作代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 更新二项堆的节点node的键值为key<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateKey</span><span class="hljs-params">(BinomialNode&lt;T&gt; node, T key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-keyword">int</span> cmp = key.compareTo(node.key);<br>    <span class="hljs-keyword">if</span>(cmp &lt; <span class="hljs-number">0</span>)                            <span class="hljs-comment">// key &lt; node.key</span><br>        decreaseKey(node, key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp &gt; <span class="hljs-number">0</span>)                       <span class="hljs-comment">// key &gt; node.key</span><br>        increaseKey(node, key);<br>    <span class="hljs-keyword">else</span><br>        System.out.println(<span class="hljs-string">"No need to update!!!"</span>);<br>&#125;<br><br><span class="hljs-comment">/* <br> * 将二项堆中键值oldkey更新为newkey<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(T oldkey, T newkey)</span> </span>&#123;<br>    BinomialNode&lt;T&gt; node;<br><br>    node = search(mRoot, oldkey);<br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)<br>        updateKey(node, newkey);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-1-减少节点的值"><a href="#5-1-减少节点的值" class="headerlink" title="5.1 减少节点的值"></a><strong>5.1 减少节点的值</strong></h4><p>减少节点值的操作很简单：该节点一定位于一棵二项树中，减小”二项树”中某个节点的值后要保证”该二项树仍然是一个最小堆”；因此，就需要我们不断的将该节点上调。</p><p>减少操作代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 减少关键字的值：将二项堆中的节点node的键值减小为key。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decreaseKey</span><span class="hljs-params">(BinomialNode&lt;T&gt; node, T key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(key.compareTo(node.key)&gt;=<span class="hljs-number">0</span> || contains(key)==<span class="hljs-keyword">true</span>) &#123;<br>    System.out.println(<span class="hljs-string">"decrease failed: the new key("</span>+key+<span class="hljs-string">") is existed already, or is no smaller than current key("</span>+node.key+<span class="hljs-string">")"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    node.key = key;<br><br>    BinomialNode&lt;T&gt; child, parent;<br>    child = node;<br>    parent = node.parent;<br>    <span class="hljs-keyword">while</span>(parent != <span class="hljs-keyword">null</span> &amp;&amp; child.key.compareTo(parent.key)&lt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 交换parent和child的数据</span><br>        T tmp = parent.key;<br>        parent.key = child.key;<br>        child.key = tmp;<br><br>        child = parent;<br>        parent = child.parent;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是减少操作的示意图(<em>20-&gt;2</em>)</p><p><a href="https://images0.cnblogs.com/i/497634/201404/101035204817623.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm1vlja9kj30hv0swq4j.jpg" alt="img"></a></p><p>减少操作的思想很简单，就是”保持被减节点所在二项树的最小堆性质”。</p><p>PS. 减少操作的图文解析过程与”测试程序(Main.java)中的testDecrease()函数”是对应的！</p><h4 id="5-2-增加节点的值"><a href="#5-2-增加节点的值" class="headerlink" title="5.2 增加节点的值"></a><strong>5.2 增加节点的值</strong></h4><p>增加节点值的操作也很简单。上面说过减少要将被减少的节点不断上调，从而保证”被减少节点所在的二项树”的最小堆性质；而增加操作则是将被增加节点不断的下调，从而保证”被增加节点所在的二项树”的最小堆性质。</p><p>增加操作代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 增加关键字的值：将二项堆中的节点node的键值增加为key。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increaseKey</span><span class="hljs-params">(BinomialNode&lt;T&gt; node, T key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(key.compareTo(node.key)&lt;=<span class="hljs-number">0</span> || contains(key)==<span class="hljs-keyword">true</span>) &#123;<br>    System.out.println(<span class="hljs-string">"increase failed: the new key("</span>+key+<span class="hljs-string">") is existed already, or is no greater than current key("</span>+node.key+<span class="hljs-string">")"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    node.key = key;<br><br>    BinomialNode&lt;T&gt; cur = node;<br>    BinomialNode&lt;T&gt; child = cur.child;<br>    <span class="hljs-keyword">while</span> (child != <span class="hljs-keyword">null</span>) &#123;<br><br>        <span class="hljs-keyword">if</span>(cur.key.compareTo(child.key) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果"当前节点" &lt; "它的左孩子"，</span><br>            <span class="hljs-comment">// 则在"它的孩子中(左孩子 和 左孩子的兄弟)"中，找出最小的节点；</span><br>            <span class="hljs-comment">// 然后将"最小节点的值" 和 "当前节点的值"进行互换</span><br>            BinomialNode&lt;T&gt; least = child;    <span class="hljs-comment">// least是child和它的兄弟中的最小节点</span><br>            <span class="hljs-keyword">while</span>(child.next != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (least.key.compareTo(child.next.key) &gt; <span class="hljs-number">0</span>)<br>                    least = child.next;<br>                child = child.next;<br>            &#125;<br>            <span class="hljs-comment">// 交换最小节点和当前节点的值</span><br>            T tmp = least.key;<br>            least.key = cur.key;<br>            cur.key = tmp;<br><br>            <span class="hljs-comment">// 交换数据之后，再对"原最小节点"进行调整，使它满足最小堆的性质：父节点 &lt;= 子节点</span><br>            cur = least;<br>            child = cur.child;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            child = child.next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是增加操作的示意图(<em>6-&gt;60</em>)</p><p><a href="https://images0.cnblogs.com/i/497634/201404/101035468879089.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwm1whiuw5j30hv11uq5c.jpg" alt="img"></a></p><p>增加操作的思想很简单，”保持被增加点所在二项树的最小堆性质”。</p><p>PS. 增加操作的图文解析过程与”测试程序(Main.java)中的testIncrease()函数”是对应的！</p><h2 id="二项堆的Java实现"><a href="#二项堆的Java实现" class="headerlink" title="二项堆的Java实现"></a><strong>二项堆的Java实现</strong></h2><h3 id="二项堆的实现文件-BinomialHeap-java"><a href="#二项堆的实现文件-BinomialHeap-java" class="headerlink" title="二项堆的实现文件(BinomialHeap.java)"></a>二项堆的实现文件(BinomialHeap.java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinomialHeap</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; mRoot;    <span class="hljs-comment">// 根结点</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinomialNode</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        T key;                <span class="hljs-comment">// 关键字(键值)</span><br>        <span class="hljs-keyword">int</span> degree;            <span class="hljs-comment">// 度数</span><br>        BinomialNode&lt;T&gt; child;    <span class="hljs-comment">// 左孩子</span><br>        BinomialNode&lt;T&gt; parent;    <span class="hljs-comment">// 父节点</span><br>        BinomialNode&lt;T&gt; next;    <span class="hljs-comment">// 兄弟节点</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinomialNode</span><span class="hljs-params">(T key)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.degree = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>.child = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"key:"</span>+key;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinomialHeap</span><span class="hljs-params">()</span> </span>&#123;<br>        mRoot = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 获取二项堆中的最小节点的键值<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">minimum</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mRoot==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        BinomialNode&lt;T&gt; x, prev_x;    <span class="hljs-comment">// x是用来遍历的当前节点</span><br>        BinomialNode&lt;T&gt; y, prev_y;    <span class="hljs-comment">// y是最小节点</span><br><br>        prev_x  = mRoot;<br>        x       = mRoot.next;<br>        prev_y  = <span class="hljs-keyword">null</span>;<br>        y       = mRoot;<br>        <span class="hljs-comment">// 找到最小节点</span><br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (x.key.compareTo(y.key) &lt; <span class="hljs-number">0</span>) &#123;<br>                y = x;<br>                prev_y = prev_x;<br>            &#125;<br>            prev_x = x;<br>            x = x.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> y.key;<br>    &#125;<br><br><br>    <span class="hljs-comment">/*<br>     * 合并两个二项堆：将child合并到root中<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">link</span><span class="hljs-params">(BinomialNode&lt;T&gt; child, BinomialNode&lt;T&gt; root)</span> </span>&#123;<br>        child.parent = root;<br>        child.next   = root.child;<br>        root.child = child;<br>        root.degree++;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将h1, h2中的根表合并成一个按度数递增的链表，返回合并后的根节点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">merge</span><span class="hljs-params">(BinomialNode&lt;T&gt; h1, BinomialNode&lt;T&gt; h2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (h1 == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> h2;<br>        <span class="hljs-keyword">if</span> (h2 == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> h1;<br><br>        <span class="hljs-comment">// root是新堆的根，h3用来遍历h1和h3的。</span><br>        BinomialNode&lt;T&gt; pre_h3, h3, root=<span class="hljs-keyword">null</span>;<br><br>        pre_h3 = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//整个while，h1, h2, pre_h3, h3都在往后顺移</span><br>        <span class="hljs-keyword">while</span> ((h1!=<span class="hljs-keyword">null</span>) &amp;&amp; (h2!=<span class="hljs-keyword">null</span>)) &#123;<br><br>            <span class="hljs-keyword">if</span> (h1.degree &lt;= h2.degree) &#123;<br>                h3 = h1;<br>                h1 = h1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                h3 = h2;<br>                h2 = h2.next;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (pre_h3 == <span class="hljs-keyword">null</span>) &#123;<br>                pre_h3 = h3;<br>                root = h3;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre_h3.next = h3;<br>                pre_h3 = h3;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (h1 != <span class="hljs-keyword">null</span>) &#123;<br>                h3.next = h1;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                h3.next = h2;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 合并二项堆：将h1, h2合并成一个堆，并返回合并后的堆<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">union</span><span class="hljs-params">(BinomialNode&lt;T&gt; h1, BinomialNode&lt;T&gt; h2)</span> </span>&#123;<br>        BinomialNode&lt;T&gt; root;<br><br>        <span class="hljs-comment">// 将h1, h2中的根表合并成一个按度数递增的链表root</span><br>        root = merge(h1, h2);<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        BinomialNode&lt;T&gt; prev_x = <span class="hljs-keyword">null</span>;<br>        BinomialNode&lt;T&gt; x      = root;<br>        BinomialNode&lt;T&gt; next_x = x.next;<br>        <span class="hljs-keyword">while</span> (next_x != <span class="hljs-keyword">null</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (   (x.degree != next_x.degree)<br>                || ((next_x.next != <span class="hljs-keyword">null</span>) &amp;&amp; (next_x.degree == next_x.next.degree))) &#123;<br>                <span class="hljs-comment">// Case 1: x.degree != next_x.degree</span><br>                <span class="hljs-comment">// Case 2: x.degree == next_x.degree == next_x.next.degree</span><br>                prev_x = x;<br>                x = next_x;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.key.compareTo(next_x.key) &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// Case 3: x.degree == next_x.degree != next_x.next.degree</span><br>                <span class="hljs-comment">//      &amp;&amp; x.key    &lt;= next_x.key</span><br>                x.next = next_x.next;<br>                link(next_x, x);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Case 4: x.degree == next_x.degree != next_x.next.degree</span><br>                <span class="hljs-comment">//      &amp;&amp; x.key    &gt;  next_x.key</span><br>                <span class="hljs-keyword">if</span> (prev_x == <span class="hljs-keyword">null</span>) &#123;<br>                    root = next_x;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    prev_x.next = next_x;<br>                &#125;<br>                link(x, next_x);<br>                x = next_x;<br>            &#125;<br>            next_x = x.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将二项堆other合并到当前堆中<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(BinomialHeap&lt;T&gt; other)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (other!=<span class="hljs-keyword">null</span> &amp;&amp; other.mRoot!=<span class="hljs-keyword">null</span>)<br>            mRoot = union(mRoot, other.mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 新建key对应的节点，并将其插入到二项堆中。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T key)</span> </span>&#123;<br>        BinomialNode&lt;T&gt; node;<br><br>        <span class="hljs-comment">// 禁止插入相同的键值</span><br>        <span class="hljs-keyword">if</span> (contains(key)==<span class="hljs-keyword">true</span>) &#123;<br>            System.out.printf(<span class="hljs-string">"insert failed: the key(%s) is existed already!\n"</span>, key);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        node = <span class="hljs-keyword">new</span> BinomialNode&lt;T&gt;(key);<br>        <span class="hljs-keyword">if</span> (node==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        mRoot = union(mRoot, node);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 反转二项堆root，并返回反转后的根节点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">reverse</span><span class="hljs-params">(BinomialNode&lt;T&gt; root)</span> </span>&#123;<br>        BinomialNode&lt;T&gt; next;<br>        BinomialNode&lt;T&gt; tail = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br><br>        root.parent = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span> (root.next!=<span class="hljs-keyword">null</span>) &#123;<br>            next         = root.next;<br>            root.next    = tail;<br>            tail         = root;<br>            root         = next;<br>            root.parent  = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        root.next = tail;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 移除二项堆root中的最小节点，并返回删除节点后的二项树<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">extractMinimum</span><span class="hljs-params">(BinomialNode&lt;T&gt; root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br><br>        BinomialNode&lt;T&gt; x, prev_x;    <span class="hljs-comment">// x是用来遍历的当前节点</span><br>        BinomialNode&lt;T&gt; y, prev_y;    <span class="hljs-comment">// y是最小节点</span><br><br>        prev_x  = root;<br>        x       = root.next;<br>        prev_y = <span class="hljs-keyword">null</span>;<br>        y      = root;<br>        <span class="hljs-comment">// 找到最小节点</span><br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (x.key.compareTo(y.key) &lt; <span class="hljs-number">0</span>) &#123;<br>                y = x;<br>                prev_y = prev_x;<br>            &#125;<br>            prev_x = x;<br>            x = x.next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (prev_y == <span class="hljs-keyword">null</span>)    <span class="hljs-comment">// root的根节点就是最小根节点</span><br>            root = root.next;<br>        <span class="hljs-keyword">else</span>                <span class="hljs-comment">// root的根节点不是最小根节点</span><br>            prev_y.next = y.next;<br><br>        <span class="hljs-comment">// 反转最小节点的左孩子，得到最小堆child；</span><br>        <span class="hljs-comment">// 这样，就使得最小节点所在二项树的孩子们都脱离出来成为一棵独立的二项树(不包括最小节点)</span><br>        BinomialNode&lt;T&gt; child = reverse(y.child);<br>        <span class="hljs-comment">// 将"删除最小节点的二项堆child"和"root"进行合并。</span><br>        root = union(root, child);<br><br>        <span class="hljs-comment">// help GC</span><br>        y = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">extractMinimum</span><span class="hljs-params">()</span> </span>&#123;<br>        mRoot = extractMinimum(mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 减少关键字的值：将二项堆中的节点node的键值减小为key。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decreaseKey</span><span class="hljs-params">(BinomialNode&lt;T&gt; node, T key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(key.compareTo(node.key)&gt;=<span class="hljs-number">0</span> || contains(key)==<span class="hljs-keyword">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">"decrease failed: the new key("</span>+key+<span class="hljs-string">") is existed already, or is no smaller than current key("</span>+node.key+<span class="hljs-string">")"</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        node.key = key;<br><br>        BinomialNode&lt;T&gt; child, parent;<br>        child = node;<br>        parent = node.parent;<br>        <span class="hljs-keyword">while</span>(parent != <span class="hljs-keyword">null</span> &amp;&amp; child.key.compareTo(parent.key)&lt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 交换parent和child的数据</span><br>            T tmp = parent.key;<br>            parent.key = child.key;<br>            child.key = tmp;<br><br>            child = parent;<br>            parent = child.parent;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 增加关键字的值：将二项堆中的节点node的键值增加为key。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increaseKey</span><span class="hljs-params">(BinomialNode&lt;T&gt; node, T key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(key.compareTo(node.key)&lt;=<span class="hljs-number">0</span> || contains(key)==<span class="hljs-keyword">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">"increase failed: the new key("</span>+key+<span class="hljs-string">") is existed already, or is no greater than current key("</span>+node.key+<span class="hljs-string">")"</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        node.key = key;<br><br>        BinomialNode&lt;T&gt; cur = node;<br>        BinomialNode&lt;T&gt; child = cur.child;<br>        <span class="hljs-keyword">while</span> (child != <span class="hljs-keyword">null</span>) &#123;<br><br>            <span class="hljs-keyword">if</span>(cur.key.compareTo(child.key) &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 如果"当前节点" &lt; "它的左孩子"，</span><br>                <span class="hljs-comment">// 则在"它的孩子中(左孩子 和 左孩子的兄弟)"中，找出最小的节点；</span><br>                <span class="hljs-comment">// 然后将"最小节点的值" 和 "当前节点的值"进行互换</span><br>                BinomialNode&lt;T&gt; least = child;    <span class="hljs-comment">// least是child和它的兄弟中的最小节点</span><br>                <span class="hljs-keyword">while</span>(child.next != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (least.key.compareTo(child.next.key) &gt; <span class="hljs-number">0</span>)<br>                        least = child.next;<br>                    child = child.next;<br>                &#125;<br>                <span class="hljs-comment">// 交换最小节点和当前节点的值</span><br>                T tmp = least.key;<br>                least.key = cur.key;<br>                cur.key = tmp;<br><br>                <span class="hljs-comment">// 交换数据之后，再对"原最小节点"进行调整，使它满足最小堆的性质：父节点 &lt;= 子节点</span><br>                cur = least;<br>                child = cur.child;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                child = child.next;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 更新二项堆的节点node的键值为key<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateKey</span><span class="hljs-params">(BinomialNode&lt;T&gt; node, T key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">int</span> cmp = key.compareTo(node.key);<br>        <span class="hljs-keyword">if</span>(cmp &lt; <span class="hljs-number">0</span>)                            <span class="hljs-comment">// key &lt; node.key</span><br>            decreaseKey(node, key);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp &gt; <span class="hljs-number">0</span>)                    <span class="hljs-comment">// key &gt; node.key</span><br>            increaseKey(node, key);<br>        <span class="hljs-keyword">else</span><br>            System.out.println(<span class="hljs-string">"No need to update!!!"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将二项堆中键值oldkey更新为newkey<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(T oldkey, T newkey)</span> </span>&#123;<br>        BinomialNode&lt;T&gt; node;<br><br>        node = search(mRoot, oldkey);<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)<br>            updateKey(node, newkey);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 查找：在二项堆中查找键值为key的节点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">search</span><span class="hljs-params">(BinomialNode&lt;T&gt; root, T key)</span> </span>&#123;<br>        BinomialNode&lt;T&gt; child;<br>        BinomialNode&lt;T&gt; parent = root;<br><br>        parent = root;<br>        <span class="hljs-keyword">while</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (parent.key.compareTo(key) == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> parent;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>((child = search(parent.child, key)) != <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-keyword">return</span> child;<br>                parent = parent.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 二项堆中是否包含键值key<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(T key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> search(mRoot, key)!=<span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 删除节点：删除键值为key的节点<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> BinomialNode&lt;T&gt; <span class="hljs-title">remove</span><span class="hljs-params">(BinomialNode&lt;T&gt; root, T key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br><br>        BinomialNode&lt;T&gt; node;<br><br>        <span class="hljs-comment">// 查找键值为key的节点</span><br>        <span class="hljs-keyword">if</span> ((node = search(root, key)) == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-comment">// 将被删除的节点的数据数据上移到它所在的二项树的根节点</span><br>        BinomialNode&lt;T&gt; parent = node.parent;<br>        <span class="hljs-keyword">while</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 交换数据</span><br>            T tmp = node.key;<br>            node.key = parent.key;<br>            parent.key = tmp;<br><br>            <span class="hljs-comment">// 下一个父节点</span><br>            node   = parent;<br>            parent = node.parent;<br>        &#125;<br><br>        <span class="hljs-comment">// 找到node的前一个根节点(prev)</span><br>        BinomialNode&lt;T&gt; prev = <span class="hljs-keyword">null</span>;<br>        BinomialNode&lt;T&gt; pos  = root;<br>        <span class="hljs-keyword">while</span> (pos != node) &#123;<br>            prev = pos;<br>            pos  = pos.next;<br>        &#125;<br>        <span class="hljs-comment">// 移除node节点</span><br>        <span class="hljs-keyword">if</span> (prev!=<span class="hljs-keyword">null</span>)<br>            prev.next = node.next;<br>        <span class="hljs-keyword">else</span><br>            root = node.next;<br><br>        root = union(root, reverse(node.child));<br><br>        <span class="hljs-comment">// help GC</span><br>        node = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(T key)</span> </span>&#123;<br>        mRoot = remove(mRoot, key);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 打印"二项堆"<br>     *<br>     * 参数说明：<br>     *     node       -- 当前节点<br>     *     prev       -- 当前节点的前一个节点(父节点or兄弟节点)<br>     *     direction  --  1，表示当前节点是一个左孩子;<br>     *                    2，表示当前节点是一个兄弟节点。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(BinomialNode&lt;T&gt; node, BinomialNode&lt;T&gt; prev, <span class="hljs-keyword">int</span> direction)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(node != <span class="hljs-keyword">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(direction==<span class="hljs-number">1</span>)    <span class="hljs-comment">// node是根节点</span><br>                System.out.printf(<span class="hljs-string">"\t%2d(%d) is %2d's child\n"</span>, node.key, node.degree, prev.key);<br>            <span class="hljs-keyword">else</span>                <span class="hljs-comment">// node是分支节点</span><br>                System.out.printf(<span class="hljs-string">"\t%2d(%d) is %2d's next\n"</span>, node.key, node.degree, prev.key);<br><br>            <span class="hljs-keyword">if</span> (node.child != <span class="hljs-keyword">null</span>)<br>                print(node.child, node, <span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// 兄弟节点</span><br>            prev = node;<br>            node = node.next;<br>            direction = <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mRoot == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        BinomialNode&lt;T&gt; p = mRoot;<br>        System.out.printf(<span class="hljs-string">"== 二项堆( "</span>);<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;<br>            System.out.printf(<span class="hljs-string">"B%d "</span>, p.degree);<br>            p = p.next;<br>        &#125;<br>        System.out.printf(<span class="hljs-string">")的详细信息：\n"</span>);<br><br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        p = mRoot;<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;<br>            i++;<br>            System.out.printf(<span class="hljs-string">"%d. 二项树B%d: \n"</span>, i, p.degree);<br>            System.out.printf(<span class="hljs-string">"\t%2d(%d) is root\n"</span>, p.key, p.degree);<br><br>            print(p.child, p, <span class="hljs-number">1</span>);<br>            p = p.next;<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二项堆的测试程序-Main-java"><a href="#二项堆的测试程序-Main-java" class="headerlink" title="二项堆的测试程序(Main.java)"></a>二项堆的测试程序(Main.java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * Java 语言: 二项堆<br> *<br> * <span class="hljs-doctag">@author</span> skywang<br> * <span class="hljs-doctag">@date</span> 2014/03/31<br> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> DEBUG = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">// 共7个 = 1+2+4</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">12</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">25</span>, <span class="hljs-number">15</span>, <span class="hljs-number">28</span>, <span class="hljs-number">33</span>, <span class="hljs-number">41</span>&#125;;<br>    <span class="hljs-comment">// 共13个 = 1+4+8</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b[] = &#123;<span class="hljs-number">18</span>, <span class="hljs-number">35</span>, <span class="hljs-number">20</span>, <span class="hljs-number">42</span>,  <span class="hljs-number">9</span>,<br>               <span class="hljs-number">31</span>, <span class="hljs-number">23</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">48</span>, <span class="hljs-number">11</span>,<br>               <span class="hljs-number">24</span>, <span class="hljs-number">52</span>, <span class="hljs-number">13</span> &#125;;<br><br><br>    <span class="hljs-comment">// 验证"二项堆的插入操作"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsert</span><span class="hljs-params">()</span> </span>&#123;<br>        BinomialHeap&lt;Integer&gt; ha=<span class="hljs-keyword">new</span> BinomialHeap&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 二项堆ha</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(ha)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            ha.insert(a[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 二项堆(ha)的详细信息: \n"</span>);<br>        ha.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"二项堆的合并操作"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUnion</span><span class="hljs-params">()</span> </span>&#123;<br>        BinomialHeap&lt;Integer&gt; ha=<span class="hljs-keyword">new</span> BinomialHeap&lt;Integer&gt;();<br>        BinomialHeap&lt;Integer&gt; hb=<span class="hljs-keyword">new</span> BinomialHeap&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 二项堆ha</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(ha)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            ha.insert(a[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        System.out.printf(<span class="hljs-string">"== 二项堆(ha)的详细信息: \n"</span>);<br>        ha.print();<br><br>        <span class="hljs-comment">// 二项堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        <span class="hljs-comment">// 打印二项堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(hb)的详细信息: \n"</span>);<br>        hb.print();<br><br>        <span class="hljs-comment">// 将"二项堆hb"合并到"二项堆ha"中。</span><br>        ha.union(hb);<br>        <span class="hljs-comment">// 打印二项堆ha的详细信息</span><br>        System.out.printf(<span class="hljs-string">"== 合并ha和hb后的详细信息:\n"</span>);<br>        ha.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"二项堆的删除操作"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span> </span>&#123;<br>        BinomialHeap&lt;Integer&gt; hb=<span class="hljs-keyword">new</span> BinomialHeap&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 二项堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        <span class="hljs-comment">// 打印二项堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(hb)的详细信息: \n"</span>);<br>        hb.print();<br><br>        <span class="hljs-comment">// 将"二项堆hb"合并到"二项堆ha"中。</span><br>        hb.remove(<span class="hljs-number">20</span>);<br>        System.out.printf(<span class="hljs-string">"== 删除节点20后的详细信息: \n"</span>);<br>        hb.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"二项堆的更新(减少)操作"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDecrease</span><span class="hljs-params">()</span> </span>&#123;<br>        BinomialHeap&lt;Integer&gt; hb=<span class="hljs-keyword">new</span> BinomialHeap&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 二项堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        <span class="hljs-comment">// 打印二项堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(hb)的详细信息: \n"</span>);<br>        hb.print();<br><br>        <span class="hljs-comment">// 将节点20更新为2</span><br>        hb.update(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>);<br>        System.out.printf(<span class="hljs-string">"== 更新节点20-&gt;2后的详细信息: \n"</span>);<br>        hb.print();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证"二项堆的更新(减少)操作"</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIncrease</span><span class="hljs-params">()</span> </span>&#123;<br>        BinomialHeap&lt;Integer&gt; hb=<span class="hljs-keyword">new</span> BinomialHeap&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 二项堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>        <span class="hljs-comment">// 打印二项堆hb</span><br>        System.out.printf(<span class="hljs-string">"== 二项堆(hb)的详细信息: \n"</span>);<br>        hb.print();<br><br>        <span class="hljs-comment">// 将节点6更新为60</span><br>        hb.update(<span class="hljs-number">6</span>, <span class="hljs-number">60</span>);<br>        System.out.printf(<span class="hljs-string">"== 更新节点6-&gt;60后的详细信息: \n"</span>);<br>        hb.print();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1. 验证"二项堆的插入操作"</span><br>        testInsert();<br>        <span class="hljs-comment">// 2. 验证"二项堆的合并操作"</span><br>        <span class="hljs-comment">//testUnion();</span><br>        <span class="hljs-comment">// 3. 验证"二项堆的删除操作"</span><br>        <span class="hljs-comment">//testDelete();</span><br>        <span class="hljs-comment">// 4. 验证"二项堆的更新(减少)操作"</span><br>        <span class="hljs-comment">//testDecrease();</span><br>        <span class="hljs-comment">// 5. 验证"二项堆的更新(增加)操作"</span><br>        <span class="hljs-comment">//testIncrease();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">== 二项堆(ha)中依次添加: 12 7 25 15 28 33 41 </span><br><span class="hljs-section">== 二项堆(ha)的详细信息: </span><br><span class="hljs-section">== 二项堆( B0 B1 B2 )的详细信息：</span><br>1. 二项树B0: <br><span class="hljs-code">    41(0) is root</span><br>2. 二项树B1: <br><span class="hljs-code">    28(1) is root</span><br><span class="hljs-code">    33(0) is 28's child</span><br>3. 二项树B2: <br><span class="hljs-code">     7(2) is root</span><br><span class="hljs-code">    15(1) is  7's child</span><br><span class="hljs-code">    25(0) is 15's child</span><br><span class="hljs-code">    12(0) is 15's next</span><br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二项堆&quot;&gt;&lt;a href=&quot;#二项堆&quot; class=&quot;headerlink&quot; title=&quot;二项堆&quot;&gt;&lt;/a&gt;二项堆&lt;/h1&gt;&lt;p&gt;二项堆是二项树的集合。在了解二项堆之前，先对二项树进行介绍。&lt;/p&gt;
&lt;h2 id=&quot;二项树的介绍&quot;&gt;&lt;a href=&quot;#二项树的介
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>6.3.斜堆</title>
    <link href="http://yoursite.com/2022/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.3.%E6%96%9C%E5%A0%86/"/>
    <id>http://yoursite.com/2022/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.3.%E6%96%9C%E5%A0%86/</id>
    <published>2022-01-06T14:36:39.000Z</published>
    <updated>2022-02-21T00:54:33.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="斜堆"><a href="#斜堆" class="headerlink" title="斜堆"></a>斜堆</h1><h2 id="斜堆的介绍"><a href="#斜堆的介绍" class="headerlink" title="斜堆的介绍"></a>斜堆的介绍</h2><p>斜堆(Skew heap)也叫自适应堆(self-adjusting heap)，它是左倾堆的一个变种。和左倾堆一样，它通常也用于实现优先队列；作为一种自适应的左倾堆，它的合并操作的时间复杂度也是O(lg n)。</p><p>它与左倾堆的差别是：<br>(1) 斜堆的节点没有”零距离”这个属性，而左倾堆则有。<br>(2) 斜堆的合并操作和左倾堆的合并操作算法不同。</p><p>斜堆的合并操作：<br>(1) 如果一个空斜堆与一个非空斜堆合并，返回非空斜堆。<br>(2) 如果两个斜堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将”较小堆的根节点的右孩子”和”较大堆”进行合并。<br>(3) 合并后，交换新堆根节点的左孩子和右孩子。<br>第(03)步是斜堆和左倾堆的合并操作差别的关键所在，如果是左倾堆，则合并后要比较左右孩子的零距离大小，若右孩子的零距离 &gt; 左孩子的零距离，则交换左右孩子；最后，在设置根的零距离。</p><h2 id="斜堆的基本操作"><a href="#斜堆的基本操作" class="headerlink" title="斜堆的基本操作"></a><strong>斜堆的基本操作</strong></h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkewHeap</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> SkewNode&lt;T&gt; mRoot;    <span class="hljs-comment">// 根结点</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkewNode</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        T key;                <span class="hljs-comment">// 关键字(键值)</span><br>        SkewNode&lt;T&gt; left;    <span class="hljs-comment">// 左孩子</span><br>        SkewNode&lt;T&gt; right;    <span class="hljs-comment">// 右孩子</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SkewNode</span><span class="hljs-params">(T key, SkewNode&lt;T&gt; left, SkewNode&lt;T&gt; right)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"key:"</span>+key;<br>        &#125;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>SkewNode是斜堆对应的节点类。<br>SkewHeap是斜堆类，它包含了斜堆的根节点，以及斜堆的操作。</p><h3 id="2-合并"><a href="#2-合并" class="headerlink" title="2. 合并"></a><strong>2. 合并</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 合并"斜堆x"和"斜堆y"<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> SkewNode&lt;T&gt; <span class="hljs-title">merge</span><span class="hljs-params">(SkewNode&lt;T&gt; x, SkewNode&lt;T&gt; y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> y;<br>    <span class="hljs-keyword">if</span>(y == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> x;<br><br>    <span class="hljs-comment">// 合并x和y时，将x作为合并后的树的根；</span><br>    <span class="hljs-comment">// 这里的操作是保证: x的key &lt; y的key</span><br>    <span class="hljs-keyword">if</span>(x.key.compareTo(y.key) &gt; <span class="hljs-number">0</span>) &#123;<br>        SkewNode&lt;T&gt; tmp = x;<br>        x = y;<br>        y = tmp;<br>    &#125;<br><br>    <span class="hljs-comment">// 将x的右孩子和y合并，</span><br>    <span class="hljs-comment">// 合并后直接交换x的左右孩子，而不需要像左倾堆一样考虑它们的npl。</span><br>    SkewNode&lt;T&gt; tmp = merge(x.right, y);<br>    x.right = x.left;<br>    x.left = tmp;<br><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(SkewHeap&lt;T&gt; other)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.mRoot = merge(<span class="hljs-keyword">this</span>.mRoot, other.mRoot);<br>&#125;<br></code></pre></td></tr></table></figure><p>merge(x, y)是内部接口，作用是合并x和y这两个斜堆，并返回得到的新堆的根节点。<br>merge(other)是外部接口，作用是将other合并到当前堆中。</p><h3 id="3-添加"><a href="#3-添加" class="headerlink" title="3. 添加"></a><strong>3. 添加</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 新建结点(key)，并将其插入到斜堆中<br> *<br> * 参数说明：<br> *     key 插入结点的键值<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T key)</span> </span>&#123;<br>    SkewNode&lt;T&gt; node = <span class="hljs-keyword">new</span> SkewNode&lt;T&gt;(key,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-comment">// 如果新建结点失败，则返回。</span><br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">this</span>.mRoot = merge(<span class="hljs-keyword">this</span>.mRoot, node);<br>&#125;<br></code></pre></td></tr></table></figure><p>insert(key)的作用是新建键值为key的节点，并将其加入到当前斜堆中。</p><h3 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a><strong>4. 删除</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 删除根结点<br> * <br> * 返回值：<br> *     返回被删除的节点的键值<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mRoot == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    T key = <span class="hljs-keyword">this</span>.mRoot.key;<br>    SkewNode&lt;T&gt; l = <span class="hljs-keyword">this</span>.mRoot.left;<br>    SkewNode&lt;T&gt; r = <span class="hljs-keyword">this</span>.mRoot.right;<br><br>    <span class="hljs-keyword">this</span>.mRoot = <span class="hljs-keyword">null</span>;          <span class="hljs-comment">// 删除根节点</span><br>    <span class="hljs-keyword">this</span>.mRoot = merge(l, r);   <span class="hljs-comment">// 合并左右子树</span><br><br>    <span class="hljs-keyword">return</span> key;<br>&#125;<br></code></pre></td></tr></table></figure><p>remove()的作用是删除斜堆的最小节点。</p><h2 id="斜堆的代码实现"><a href="#斜堆的代码实现" class="headerlink" title="斜堆的代码实现"></a>斜堆的代码实现</h2><h3 id="斜堆的实现文件-SkewHeap-java"><a href="#斜堆的实现文件-SkewHeap-java" class="headerlink" title="斜堆的实现文件(SkewHeap.java)"></a>斜堆的实现文件(SkewHeap.java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkewHeap</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> SkewNode&lt;T&gt; mRoot;    <span class="hljs-comment">// 根结点</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkewNode</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        T key;                <span class="hljs-comment">// 关键字(键值)</span><br>        SkewNode&lt;T&gt; left;    <span class="hljs-comment">// 左孩子</span><br>        SkewNode&lt;T&gt; right;    <span class="hljs-comment">// 右孩子</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SkewNode</span><span class="hljs-params">(T key, SkewNode&lt;T&gt; left, SkewNode&lt;T&gt; right)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"key:"</span>+key;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SkewHeap</span><span class="hljs-params">()</span> </span>&#123;<br>        mRoot = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 前序遍历"斜堆"<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(SkewNode&lt;T&gt; heap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(heap != <span class="hljs-keyword">null</span>) &#123;<br>            System.out.print(heap.key+<span class="hljs-string">" "</span>);<br>            preOrder(heap.left);<br>            preOrder(heap.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        preOrder(mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 中序遍历"斜堆"<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(SkewNode&lt;T&gt; heap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(heap != <span class="hljs-keyword">null</span>) &#123;<br>            inOrder(heap.left);<br>            System.out.print(heap.key+<span class="hljs-string">" "</span>);<br>            inOrder(heap.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        inOrder(mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 后序遍历"斜堆"<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(SkewNode&lt;T&gt; heap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(heap != <span class="hljs-keyword">null</span>)<br>        &#123;<br>            postOrder(heap.left);<br>            postOrder(heap.right);<br>            System.out.print(heap.key+<span class="hljs-string">" "</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        postOrder(mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 合并"斜堆x"和"斜堆y"<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> SkewNode&lt;T&gt; <span class="hljs-title">merge</span><span class="hljs-params">(SkewNode&lt;T&gt; x, SkewNode&lt;T&gt; y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> y;<br>        <span class="hljs-keyword">if</span>(y == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> x;<br><br>        <span class="hljs-comment">// 合并x和y时，将x作为合并后的树的根；</span><br>        <span class="hljs-comment">// 这里的操作是保证: x的key &lt; y的key</span><br>        <span class="hljs-keyword">if</span>(x.key.compareTo(y.key) &gt; <span class="hljs-number">0</span>) &#123;<br>            SkewNode&lt;T&gt; tmp = x;<br>            x = y;<br>            y = tmp;<br>        &#125;<br><br>        <span class="hljs-comment">// 将x的右孩子和y合并，</span><br>        <span class="hljs-comment">// 合并后直接交换x的左右孩子，而不需要像左倾堆一样考虑它们的npl。</span><br>        SkewNode&lt;T&gt; tmp = merge(x.right, y);<br>        x.right = x.left;<br>        x.left = tmp;<br><br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(SkewHeap&lt;T&gt; other)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mRoot = merge(<span class="hljs-keyword">this</span>.mRoot, other.mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 新建结点(key)，并将其插入到斜堆中<br>     *<br>     * 参数说明：<br>     *     key 插入结点的键值<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T key)</span> </span>&#123;<br>        SkewNode&lt;T&gt; node = <span class="hljs-keyword">new</span> SkewNode&lt;T&gt;(key,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">// 如果新建结点失败，则返回。</span><br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">this</span>.mRoot = merge(<span class="hljs-keyword">this</span>.mRoot, node);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 删除根结点<br>     *<br>     * 返回值：<br>     *     返回被删除的节点的键值<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mRoot == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        T key = <span class="hljs-keyword">this</span>.mRoot.key;<br>        SkewNode&lt;T&gt; l = <span class="hljs-keyword">this</span>.mRoot.left;<br>        SkewNode&lt;T&gt; r = <span class="hljs-keyword">this</span>.mRoot.right;<br><br>        <span class="hljs-keyword">this</span>.mRoot = <span class="hljs-keyword">null</span>;          <span class="hljs-comment">// 删除根节点</span><br>        <span class="hljs-keyword">this</span>.mRoot = merge(l, r);   <span class="hljs-comment">// 合并左右子树</span><br><br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 销毁斜堆<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(SkewNode&lt;T&gt; heap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (heap==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span> (heap.left != <span class="hljs-keyword">null</span>)<br>            destroy(heap.left);<br>        <span class="hljs-keyword">if</span> (heap.right != <span class="hljs-keyword">null</span>)<br>            destroy(heap.right);<br><br>        heap=<span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>        destroy(mRoot);<br>        mRoot = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 打印"斜堆"<br>     *<br>     * key        -- 节点的键值<br>     * direction  --  0，表示该节点是根节点;<br>     *               -1，表示该节点是它的父结点的左孩子;<br>     *                1，表示该节点是它的父结点的右孩子。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(SkewNode&lt;T&gt; heap, T key, <span class="hljs-keyword">int</span> direction)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(heap != <span class="hljs-keyword">null</span>) &#123;<br><br>            <span class="hljs-keyword">if</span>(direction==<span class="hljs-number">0</span>)    <span class="hljs-comment">// heap是根节点</span><br>                System.out.printf(<span class="hljs-string">"%2d is root\n"</span>, heap.key);<br>            <span class="hljs-keyword">else</span>                <span class="hljs-comment">// heap是分支节点</span><br>                System.out.printf(<span class="hljs-string">"%2d is %2d's %6s child\n"</span>, heap.key, key, direction==<span class="hljs-number">1</span>?<span class="hljs-string">"right"</span> : <span class="hljs-string">"left"</span>);<br><br>            print(heap.left, heap.key, -<span class="hljs-number">1</span>);<br>            print(heap.right,heap.key,  <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mRoot != <span class="hljs-keyword">null</span>)<br>            print(mRoot, mRoot.key, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="斜堆的测试程序-SkewHeapTest-java"><a href="#斜堆的测试程序-SkewHeapTest-java" class="headerlink" title="斜堆的测试程序(SkewHeapTest.java)"></a>斜堆的测试程序(SkewHeapTest.java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkewHeapTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> a[]= &#123;<span class="hljs-number">10</span>,<span class="hljs-number">40</span>,<span class="hljs-number">24</span>,<span class="hljs-number">30</span>,<span class="hljs-number">36</span>,<span class="hljs-number">20</span>,<span class="hljs-number">12</span>,<span class="hljs-number">16</span>&#125;;<br>        <span class="hljs-keyword">int</span> b[]= &#123;<span class="hljs-number">17</span>,<span class="hljs-number">13</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>,<span class="hljs-number">19</span>,<span class="hljs-number">21</span>,<span class="hljs-number">23</span>&#125;;<br>        SkewHeap&lt;Integer&gt; ha=<span class="hljs-keyword">new</span> SkewHeap&lt;Integer&gt;();<br>        SkewHeap&lt;Integer&gt; hb=<span class="hljs-keyword">new</span> SkewHeap&lt;Integer&gt;();<br><br>        System.out.printf(<span class="hljs-string">"== 斜堆(ha)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            ha.insert(a[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n== 斜堆(ha)的详细信息: \n"</span>);<br>        ha.print();<br><br><br>        System.out.printf(<span class="hljs-string">"\n== 斜堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n== 斜堆(hb)的详细信息: \n"</span>);<br>        hb.print();<br><br>        <span class="hljs-comment">// 将"斜堆hb"合并到"斜堆ha"中。</span><br>        ha.merge(hb);<br>        System.out.printf(<span class="hljs-string">"\n== 合并ha和hb后的详细信息: \n"</span>);<br>        ha.print();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ada">== 斜堆(ha)中依次添加: <span class="hljs-number">10</span> <span class="hljs-number">40</span> <span class="hljs-number">24</span> <span class="hljs-number">30</span> <span class="hljs-number">36</span> <span class="hljs-number">20</span> <span class="hljs-number">12</span> <span class="hljs-number">16</span> <br>== 斜堆(ha)的详细信息: <br><span class="hljs-number">10</span> <span class="hljs-keyword">is</span> root<br><span class="hljs-number">16</span> <span class="hljs-keyword">is</span> <span class="hljs-number">10</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">20</span> <span class="hljs-keyword">is</span> <span class="hljs-number">16</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">30</span> <span class="hljs-keyword">is</span> <span class="hljs-number">20</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">40</span> <span class="hljs-keyword">is</span> <span class="hljs-number">30</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">12</span> <span class="hljs-keyword">is</span> <span class="hljs-number">10</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">24</span> <span class="hljs-keyword">is</span> <span class="hljs-number">12</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">36</span> <span class="hljs-keyword">is</span> <span class="hljs-number">24</span><span class="hljs-symbol">'s</span>   left child<br><br>== 斜堆(hb)中依次添加: <span class="hljs-number">17</span> <span class="hljs-number">13</span> <span class="hljs-number">11</span> <span class="hljs-number">15</span> <span class="hljs-number">19</span> <span class="hljs-number">21</span> <span class="hljs-number">23</span> <br>== 斜堆(hb)的详细信息: <br><span class="hljs-number">11</span> <span class="hljs-keyword">is</span> root<br><span class="hljs-number">13</span> <span class="hljs-keyword">is</span> <span class="hljs-number">11</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">17</span> <span class="hljs-keyword">is</span> <span class="hljs-number">13</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">23</span> <span class="hljs-keyword">is</span> <span class="hljs-number">17</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">19</span> <span class="hljs-keyword">is</span> <span class="hljs-number">13</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">15</span> <span class="hljs-keyword">is</span> <span class="hljs-number">11</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">21</span> <span class="hljs-keyword">is</span> <span class="hljs-number">15</span><span class="hljs-symbol">'s</span>   left child<br><br>== 合并ha和hb后的详细信息: <br><span class="hljs-number">10</span> <span class="hljs-keyword">is</span> root<br><span class="hljs-number">11</span> <span class="hljs-keyword">is</span> <span class="hljs-number">10</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">12</span> <span class="hljs-keyword">is</span> <span class="hljs-number">11</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">15</span> <span class="hljs-keyword">is</span> <span class="hljs-number">12</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">21</span> <span class="hljs-keyword">is</span> <span class="hljs-number">15</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">24</span> <span class="hljs-keyword">is</span> <span class="hljs-number">12</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">36</span> <span class="hljs-keyword">is</span> <span class="hljs-number">24</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">13</span> <span class="hljs-keyword">is</span> <span class="hljs-number">11</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">17</span> <span class="hljs-keyword">is</span> <span class="hljs-number">13</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">23</span> <span class="hljs-keyword">is</span> <span class="hljs-number">17</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">19</span> <span class="hljs-keyword">is</span> <span class="hljs-number">13</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">16</span> <span class="hljs-keyword">is</span> <span class="hljs-number">10</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">20</span> <span class="hljs-keyword">is</span> <span class="hljs-number">16</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">30</span> <span class="hljs-keyword">is</span> <span class="hljs-number">20</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">40</span> <span class="hljs-keyword">is</span> <span class="hljs-number">30</span><span class="hljs-symbol">'s</span>   left child<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;斜堆&quot;&gt;&lt;a href=&quot;#斜堆&quot; class=&quot;headerlink&quot; title=&quot;斜堆&quot;&gt;&lt;/a&gt;斜堆&lt;/h1&gt;&lt;h2 id=&quot;斜堆的介绍&quot;&gt;&lt;a href=&quot;#斜堆的介绍&quot; class=&quot;headerlink&quot; title=&quot;斜堆的介绍&quot;&gt;&lt;/a&gt;斜堆的介
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>6.2.左倾堆</title>
    <link href="http://yoursite.com/2022/01/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.2.%E5%B7%A6%E5%80%BE%E5%A0%86/"/>
    <id>http://yoursite.com/2022/01/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.2.%E5%B7%A6%E5%80%BE%E5%A0%86/</id>
    <published>2022-01-04T14:35:39.000Z</published>
    <updated>2022-02-21T00:54:33.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="左倾堆"><a href="#左倾堆" class="headerlink" title="左倾堆"></a><strong>左倾堆</strong></h1><p>左倾堆(leftist tree 或 leftist heap)，又被成为左偏树、左偏堆，最左堆等。<br>它和二叉堆一样，都是优先队列实现方式。当优先队列中涉及到”对两个优先队列进行合并”的问题时，二叉堆的效率就无法令人满意了。</p><p><strong>==目的：对两个优先队列进行合并==</strong></p><h2 id="左倾堆的定义"><a href="#左倾堆的定义" class="headerlink" title="左倾堆的定义"></a><strong>左倾堆的定义</strong></h2><p><a href="https://images0.cnblogs.com/i/497634/201404/011451438751063.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlytpjgf3j30hd0b274p.jpg" alt="img"></a></p><p>上图是一颗左倾树，它的节点除了和二叉树的节点一样具有左右子树指针外，还有两个属性：键值和零距离。<br>(1) 键值的作用是来比较节点的大小，从而对节点进行排序。<br>(2) 零距离(英文名NPL，即Null Path Length)则是从一个节点到一个”最近的不满节点”的路径长度。不满节点是指该该节点的左右孩子至少有有一个为NULL。叶节点的NPL为0，NULL节点的NPL为-1。</p><p>左倾堆有以下几个基本性质：<br>[性质1] 节点的键值小于或等于它的左右子节点的键值。(小顶堆?)<br>[性质2] 节点的左孩子的NPL &gt;= 右孩子的NPL。<br>[性质3] 节点的NPL = 它的右孩子的NPL + 1。</p><h2 id="左倾堆的图文解析"><a href="#左倾堆的图文解析" class="headerlink" title="左倾堆的图文解析"></a>左倾堆的图文解析</h2><p>合并操作是左倾堆的重点。合并两个左倾堆的基本思想如下：<br>(01) 如果一个空左倾堆与一个非空左倾堆合并，返回非空左倾堆。<br>(02) 如果两个左倾堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将”较小堆的根节点的右孩子”和”较大堆”进行合并。<br>(03) 如果新堆的右孩子的NPL &gt; 左孩子的NPL，则交换左右孩子。<br>(04) 设置新堆的根节点的NPL = 右子堆NPL + 1</p><p>下面通过图文演示合并以下两个堆的过程。</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011452529377696.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyvalepjj30x40b2759.jpg" alt="img"></a><br><strong>提示</strong>：这两个堆的合并过程和测试程序相对应！</p><p><strong>第1步：将”较小堆(根为10)的右孩子”和”较大堆(根为11)”进行合并。</strong><br>合并的结果，相当于将”较大堆”设置”较小堆”的右孩子，如下图所示：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011453446095544.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyvemd0mj30x40kxwg3.jpg" alt="img"></a></p><p><strong>第2步：将上一步得到的”根11的右子树”和”根为12的树”进行合并</strong>，得到的结果如下：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011454410629829.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyvbqxj3j30x40cd3zb.jpg" alt="img"></a></p><p><strong>第3步：将上一步得到的”根12的右子树”和”根为13的树”进行合并</strong>，得到的结果如下：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011455050785927.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyvav1qrj30x40cdq3q.jpg" alt="img"></a></p><p><strong>第4步：将上一步得到的”根13的右子树”和”根为16的树”进行合并</strong>，得到的结果如下：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011456381256901.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyvcqy75j30x40cdaau.jpg" alt="img"></a></p><p><strong>第5步：将上一步得到的”根16的右子树”和”根为23的树”进行合并</strong>，得到的结果如下：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011457032506325.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyve6gnej30ng0emq3p.jpg" alt="img"></a></p><p>至此，已经成功的将两棵树合并成为一棵树了。接下来，对新生成的树进行调节。</p><p><strong>第6步：上一步得到的”树16的右孩子的NPL &gt; 左孩子的NPL”，因此交换左右孩子。</strong>得到的结果如下：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011457434061924.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyvcauk9j30ng0emaau.jpg" alt="img"></a></p><p><strong>第7步：上一步得到的”树12的右孩子的NPL &gt; 左孩子的NPL”，因此交换左右孩子。</strong>得到的结果如下：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011458120315745.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyvdp12aj30ng0emt9j.jpg" alt="img"></a></p><p><strong>第8步：上一步得到的”树10的右孩子的NPL &gt; 左孩子的NPL”，因此交换左右孩子。</strong>得到的结果如下：</p><p><a href="https://images0.cnblogs.com/i/497634/201404/011458431561137.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlyvb96idj30ng0ewjs6.jpg" alt="img"></a></p><p>至此，合并完毕。上面就是合并得到的左倾堆！</p><h2 id="左倾堆的基本操作的代码"><a href="#左倾堆的基本操作的代码" class="headerlink" title="左倾堆的基本操作的代码"></a>左倾堆的基本操作的代码</h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeftistHeap</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> LeftistNode&lt;T&gt; mRoot;    <span class="hljs-comment">// 根结点</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeftistNode</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        T key;                    <span class="hljs-comment">// 关键字(键值)</span><br>        <span class="hljs-keyword">int</span> npl;                <span class="hljs-comment">// 零路经长度(Null Path Length)</span><br>        LeftistNode&lt;T&gt; left;    <span class="hljs-comment">// 左孩子</span><br>        LeftistNode&lt;T&gt; right;    <span class="hljs-comment">// 右孩子</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LeftistNode</span><span class="hljs-params">(T key, LeftistNode&lt;T&gt; left, LeftistNode&lt;T&gt; right)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.npl = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"key:"</span>+key;<br>        &#125;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>LeftistNode是左倾堆对应的节点类。<br>LeftistHeap是左倾堆类，它包含了左倾堆的根节点，以及左倾堆的操作。</p><h3 id="2-合并"><a href="#2-合并" class="headerlink" title="2. 合并"></a><strong>2. 合并</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 合并"左倾堆x"和"左倾堆y"<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> LeftistNode&lt;T&gt; <span class="hljs-title">merge</span><span class="hljs-params">(LeftistNode&lt;T&gt; x, LeftistNode&lt;T&gt; y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> y;<br>    <span class="hljs-keyword">if</span>(y == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> x;<br><br>    <span class="hljs-comment">// 合并x和y时，将x作为合并后的树的根；</span><br>    <span class="hljs-comment">// 这里的操作是保证: x的key &lt; y的key</span><br>    <span class="hljs-keyword">if</span>(x.key.compareTo(y.key) &gt; <span class="hljs-number">0</span>) &#123;<br>        LeftistNode&lt;T&gt; tmp = x;<br>        x = y;<br>        y = tmp;<br>    &#125;<br><br>    <span class="hljs-comment">// 将x的右孩子和y合并，"合并后的树的根"是x的右孩子。</span><br>    x.right = merge(x.right, y);<br><br>    <span class="hljs-comment">// 如果"x的左孩子为空" 或者 "x的左孩子的npl&lt;右孩子的npl"</span><br>    <span class="hljs-comment">// 则，交换x和y</span><br>    <span class="hljs-keyword">if</span> (x.left == <span class="hljs-keyword">null</span> || x.left.npl &lt; x.right.npl) &#123;<br>        LeftistNode&lt;T&gt; tmp = x.left;<br>        x.left = x.right;<br>        x.right = tmp;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x.right == <span class="hljs-keyword">null</span> || x.left == <span class="hljs-keyword">null</span>)<br>        x.npl = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>        x.npl = (x.left.npl &gt; x.right.npl) ? (x.right.npl + <span class="hljs-number">1</span>) : (x.left.npl + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(LeftistHeap&lt;T&gt; other)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.mRoot = merge(<span class="hljs-keyword">this</span>.mRoot, other.mRoot);<br>&#125;<br></code></pre></td></tr></table></figure><p>merge(x, y)是内部接口，作用是合并x和y这两个左倾堆，并返回得到的新堆的根节点。<br>merge(other)是外部接口，作用是将other合并到当前堆中。</p><h3 id="3-添加"><a href="#3-添加" class="headerlink" title="3. 添加"></a><strong>3. 添加</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 新建结点(key)，并将其插入到左倾堆中<br> *<br> * 参数说明：<br> *     key 插入结点的键值<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T key)</span> </span>&#123;<br>    LeftistNode&lt;T&gt; node = <span class="hljs-keyword">new</span> LeftistNode&lt;T&gt;(key,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-comment">// 如果新建结点失败，则返回。</span><br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">this</span>.mRoot = merge(<span class="hljs-keyword">this</span>.mRoot, node);<br>&#125;<br></code></pre></td></tr></table></figure><p>insert(key)的作用是新建键值为key的节点，并将其加入到当前左倾堆中。</p><h3 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a><strong>4. 删除</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 删除根结点<br> * <br> * 返回值：<br> *     返回被删除的节点的键值<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mRoot == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    T key = <span class="hljs-keyword">this</span>.mRoot.key;<br>    LeftistNode&lt;T&gt; l = <span class="hljs-keyword">this</span>.mRoot.left;<br>    LeftistNode&lt;T&gt; r = <span class="hljs-keyword">this</span>.mRoot.right;<br><br>    <span class="hljs-keyword">this</span>.mRoot = <span class="hljs-keyword">null</span>;          <span class="hljs-comment">// 删除根节点</span><br>    <span class="hljs-keyword">this</span>.mRoot = merge(l, r);   <span class="hljs-comment">// 合并左右子树</span><br><br>    <span class="hljs-keyword">return</span> key;<br>&#125;<br></code></pre></td></tr></table></figure><p>remove()的作用是删除左倾堆的最小节点。</p><h2 id="左倾堆的Java实现-完整源码"><a href="#左倾堆的Java实现-完整源码" class="headerlink" title="左倾堆的Java实现(完整源码)"></a><strong>左倾堆的Java实现(完整源码)</strong></h2><h3 id="左倾堆的实现文件-LeftistHeap-java"><a href="#左倾堆的实现文件-LeftistHeap-java" class="headerlink" title="左倾堆的实现文件(LeftistHeap.java)"></a>左倾堆的实现文件(LeftistHeap.java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeftistHeap</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> LeftistNode&lt;T&gt; mRoot;    <span class="hljs-comment">// 根结点</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeftistNode</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        T key;                    <span class="hljs-comment">// 关键字(键值)</span><br>        <span class="hljs-keyword">int</span> npl;                <span class="hljs-comment">// 零路经长度(Null Path Length)</span><br>        LeftistNode&lt;T&gt; left;    <span class="hljs-comment">// 左孩子</span><br>        LeftistNode&lt;T&gt; right;    <span class="hljs-comment">// 右孩子</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LeftistNode</span><span class="hljs-params">(T key, LeftistNode&lt;T&gt; left, LeftistNode&lt;T&gt; right)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.npl = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"key:"</span>+key;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LeftistHeap</span><span class="hljs-params">()</span> </span>&#123;<br>        mRoot = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 前序遍历"左倾堆"<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(LeftistNode&lt;T&gt; heap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(heap != <span class="hljs-keyword">null</span>) &#123;<br>            System.out.print(heap.key+<span class="hljs-string">" "</span>);<br>            preOrder(heap.left);<br>            preOrder(heap.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        preOrder(mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 中序遍历"左倾堆"<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(LeftistNode&lt;T&gt; heap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(heap != <span class="hljs-keyword">null</span>) &#123;<br>            inOrder(heap.left);<br>            System.out.print(heap.key+<span class="hljs-string">" "</span>);<br>            inOrder(heap.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        inOrder(mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 后序遍历"左倾堆"<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(LeftistNode&lt;T&gt; heap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(heap != <span class="hljs-keyword">null</span>)<br>        &#123;<br>            postOrder(heap.left);<br>            postOrder(heap.right);<br>            System.out.print(heap.key+<span class="hljs-string">" "</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        postOrder(mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 合并"左倾堆x"和"左倾堆y"<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> LeftistNode&lt;T&gt; <span class="hljs-title">merge</span><span class="hljs-params">(LeftistNode&lt;T&gt; x, LeftistNode&lt;T&gt; y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> y;<br>        <span class="hljs-keyword">if</span>(y == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> x;<br><br>        <span class="hljs-comment">// 合并x和y时，将x作为合并后的树的根；</span><br>        <span class="hljs-comment">// 这里的操作是保证: x的key &lt; y的key</span><br>        <span class="hljs-keyword">if</span>(x.key.compareTo(y.key) &gt; <span class="hljs-number">0</span>) &#123;<br>            LeftistNode&lt;T&gt; tmp = x;<br>            x = y;<br>            y = tmp;<br>        &#125;<br><br>        <span class="hljs-comment">// 将x的右孩子和y合并，"合并后的树的根"是x的右孩子。</span><br>        x.right = merge(x.right, y);<br><br>        <span class="hljs-comment">// 如果"x的左孩子为空" 或者 "x的左孩子的npl&lt;右孩子的npl"</span><br>        <span class="hljs-comment">// 则，交换x和y</span><br>        <span class="hljs-keyword">if</span> (x.left == <span class="hljs-keyword">null</span> || x.left.npl &lt; x.right.npl) &#123;<br>            LeftistNode&lt;T&gt; tmp = x.left;<br>            x.left = x.right;<br>            x.right = tmp;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x.right == <span class="hljs-keyword">null</span> || x.left == <span class="hljs-keyword">null</span>)<br>            x.npl = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span><br>            x.npl = (x.left.npl &gt; x.right.npl) ? (x.right.npl + <span class="hljs-number">1</span>) : (x.left.npl + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(LeftistHeap&lt;T&gt; other)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mRoot = merge(<span class="hljs-keyword">this</span>.mRoot, other.mRoot);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 新建结点(key)，并将其插入到左倾堆中<br>     *<br>     * 参数说明：<br>     *     key 插入结点的键值<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T key)</span> </span>&#123;<br>        LeftistNode&lt;T&gt; node = <span class="hljs-keyword">new</span> LeftistNode&lt;T&gt;(key,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">// 如果新建结点失败，则返回。</span><br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">this</span>.mRoot = merge(<span class="hljs-keyword">this</span>.mRoot, node);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 删除根结点<br>     *<br>     * 返回值：<br>     *     返回被删除的节点的键值<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mRoot == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        T key = <span class="hljs-keyword">this</span>.mRoot.key;<br>        LeftistNode&lt;T&gt; l = <span class="hljs-keyword">this</span>.mRoot.left;<br>        LeftistNode&lt;T&gt; r = <span class="hljs-keyword">this</span>.mRoot.right;<br><br>        <span class="hljs-keyword">this</span>.mRoot = <span class="hljs-keyword">null</span>;          <span class="hljs-comment">// 删除根节点</span><br>        <span class="hljs-keyword">this</span>.mRoot = merge(l, r);   <span class="hljs-comment">// 合并左右子树</span><br><br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 销毁左倾堆<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(LeftistNode&lt;T&gt; heap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (heap==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span> (heap.left != <span class="hljs-keyword">null</span>)<br>            destroy(heap.left);<br>        <span class="hljs-keyword">if</span> (heap.right != <span class="hljs-keyword">null</span>)<br>            destroy(heap.right);<br><br>        heap=<span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>        destroy(mRoot);<br>        mRoot = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 打印"左倾堆"<br>     *<br>     * key        -- 节点的键值<br>     * direction  --  0，表示该节点是根节点;<br>     *               -1，表示该节点是它的父结点的左孩子;<br>     *                1，表示该节点是它的父结点的右孩子。<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(LeftistNode&lt;T&gt; heap, T key, <span class="hljs-keyword">int</span> direction)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(heap != <span class="hljs-keyword">null</span>) &#123;<br><br>            <span class="hljs-keyword">if</span>(direction==<span class="hljs-number">0</span>)    <span class="hljs-comment">// heap是根节点</span><br>                System.out.printf(<span class="hljs-string">"%2d(%d) is root\n"</span>, heap.key, heap.npl);<br>            <span class="hljs-keyword">else</span>                <span class="hljs-comment">// heap是分支节点</span><br>                System.out.printf(<span class="hljs-string">"%2d(%d) is %2d's %6s child\n"</span>, heap.key, heap.npl, key, direction==<span class="hljs-number">1</span>?<span class="hljs-string">"right"</span> : <span class="hljs-string">"left"</span>);<br><br>            print(heap.left, heap.key, -<span class="hljs-number">1</span>);<br>            print(heap.right,heap.key,  <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mRoot != <span class="hljs-keyword">null</span>)<br>            print(mRoot, mRoot.key, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="左倾堆的测试程序-LeftistHeapTest-java"><a href="#左倾堆的测试程序-LeftistHeapTest-java" class="headerlink" title="左倾堆的测试程序(LeftistHeapTest.java)"></a>左倾堆的测试程序(LeftistHeapTest.java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeftistHeapTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> a[]= &#123;<span class="hljs-number">10</span>,<span class="hljs-number">40</span>,<span class="hljs-number">24</span>,<span class="hljs-number">30</span>,<span class="hljs-number">36</span>,<span class="hljs-number">20</span>,<span class="hljs-number">12</span>,<span class="hljs-number">16</span>&#125;;<br>        <span class="hljs-keyword">int</span> b[]= &#123;<span class="hljs-number">17</span>,<span class="hljs-number">13</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>,<span class="hljs-number">19</span>,<span class="hljs-number">21</span>,<span class="hljs-number">23</span>&#125;;<br>        LeftistHeap&lt;Integer&gt; ha=<span class="hljs-keyword">new</span> LeftistHeap&lt;Integer&gt;();<br>        LeftistHeap&lt;Integer&gt; hb=<span class="hljs-keyword">new</span> LeftistHeap&lt;Integer&gt;();<br><br>        System.out.printf(<span class="hljs-string">"== 左倾堆(ha)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            ha.insert(a[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n== 左倾堆(ha)的详细信息: \n"</span>);<br>        ha.print();<br><br><br>        System.out.printf(<span class="hljs-string">"\n== 左倾堆(hb)中依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;b.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, b[i]);<br>            hb.insert(b[i]);<br>        &#125;<br>        System.out.printf(<span class="hljs-string">"\n== 左倾堆(hb)的详细信息: \n"</span>);<br>        hb.print();<br><br>        <span class="hljs-comment">// 将"左倾堆hb"合并到"左倾堆ha"中。</span><br>        ha.merge(hb);<br>        System.out.printf(<span class="hljs-string">"\n== 合并ha和hb后的详细信息: \n"</span>);<br>        ha.print();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ada">== 左倾堆(ha)中依次添加: <span class="hljs-number">10</span> <span class="hljs-number">40</span> <span class="hljs-number">24</span> <span class="hljs-number">30</span> <span class="hljs-number">36</span> <span class="hljs-number">20</span> <span class="hljs-number">12</span> <span class="hljs-number">16</span> <br>== 左倾堆(ha)的详细信息: <br><span class="hljs-number">10</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">is</span> root<br><span class="hljs-number">24</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">10</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">30</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">24</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">36</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">24</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">12</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">10</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">20</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">12</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">40</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">20</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">16</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">12</span><span class="hljs-symbol">'s</span>  right child<br><br>== 左倾堆(hb)中依次添加: <span class="hljs-number">17</span> <span class="hljs-number">13</span> <span class="hljs-number">11</span> <span class="hljs-number">15</span> <span class="hljs-number">19</span> <span class="hljs-number">21</span> <span class="hljs-number">23</span> <br>== 左倾堆(hb)的详细信息: <br><span class="hljs-number">11</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">is</span> root<br><span class="hljs-number">15</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">11</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">19</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">15</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">21</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">15</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">13</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">11</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">17</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">13</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">23</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">13</span><span class="hljs-symbol">'s</span>  right child<br><br>== 合并ha和hb后的详细信息: <br><span class="hljs-number">10</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">is</span> root<br><span class="hljs-number">11</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">10</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">15</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">11</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">19</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">15</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">21</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">15</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">12</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">11</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">13</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">12</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">17</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">13</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">16</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">13</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">23</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">16</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">20</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">12</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">40</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">20</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">24</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">10</span><span class="hljs-symbol">'s</span>  right child<br><span class="hljs-number">30</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">24</span><span class="hljs-symbol">'s</span>   left child<br><span class="hljs-number">36</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">24</span><span class="hljs-symbol">'s</span>  right child<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;左倾堆&quot;&gt;&lt;a href=&quot;#左倾堆&quot; class=&quot;headerlink&quot; title=&quot;左倾堆&quot;&gt;&lt;/a&gt;&lt;strong&gt;左倾堆&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;左倾堆(leftist tree 或 leftist heap)，又被成为左偏树、左偏堆，最左堆等
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>6.1.堆</title>
    <link href="http://yoursite.com/2022/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.1.%E5%A0%86/"/>
    <id>http://yoursite.com/2022/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.1.%E5%A0%86/</id>
    <published>2022-01-03T14:34:39.000Z</published>
    <updated>2022-02-21T00:54:33.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 Heap"></a>堆 Heap</h1><h2 id="1-堆的定义"><a href="#1-堆的定义" class="headerlink" title="1. 堆的定义"></a>1. 堆的定义</h2><p>堆是一种数据结构具有以下的特点：<br>1）<strong>完全二叉树</strong>：除了最后一层结点，其它层的结点数都达到了最大值；同时最后一层的结点都是按照从左到右依次排布。<br>2）堆中存储的值是<strong>偏序</strong>；</p><p><strong>Min-heap</strong>(小根堆，小顶堆): 父节点的值小于或等于子节点的值；<br><strong>Max-heap</strong>(大根堆，大顶堆): 父节点的值大于或等于子节点的值；</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlv796k8ej30ib0bb0to.jpg" alt="img"></p><p>堆的常用方法：</p><ul><li>构建优先队列</li><li>支持堆排序</li><li>快速找出一个集合中的最小值（或者最大值）</li></ul><p>堆常用来实现优先队列，在面试中经常考的问题都是与排序有关，比如<strong>==堆排序==</strong>、<strong>==topK问题==</strong>等。由于堆的根节点是序列中最大或者最小值，因而可以在建堆以及重建堆的过程中，筛选出数据序列中的极值，从而达到排序或者挑选topK值的目的。</p><h2 id="2-堆的存储："><a href="#2-堆的存储：" class="headerlink" title="2. 堆的存储："></a><strong>2. 堆的存储：</strong></h2><p>之前说到，堆是一种完全二叉树，但是否就意味着我们真的要用树来表示它呢？答案是否定的，因为完全二叉树有其非常卓越的性质：<strong>对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1,2n+2</strong>，因此我们可以直接用数组来表示一个堆。如第0个结点左右子结点下标分别为1和2。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlv8nck8wg30be04m74g.gif" alt="img"></p><table><thead><tr><th align="left"></th><th>堆</th><th>二叉搜索树</th></tr></thead><tbody><tr><td align="left">节点的顺序</td><td>在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。</td><td>左子节点必须比父节点小，右子节点必须必比父节点大。</td></tr><tr><td align="left">内存占用</td><td>堆仅仅使用一个数组来存储数据，且不使用指针。</td><td>普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配内存。</td></tr><tr><td align="left">平衡</td><td>堆中实际上不需要整棵树都是有序的,我们只需要满足堆属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证<strong>O(log n)</strong> 的性能。</td><td>二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到<strong>O(log n)</strong>。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树</td></tr><tr><td align="left">搜索</td><td>慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。</td><td>快</td></tr></tbody></table><h2 id="3-堆的操作"><a href="#3-堆的操作" class="headerlink" title="3. 堆的操作"></a>3. 堆的操作</h2><h3 id="insert-Push"><a href="#insert-Push" class="headerlink" title="insert(Push)"></a><strong>insert(Push)</strong></h3><p>插入一个元素：新元素被加入到heap的末尾，然后更新树以恢复堆的次序。<br>每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中——这就类似于直接插入排序中将一个数据并入到有序区间中。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlvistp98j30kv0jxab7.jpg" alt="img"></p><p><strong>最大堆的插入代码(Java语言)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 最大堆的向上调整算法(从start开始向上直到0，调整堆)<br> *<br> * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。<br> *<br> * 参数说明：<br> *     start -- 被上调节点的起始位置(一般为数组中最后一个元素的索引)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> c = start;            <span class="hljs-comment">// 当前节点(current)的位置</span><br>    <span class="hljs-keyword">int</span> p = (c-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;        <span class="hljs-comment">// 父(parent)结点的位置 </span><br>    T tmp = mHeap.get(c);        <span class="hljs-comment">// 当前节点(current)的大小</span><br><br>    <span class="hljs-keyword">while</span>(c &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> cmp = mHeap.get(p).compareTo(tmp);<br>        <span class="hljs-keyword">if</span>(cmp &gt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            mHeap.set(c, mHeap.get(p));<br>            c = p;<br>            p = (p-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;   <br>        &#125;       <br>    &#125;<br>    mHeap.set(c, tmp);<br>&#125;<br>  <br><span class="hljs-comment">/* <br> * 将data插入到二叉堆中<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T data)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> size = mHeap.size();<br><br>    mHeap.add(data);    <span class="hljs-comment">// 将"数组"插在表尾</span><br>    filterup(size);        <span class="hljs-comment">// 向上调整堆</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Removemax-Pop"><a href="#Removemax-Pop" class="headerlink" title="Removemax(Pop)"></a><strong>Removemax(Pop)</strong></h3><p>按定义，堆中每次都删除第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最大的，如果父结点比这个最小的子结点还大说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlvjvfq44j30u014bwgw.jpg" alt="img"></p><p><strong>二叉堆的删除代码(Java语言)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 最大堆的向下调整算法<br> *<br> * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。<br> *<br> * 参数说明：<br> *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)<br> *     end   -- 截至范围(一般为数组中最后一个元素的索引)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> c = start;          <span class="hljs-comment">// 当前(current)节点的位置</span><br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>*c + <span class="hljs-number">1</span>;     <span class="hljs-comment">// 左(left)孩子的位置</span><br>    T tmp = mHeap.get(c);    <span class="hljs-comment">// 当前(current)节点的大小</span><br><br>    <span class="hljs-keyword">while</span>(l &lt;= end) &#123;<br>        <span class="hljs-keyword">int</span> cmp = mHeap.get(l).compareTo(mHeap.get(l+<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// "l"是左孩子，"l+1"是右孩子</span><br>        <span class="hljs-keyword">if</span>(l &lt; end &amp;&amp; cmp&lt;<span class="hljs-number">0</span>)<br>            l++;        <span class="hljs-comment">// 左右两孩子中选择较大者，即mHeap[l+1]</span><br>        cmp = tmp.compareTo(mHeap.get(l));<br>        <span class="hljs-keyword">if</span>(cmp &gt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;        <span class="hljs-comment">//调整结束</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            mHeap.set(c, mHeap.get(l));<br>            c = l;<br>            l = <span class="hljs-number">2</span>*l + <span class="hljs-number">1</span>;   <br>        &#125;       <br>    &#125;   <br>    mHeap.set(c, tmp);<br>&#125;<br><br><span class="hljs-comment">/*<br> * 删除最大堆中的data<br> *<br> * 返回值：<br> *      0，成功<br> *     -1，失败<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">remove</span><span class="hljs-params">(T data)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果"堆"已空，则返回-1</span><br>    <span class="hljs-keyword">if</span>(mHeap.isEmpty() == <span class="hljs-keyword">true</span>)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 获取data在数组中的索引</span><br>    <span class="hljs-keyword">int</span> index = mHeap.indexOf(data);<br>    <span class="hljs-keyword">if</span> (index==-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">int</span> size = mHeap.size();<br>    mHeap.set(index, mHeap.get(size-<span class="hljs-number">1</span>));<span class="hljs-comment">// 用最后元素填补</span><br>    mHeap.remove(size - <span class="hljs-number">1</span>);                <span class="hljs-comment">// 删除最后的元素</span><br><br>    <span class="hljs-keyword">if</span> (mHeap.size() &gt; <span class="hljs-number">1</span>)<br>        filterdown(index, mHeap.size()-<span class="hljs-number">1</span>);    <span class="hljs-comment">// 从index号位置开始自上向下调整为最小堆</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="buildHeap堆化数组"><a href="#buildHeap堆化数组" class="headerlink" title="buildHeap堆化数组"></a><strong>buildHeap</strong>堆化数组</h3><p>对于叶子节点，不用调整次序，根据满二叉树的性质，叶子节点比内部节点的个数多1.所以i=n/2 -1 ，不用从n开始。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlvcx13epj30ka0ds76u.jpg" alt="img"></p><h2 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4. 堆排序"></a>4. 堆排序</h2><p>堆建好之后堆中第0个数据是堆中最大的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最大的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。</p><h2 id="5-堆的实现"><a href="#5-堆的实现" class="headerlink" title="5. 堆的实现"></a>5. 堆的实现</h2><h3 id="二叉堆-最大堆-的实现"><a href="#二叉堆-最大堆-的实现" class="headerlink" title="二叉堆(最大堆)的实现"></a>二叉堆(最大堆)的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * 二叉堆(最大堆)<br> */</span><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxHeap</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;T&gt; mHeap;    <span class="hljs-comment">// 队列(实际上是动态数组ArrayList的实例)</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxHeap</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mHeap = <span class="hljs-keyword">new</span> ArrayList&lt;T&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 最大堆的向下调整算法<br>     *<br>     * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。<br>     *<br>     * 参数说明：<br>     *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)<br>     *     end   -- 截至范围(一般为数组中最后一个元素的索引)<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = start;          <span class="hljs-comment">// 当前(current)节点的位置</span><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>*c + <span class="hljs-number">1</span>;     <span class="hljs-comment">// 左(left)孩子的位置</span><br>        T tmp = mHeap.get(c);    <span class="hljs-comment">// 当前(current)节点的大小</span><br><br>        <span class="hljs-keyword">while</span>(l &lt;= end) &#123;<br>            <span class="hljs-keyword">int</span> cmp = mHeap.get(l).compareTo(mHeap.get(l+<span class="hljs-number">1</span>));<br>            <span class="hljs-comment">// "l"是左孩子，"l+1"是右孩子</span><br>            <span class="hljs-keyword">if</span>(l &lt; end &amp;&amp; cmp&lt;<span class="hljs-number">0</span>)<br>                l++;        <span class="hljs-comment">// 左右两孩子中选择较大者，即mHeap[l+1]</span><br>            cmp = tmp.compareTo(mHeap.get(l));<br>            <span class="hljs-keyword">if</span>(cmp &gt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;        <span class="hljs-comment">//调整结束</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                mHeap.set(c, mHeap.get(l));<br>                c = l;<br>                l = <span class="hljs-number">2</span>*l + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        mHeap.set(c, tmp);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 删除最大堆中的data<br>     *<br>     * 返回值：<br>     *      0，成功<br>     *     -1，失败<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">remove</span><span class="hljs-params">(T data)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果"堆"已空，则返回-1</span><br>        <span class="hljs-keyword">if</span>(mHeap.isEmpty() == <span class="hljs-keyword">true</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 获取data在数组中的索引</span><br>        <span class="hljs-keyword">int</span> index = mHeap.indexOf(data);<br>        <span class="hljs-keyword">if</span> (index==-<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">int</span> size = mHeap.size();<br>        mHeap.set(index, mHeap.get(size-<span class="hljs-number">1</span>));<span class="hljs-comment">// 用最后元素填补</span><br>        mHeap.remove(size - <span class="hljs-number">1</span>);                <span class="hljs-comment">// 删除最后的元素</span><br><br>        <span class="hljs-keyword">if</span> (mHeap.size() &gt; <span class="hljs-number">1</span>)<br>            filterdown(index, mHeap.size()-<span class="hljs-number">1</span>);    <span class="hljs-comment">// 从index号位置开始自上向下调整为最小堆</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 最大堆的向上调整算法(从start开始向上直到0，调整堆)<br>     *<br>     * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。<br>     *<br>     * 参数说明：<br>     *     start -- 被上调节点的起始位置(一般为数组中最后一个元素的索引)<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = start;            <span class="hljs-comment">// 当前节点(current)的位置</span><br>        <span class="hljs-keyword">int</span> p = (c-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;        <span class="hljs-comment">// 父(parent)结点的位置</span><br>        T tmp = mHeap.get(c);        <span class="hljs-comment">// 当前节点(current)的大小</span><br><br>        <span class="hljs-keyword">while</span>(c &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> cmp = mHeap.get(p).compareTo(tmp);<br>            <span class="hljs-keyword">if</span>(cmp &gt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                mHeap.set(c, mHeap.get(p));<br>                c = p;<br>                p = (p-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        mHeap.set(c, tmp);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将data插入到二叉堆中<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T data)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = mHeap.size();<br><br>        mHeap.add(data);    <span class="hljs-comment">// 将"数组"插在表尾</span><br>        filterup(size);        <span class="hljs-comment">// 向上调整堆</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;mHeap.size(); i++)<br>            sb.append(mHeap.get(i) +<span class="hljs-string">" "</span>);<br><br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">60</span>, <span class="hljs-number">90</span>, <span class="hljs-number">70</span>, <span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">80</span>&#125;;<br>        MaxHeap&lt;Integer&gt; tree=<span class="hljs-keyword">new</span> MaxHeap&lt;Integer&gt;();<br><br>        System.out.printf(<span class="hljs-string">"== 依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            tree.insert(a[i]);<br>        &#125;<br><br>        System.out.printf(<span class="hljs-string">"\n== 最 大 堆: %s"</span>, tree);<br><br>        i=<span class="hljs-number">85</span>;<br>        tree.insert(i);<br>        System.out.printf(<span class="hljs-string">"\n== 添加元素: %d"</span>, i);<br>        System.out.printf(<span class="hljs-string">"\n== 最 大 堆: %s"</span>, tree);<br><br>        i=<span class="hljs-number">90</span>;<br>        tree.remove(i);<br>        System.out.printf(<span class="hljs-string">"\n== 删除元素: %d"</span>, i);<br>        System.out.printf(<span class="hljs-string">"\n== 最 大 堆: %s"</span>, tree);<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉堆-最小堆-的实现"><a href="#二叉堆-最小堆-的实现" class="headerlink" title="二叉堆(最小堆)的实现"></a>二叉堆(最小堆)的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * 二叉堆(最小堆)<br> */</span><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHeap</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;T&gt; mHeap;        <span class="hljs-comment">// 存放堆的数组</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinHeap</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mHeap = <span class="hljs-keyword">new</span> ArrayList&lt;T&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 最小堆的向下调整算法<br>     *<br>     * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。<br>     *<br>     * 参数说明：<br>     *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)<br>     *     end   -- 截至范围(一般为数组中最后一个元素的索引)<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = start;          <span class="hljs-comment">// 当前(current)节点的位置</span><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>*c + <span class="hljs-number">1</span>;     <span class="hljs-comment">// 左(left)孩子的位置</span><br>        T tmp = mHeap.get(c);    <span class="hljs-comment">// 当前(current)节点的大小</span><br><br>        <span class="hljs-keyword">while</span>(l &lt;= end) &#123;<br>            <span class="hljs-keyword">int</span> cmp = mHeap.get(l).compareTo(mHeap.get(l+<span class="hljs-number">1</span>));<br>            <span class="hljs-comment">// "l"是左孩子，"l+1"是右孩子</span><br>            <span class="hljs-keyword">if</span>(l &lt; end &amp;&amp; cmp&gt;<span class="hljs-number">0</span>)<br>                l++;        <span class="hljs-comment">// 左右两孩子中选择较小者，即mHeap[l+1]</span><br><br>            cmp = tmp.compareTo(mHeap.get(l));<br>            <span class="hljs-keyword">if</span>(cmp &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;        <span class="hljs-comment">//调整结束</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                mHeap.set(c, mHeap.get(l));<br>                c = l;<br>                l = <span class="hljs-number">2</span>*l + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        mHeap.set(c, tmp);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 最小堆的删除<br>     *<br>     * 返回值：<br>     *     成功，返回被删除的值<br>     *     失败，返回null<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">remove</span><span class="hljs-params">(T data)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果"堆"已空，则返回-1</span><br>        <span class="hljs-keyword">if</span>(mHeap.isEmpty() == <span class="hljs-keyword">true</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 获取data在数组中的索引</span><br>        <span class="hljs-keyword">int</span> index = mHeap.indexOf(data);<br>        <span class="hljs-keyword">if</span> (index==-<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">int</span> size = mHeap.size();<br>        mHeap.set(index, mHeap.get(size-<span class="hljs-number">1</span>));<span class="hljs-comment">// 用最后元素填补</span><br>        mHeap.remove(size - <span class="hljs-number">1</span>);                <span class="hljs-comment">// 删除最后的元素</span><br><br>        <span class="hljs-keyword">if</span> (mHeap.size() &gt; <span class="hljs-number">1</span>)<br>            filterdown(index, mHeap.size()-<span class="hljs-number">1</span>);    <span class="hljs-comment">// 从index号位置开始自上向下调整为最小堆</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 最小堆的向上调整算法(从start开始向上直到0，调整堆)<br>     *<br>     * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。<br>     *<br>     * 参数说明：<br>     *     start -- 被上调节点的起始位置(一般为数组中最后一个元素的索引)<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = start;            <span class="hljs-comment">// 当前节点(current)的位置</span><br>        <span class="hljs-keyword">int</span> p = (c-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;        <span class="hljs-comment">// 父(parent)结点的位置</span><br>        T tmp = mHeap.get(c);        <span class="hljs-comment">// 当前节点(current)的大小</span><br><br>        <span class="hljs-keyword">while</span>(c &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> cmp = mHeap.get(p).compareTo(tmp);<br>            <span class="hljs-keyword">if</span>(cmp &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                mHeap.set(c, mHeap.get(p));<br>                c = p;<br>                p = (p-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        mHeap.set(c, tmp);<br>    &#125;<br><br>    <span class="hljs-comment">/*<br>     * 将data插入到二叉堆中<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T data)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = mHeap.size();<br><br>        mHeap.add(data);    <span class="hljs-comment">// 将"数组"插在表尾</span><br>        filterup(size);        <span class="hljs-comment">// 向上调整堆</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;mHeap.size(); i++)<br>            sb.append(mHeap.get(i) +<span class="hljs-string">" "</span>);<br><br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">80</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">60</span>, <span class="hljs-number">90</span>, <span class="hljs-number">70</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>&#125;;<br>        MinHeap&lt;Integer&gt; tree=<span class="hljs-keyword">new</span> MinHeap&lt;Integer&gt;();<br><br>        System.out.printf(<span class="hljs-string">"== 依次添加: "</span>);<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>            System.out.printf(<span class="hljs-string">"%d "</span>, a[i]);<br>            tree.insert(a[i]);<br>        &#125;<br><br>        System.out.printf(<span class="hljs-string">"\n== 最 小 堆: %s"</span>, tree);<br><br>        i=<span class="hljs-number">15</span>;<br>        tree.insert(i);<br>        System.out.printf(<span class="hljs-string">"\n== 添加元素: %d"</span>, i);<br>        System.out.printf(<span class="hljs-string">"\n== 最 小 堆: %s"</span>, tree);<br><br>        i=<span class="hljs-number">10</span>;<br>        tree.remove(i);<br>        System.out.printf(<span class="hljs-string">"\n== 删除元素: %d"</span>, i);<br>        System.out.printf(<span class="hljs-string">"\n== 最 小 堆: %s"</span>, tree);<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆-Heap&quot;&gt;&lt;a href=&quot;#堆-Heap&quot; class=&quot;headerlink&quot; title=&quot;堆 Heap&quot;&gt;&lt;/a&gt;堆 Heap&lt;/h1&gt;&lt;h2 id=&quot;1-堆的定义&quot;&gt;&lt;a href=&quot;#1-堆的定义&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>5.3 树与森林</title>
    <link href="http://yoursite.com/2021/12/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3.%E6%A0%91%E4%B8%8E%E6%A3%AE/"/>
    <id>http://yoursite.com/2021/12/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3.%E6%A0%91%E4%B8%8E%E6%A3%AE/</id>
    <published>2021-12-31T14:33:39.000Z</published>
    <updated>2022-02-21T00:54:33.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、树的存储结构"><a href="#一、树的存储结构" class="headerlink" title="一、树的存储结构"></a>一、树的存储结构</h1><h2 id="1、-双亲表示法"><a href="#1、-双亲表示法" class="headerlink" title="1、 双亲表示法"></a>1、 双亲表示法</h2><p>树中每个结点都有唯一一个双亲结点，根据这一特性，可以用一组连续的存储空间（一维数组）存储树中的各个结点，数组中每个元素都表示树中的一个结点，数组元素为结构体类型，这个结构体类型由结点本身的数据和结点的双亲在数组中的序号组成。</p><p><img src="https:////upload-images.jianshu.io/upload_images/5315181-5f05cb59e3ceacc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/378/format/webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXNODE<span class="hljs-meta-string">&lt;树中结点个数&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    elemtype data;<br>    <span class="hljs-keyword">int</span> parent;<br>&#125; NodeType;<br>NodeType t[MAXNODE];<br></code></pre></td></tr></table></figure><p><strong>优点</strong>：找双亲和根方便。</p><p><strong>缺点</strong>：1. 求某结点的孩子结点，需要遍历整个数组。2.不能反映各兄弟之间的关系，因此找到某结点的兄弟也很困难。</p><h2 id="2、孩子表示法"><a href="#2、孩子表示法" class="headerlink" title="2、孩子表示法"></a>2、孩子表示法</h2><p>按如下图所示的形式存储。主体是一个与结点个数一样大小的一维数组，数组的每个元素有两个域，一个域用于存放结点数据，另一个用于存放指针，该指针指向由该结点孩子组成的单链表的首位置。单链表的结构也由两个域组成，一个存放孩子结点在一维数组中的序号，另一个为指针域，指向下一个孩子。</p><p><img src="https:////upload-images.jianshu.io/upload_images/5315181-c2ad5ee1997f1809.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXNODE<span class="hljs-meta-string">&lt;树中结点个数&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ChildNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> childcode;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ChildNode</span> *<span class="hljs-title">nextChild</span>;</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    elemtype data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ChildNode</span> *<span class="hljs-title">firstChild</span>;</span><br>&#125; NodeType;<br>NodeType t[MAXNODE];<br></code></pre></td></tr></table></figure><p><strong>优点</strong>：找孩子方便</p><p><strong>缺点</strong>：找双亲困难</p><h2 id="3、双亲孩子表示法"><a href="#3、双亲孩子表示法" class="headerlink" title="3、双亲孩子表示法"></a>3、双亲孩子表示法</h2><p>双亲孩子表示法是将双亲表示法和孩子表示法结合起来的方法。如下图所示，将各节点的孩子结点组成单链表，用一维数组顺序存储树的结点，数组元素包括结点本身的数据，该结点的孩子结点链表的头指针，存储该结点的双亲在数组中的序号。</p><p><img src="https:////upload-images.jianshu.io/upload_images/5315181-f01d9deac9d55fd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><h2 id="4、孩子兄弟表示法"><a href="#4、孩子兄弟表示法" class="headerlink" title="4、孩子兄弟表示法"></a>4、孩子兄弟表示法</h2><p> 这种方法的结构体包含：每个结点的数据，指向该结点的<strong>第一个孩子结点的指针</strong>和<strong>指向下一个兄弟结点的指针</strong>。</p><p><img src="https:////upload-images.jianshu.io/upload_images/5315181-1b86fbd5a76f394a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>elemtype data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> *<span class="hljs-title">lChild</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> *<span class="hljs-title">nextSibling</span>;</span><br>&#125; NodeType, *CSTree;<br></code></pre></td></tr></table></figure><h1 id="二、树转换为二叉树"><a href="#二、树转换为二叉树" class="headerlink" title="二、树转换为二叉树"></a>二、树转换为二叉树</h1><p><img src="https:////upload-images.jianshu.io/upload_images/5315181-3b56e662e77390d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/363/format/webp" alt="img"></p><p>第一步：在树中所有兄弟结点间加一条连线</p><p><img src="https:////upload-images.jianshu.io/upload_images/5315181-518bbef5d129d8e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/347/format/webp" alt="img"></p><p> 第二步：对每个结点，除了保留与最左边孩子的连线外，去掉该结点其他孩子的连线</p><p><img src="https:////upload-images.jianshu.io/upload_images/5315181-9cf88930f13b14f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/355/format/webp" alt="img"></p><p>第四步：调整位置</p><p><img src="https:////upload-images.jianshu.io/upload_images/5315181-89637de192d80da9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><h1 id="三、森林转换为二叉树"><a href="#三、森林转换为二叉树" class="headerlink" title="三、森林转换为二叉树"></a>三、森林转换为二叉树</h1><p><img src="https:////upload-images.jianshu.io/upload_images/5315181-20b7efd5cf8d09cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/385/format/webp" alt="img"></p><p> 第一步：先将森林中的每棵树变为二叉树</p><p><img src="https:////upload-images.jianshu.io/upload_images/5315181-5d094393adbc8bab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/391/format/webp" alt="img"></p><p> 第二步：将各二叉树的根节点从左到右连在一起，形成二叉树</p><p><img src="https:////upload-images.jianshu.io/upload_images/5315181-43d15e9ab194c802.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/377/format/webp" alt="img"></p><p> 第三步：调整位置</p><p><img src="https:////upload-images.jianshu.io/upload_images/5315181-347edaa6104dc8cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><h1 id="四、二叉树转换为树、森林"><a href="#四、二叉树转换为树、森林" class="headerlink" title="四、二叉树转换为树、森林"></a>四、二叉树转换为树、森林</h1><p><img src="https:////upload-images.jianshu.io/upload_images/5315181-f0382761d824496c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/337/format/webp" alt="img"></p><p> 第一步：若结点X是双亲Y的左孩子，则把X的右孩子，右孩子的右孩子…都和 Y用线连起来。</p><p><img src="https:////upload-images.jianshu.io/upload_images/5315181-f1bdd51479476ba4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/319/format/webp" alt="img"></p><p> 第二步：去掉所有双亲到右孩子间的连线</p><p><img src="https:////upload-images.jianshu.io/upload_images/5315181-4bb19664dd18a38a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/306/format/webp" alt="img"></p><p> 第三步：调整位置</p><p><img src="https:////upload-images.jianshu.io/upload_images/5315181-95b30bb90bb187d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><h1 id="五、树的遍历"><a href="#五、树的遍历" class="headerlink" title="五、树的遍历"></a>五、树的遍历</h1><p> 树的遍历分为两种：先根遍历和后根遍历<br> <img src="https:////upload-images.jianshu.io/upload_images/5315181-e9f090a14bfa2bd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/226/format/webp" alt="img"></p><p> 1、先根遍历<br> A.  访问根节点<br> B.  按照从左到右的顺序先根遍历根节点的每一棵子树<br> 上图按照先根遍历，结果为：A B E F C D G</p><p> 2、  后根遍历<br> A.  按照从左到右的顺序后根遍历根节点的每一棵子树<br> B.  最后访问根节点<br> 上图按照后根遍历，结果为：E F B C G D A</p><h1 id="六、森林的遍历"><a href="#六、森林的遍历" class="headerlink" title="六、森林的遍历"></a>六、森林的遍历</h1><p> 森林的遍历分为两种：前序遍历和中序遍历<br> <img src="https:////upload-images.jianshu.io/upload_images/5315181-d1af3a34986a0e8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/382/format/webp" alt="img"></p><p> 1、  前序遍历<br> A.  访问森林中第一棵树的根节点<br> B.  前序遍历第一棵树的根节点的子树<br> C.  前序遍历去掉第一棵树后剩余的森林<br> 上图按照前序遍历，结果为：A B C D E F G H J I K</p><p>2、  中序遍历<br> A.  中序遍历第一棵树的根节点的子树<br> B.  访问森林中第一棵树的根结点<br> C.  中序遍历去掉第一棵树剩余的森林<br> 上图按照中序遍历，结果为：B A D E F C J H K I G</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、树的存储结构&quot;&gt;&lt;a href=&quot;#一、树的存储结构&quot; class=&quot;headerlink&quot; title=&quot;一、树的存储结构&quot;&gt;&lt;/a&gt;一、树的存储结构&lt;/h1&gt;&lt;h2 id=&quot;1、-双亲表示法&quot;&gt;&lt;a href=&quot;#1、-双亲表示法&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>5.2.3.最优二叉树--哈夫曼树</title>
    <link href="http://yoursite.com/2021/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2.3.%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91--%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <id>http://yoursite.com/2021/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2.3.%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91--%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</id>
    <published>2021-12-30T14:33:39.000Z</published>
    <updated>2022-02-21T00:54:33.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a><strong>哈夫曼树</strong></h1><h2 id="1-定义与概念"><a href="#1-定义与概念" class="headerlink" title="1.定义与概念"></a>1.定义与概念</h2><p>Huffman Tree，中文名是哈夫曼树或霍夫曼树，它是最优二叉树。</p><p><strong>定义</strong>：给定n个权值作为n个叶子结点，构造一棵二叉树，若树的==带权路径长度达到最小==，则这棵树被称为哈夫曼树。 这个定义里面涉及到了几个陌生的概念，下面就是一颗哈夫曼树，我们来看图解答。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/tree/huffman/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlntgjw8bj308f06v0ss.jpg" alt="img"></a></p><p>(01) 路径和路径长度</p><blockquote><p><strong>定义</strong>：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。<br><strong>例子</strong>：100和80的路径长度是1，50和30的路径长度是2，20和10的路径长度是3。</p></blockquote><p>(02) 结点的权及带权路径长度</p><blockquote><p><strong>定义</strong>：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。<br><strong>例子</strong>：节点20的路径长度是3，它的带权路径长度= 路径长度 * 权 = 3 * 20 = 60。</p></blockquote><p>(03) 树的带权路径长度</p><blockquote><p><strong>定义</strong>：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。<br><strong>例子</strong>：示例中，树的WPL= 1X100 + 2X50 + 3X20 + 3X10 = 100 + 100 + 60 + 30 = 290。</p></blockquote><p>比较下面两棵树</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/tree/huffman/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlo1e4b8nj30hd06v74m.jpg" alt="img"></a></p><p>上面的两棵树都是以{10, 20, 50, 100}为叶子节点的树。</p><blockquote><p>左边的树WPL=2x10 + 2x20 + 2x50 + 2x100 = 360<br>右边的树WPL=290</p></blockquote><p>左边的树WPL &gt; 右边的树的WPL。你也可以计算除上面两种示例之外的情况，但实际上右边的树就是{10,20,50,100}对应的哈夫曼树。至此，应该堆哈夫曼树的概念有了一定的了解了，下面看看如何去构造一棵哈夫曼树。</p><h2 id="2-如何构造哈夫曼树"><a href="#2-如何构造哈夫曼树" class="headerlink" title="2.如何构造哈夫曼树"></a>2.如何构造哈夫曼树</h2><p>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，哈夫曼树的构造规则为：</p><blockquote><p><strong>1</strong>. 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；<br><strong>2</strong>. 在森林中选出根结点的权值最小的两棵树进行合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；<br><strong>3</strong>. 从森林中删除选取的两棵树，并将新树加入森林；<br><strong>4</strong>. 重复(02)、(03)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。</p></blockquote><p>以{5,6,7,8,15}为例，来构造一棵哈夫曼树。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/tree/huffman/03.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlo3erlp0j30eq0nnt9w.jpg" alt="img"></a></p><p><strong>第1步</strong>：创建森林，森林包括5棵树，这5棵树的权值分别是5,6,7,8,15。<br><strong>第2步</strong>：在森林中，选择根节点权值最小的两棵树(5和6)来进行合并，将它们作为一颗新树的左右孩子(谁左谁右无关紧要，这里，我们选择较小的作为左孩子)，并且新树的权值是左右孩子的权值之和。即，新树的权值是11。 然后，将”树5”和”树6”从森林中删除，并将新的树(树11)添加到森林中。<br><strong>第3步</strong>：在森林中，选择根节点权值最小的两棵树(7和8)来进行合并。得到的新树的权值是15。 然后，将”树7”和”树8”从森林中删除，并将新的树(树15)添加到森林中。<br><strong>第4步</strong>：在森林中，选择根节点权值最小的两棵树(11和15)来进行合并。得到的新树的权值是26。 然后，将”树11”和”树15”从森林中删除，并将新的树(树26)添加到森林中。<br><strong>第5步</strong>：在森林中，选择根节点权值最小的两棵树(15和26)来进行合并。得到的新树的权值是41。 然后，将”树15”和”树26”从森林中删除，并将新的树(树41)添加到森林中。<br>此时，森林中只有一棵树(树41)。这棵树就是我们需要的哈夫曼树！</p><h2 id="3-构造哈夫曼树代码"><a href="#3-构造哈夫曼树代码" class="headerlink" title="3.构造哈夫曼树代码"></a>3.构造哈夫曼树代码</h2><p>哈夫曼树的重点是如何构造哈夫曼树。本文构造哈夫曼时，用到了以前介绍过的”(二叉堆)最小堆”。下面对哈夫曼树进行讲解。</p><ol><li>HuffmanNode是哈夫曼树的节点类。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * Huffman节点类(Huffman.java的辅助类)<br> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuffmanNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>, <span class="hljs-title">Cloneable</span> </span>&#123;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> key;<span class="hljs-comment">// 权值</span><br><span class="hljs-keyword">protected</span> HuffmanNode left;<span class="hljs-comment">// 左孩子</span><br><span class="hljs-keyword">protected</span> HuffmanNode right;<span class="hljs-comment">// 右孩子</span><br><span class="hljs-keyword">protected</span> HuffmanNode parent;<span class="hljs-comment">// 父结点</span><br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">HuffmanNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, HuffmanNode left, HuffmanNode right, HuffmanNode parent)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.key = key;<br><span class="hljs-keyword">this</span>.left = left;<br><span class="hljs-keyword">this</span>.right = right;<br><span class="hljs-keyword">this</span>.parent = parent;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>Object obj=<span class="hljs-keyword">null</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>obj = (HuffmanNode)<span class="hljs-keyword">super</span>.clone();<span class="hljs-comment">//Object 中的clone()识别出你要复制的是哪一个对象。    </span><br>&#125; <span class="hljs-keyword">catch</span>(CloneNotSupportedException e) &#123;<br>System.out.println(e.toString());<br>&#125;<br><br><span class="hljs-keyword">return</span> obj;    <br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.key - ((HuffmanNode)obj).key;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>Huffman是哈夫曼树对应的类，它包含了哈夫曼树的根节点和哈夫曼树的相关操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * Huffman树<br> */</span><br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Huffman</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> HuffmanNode mRoot;<span class="hljs-comment">// 根结点</span><br><br><span class="hljs-comment">/* <br> * 创建Huffman树<br> *<br> * @param 权值数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Huffman</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[])</span> </span>&#123;<br>        HuffmanNode parent = <span class="hljs-keyword">null</span>;<br>MinHeap heap;<br><br><span class="hljs-comment">// 建立数组a对应的最小堆</span><br>heap = <span class="hljs-keyword">new</span> MinHeap(a);<br> <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length-<span class="hljs-number">1</span>; i++) &#123;   <br>        HuffmanNode left = heap.dumpFromMinimum();  <span class="hljs-comment">// 最小节点是左孩子</span><br>        HuffmanNode right = heap.dumpFromMinimum(); <span class="hljs-comment">// 其次才是右孩子</span><br> <br><span class="hljs-comment">// 新建parent节点，左右孩子分别是left/right；</span><br><span class="hljs-comment">// parent的大小是左右孩子之和</span><br>parent = <span class="hljs-keyword">new</span> HuffmanNode(left.key+right.key, left, right, <span class="hljs-keyword">null</span>);<br>left.parent = parent;<br>right.parent = parent;<br><br><span class="hljs-comment">// 将parent节点数据拷贝到"最小堆"中</span><br>heap.insert(parent);<br>&#125;<br><br>mRoot = parent;<br><br><span class="hljs-comment">// 销毁最小堆</span><br>heap.destroy();<br>&#125;<br><br><span class="hljs-comment">/*<br> * 前序遍历"Huffman树"<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(HuffmanNode tree)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(tree != <span class="hljs-keyword">null</span>) &#123;<br>System.out.print(tree.key+<span class="hljs-string">" "</span>);<br>preOrder(tree.left);<br>preOrder(tree.right);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> </span>&#123;<br>preOrder(mRoot);<br>&#125;<br><br><span class="hljs-comment">/*<br> * 中序遍历"Huffman树"<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(HuffmanNode tree)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(tree != <span class="hljs-keyword">null</span>) &#123;<br>inOrder(tree.left);<br>System.out.print(tree.key+<span class="hljs-string">" "</span>);<br>inOrder(tree.right);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">()</span> </span>&#123;<br>inOrder(mRoot);<br>&#125;<br><br><br><span class="hljs-comment">/*<br> * 后序遍历"Huffman树"<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(HuffmanNode tree)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(tree != <span class="hljs-keyword">null</span>)<br>&#123;<br>postOrder(tree.left);<br>postOrder(tree.right);<br>System.out.print(tree.key+<span class="hljs-string">" "</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">()</span> </span>&#123;<br>postOrder(mRoot);<br>&#125;<br><br><span class="hljs-comment">/*<br> * 销毁Huffman树<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(HuffmanNode tree)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (tree==<span class="hljs-keyword">null</span>)<br><span class="hljs-keyword">return</span> ;<br><br><span class="hljs-keyword">if</span> (tree.left != <span class="hljs-keyword">null</span>)<br>destroy(tree.left);<br><span class="hljs-keyword">if</span> (tree.right != <span class="hljs-keyword">null</span>)<br>destroy(tree.right);<br><br>tree=<span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>destroy(mRoot);<br>mRoot = <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-comment">/*<br> * 打印"Huffman树"<br> *<br> * key        -- 节点的键值 <br> * direction  --  0，表示该节点是根节点;<br> *               -1，表示该节点是它的父结点的左孩子;<br> *                1，表示该节点是它的父结点的右孩子。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(HuffmanNode tree, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> direction)</span> </span>&#123;<br><br><span class="hljs-keyword">if</span>(tree != <span class="hljs-keyword">null</span>) &#123;<br><br><span class="hljs-keyword">if</span>(direction==<span class="hljs-number">0</span>)<span class="hljs-comment">// tree是根节点</span><br>System.out.printf(<span class="hljs-string">"%2d is root\n"</span>, tree.key);<br><span class="hljs-keyword">else</span><span class="hljs-comment">// tree是分支节点</span><br>System.out.printf(<span class="hljs-string">"%2d is %2d's %6s child\n"</span>, tree.key, key, direction==<span class="hljs-number">1</span>?<span class="hljs-string">"right"</span> : <span class="hljs-string">"left"</span>);<br><br>print(tree.left, tree.key, -<span class="hljs-number">1</span>);<br>print(tree.right,tree.key,  <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (mRoot != <span class="hljs-keyword">null</span>)<br>print(mRoot, mRoot.key, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>首先创建最小堆，然后进入for循环。</p><p>每次循环时：</p><blockquote><p>(01) 首先，将最小堆中的最小节点拷贝一份并赋值给left，然后重塑最小堆(将最小节点和后面的节点交换位置，接着将”交换位置后的最小节点”之前的全部元素重新构造成最小堆)；<br>(02) 接着，再将最小堆中的最小节点拷贝一份并将其赋值right，然后再次重塑最小堆；<br>(03) 然后，新建节点parent，并将它作为left和right的父节点；<br>(04) 接着，将parent的数据复制给最小堆中的指定节点。</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * 最小堆(Huffman.java的辅助类)<br> */</span><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHeap</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> List&lt;HuffmanNode&gt; mHeap;<span class="hljs-comment">// 存放堆的数组</span><br><br><span class="hljs-comment">/* <br> * 创建最小堆<br> *<br> * 参数说明：<br> *     a -- 数据所在的数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MinHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[])</span> </span>&#123;<br>mHeap = <span class="hljs-keyword">new</span> ArrayList&lt;HuffmanNode&gt;();<br><span class="hljs-comment">// 初始化数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++) &#123;<br>    HuffmanNode node = <span class="hljs-keyword">new</span> HuffmanNode(a[i], <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>mHeap.add(node);<br>&#125;<br><br><span class="hljs-comment">// 从(size/2-1) --&gt; 0逐次遍历。遍历之后，得到的数组实际上是一个最小堆。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>filterdown(i, a.length-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/* <br> * 最小堆的向下调整算法<br> *<br> * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。<br> *<br> * 参数说明：<br> *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)<br> *     end   -- 截至范围(一般为数组中最后一个元素的索引)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br><span class="hljs-keyword">int</span> c = start;  <span class="hljs-comment">// 当前(current)节点的位置</span><br><span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>*c + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左(left)孩子的位置</span><br>HuffmanNode tmp = mHeap.get(c);<span class="hljs-comment">// 当前(current)节点</span><br><br><span class="hljs-keyword">while</span>(l &lt;= end) &#123;<br><span class="hljs-comment">// "l"是左孩子，"l+1"是右孩子</span><br><span class="hljs-keyword">if</span>(l &lt; end &amp;&amp; (mHeap.get(l).compareTo(mHeap.get(l+<span class="hljs-number">1</span>))&gt;<span class="hljs-number">0</span>))<br>l++;<span class="hljs-comment">// 左右两孩子中选择较小者，即mHeap[l+1]</span><br><br><span class="hljs-keyword">int</span> cmp = tmp.compareTo(mHeap.get(l));<br><span class="hljs-keyword">if</span>(cmp &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//调整结束</span><br><span class="hljs-keyword">else</span> &#123;<br>mHeap.set(c, mHeap.get(l));<br>c = l;<br>l = <span class="hljs-number">2</span>*l + <span class="hljs-number">1</span>;   <br>&#125;       <br>&#125;   <br>mHeap.set(c, tmp);<br>&#125;<br><br><span class="hljs-comment">/*<br> * 最小堆的向上调整算法(从start开始向上直到0，调整堆)<br> *<br> * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。<br> *<br> * 参数说明：<br> *     start -- 被上调节点的起始位置(一般为数组中最后一个元素的索引)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br><span class="hljs-keyword">int</span> c = start;<span class="hljs-comment">// 当前节点(current)的位置</span><br><span class="hljs-keyword">int</span> p = (c-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-comment">// 父(parent)结点的位置 </span><br>HuffmanNode tmp = mHeap.get(c);<span class="hljs-comment">// 当前(current)节点</span><br><br><span class="hljs-keyword">while</span>(c &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">int</span> cmp = mHeap.get(p).compareTo(tmp);<br><span class="hljs-keyword">if</span>(cmp &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">else</span> &#123;<br>mHeap.set(c, mHeap.get(p));<br>c = p;<br>p = (p-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;   <br>&#125;       <br>&#125;<br>mHeap.set(c, tmp);<br>&#125; <br> <br><span class="hljs-comment">/* <br> * 将node插入到二叉堆中<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(HuffmanNode node)</span> </span>&#123;<br><span class="hljs-keyword">int</span> size = mHeap.size();<br><br>mHeap.add(node);<span class="hljs-comment">// 将"数组"插在表尾</span><br>filterup(size);<span class="hljs-comment">// 向上调整堆</span><br>&#125;<br><br><span class="hljs-comment">/*<br> * 交换两个HuffmanNode节点的全部数据<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swapNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>HuffmanNode tmp = mHeap.get(i);<br>mHeap.set(i, mHeap.get(j));<br>mHeap.set(j, tmp);<br>&#125;<br><br><span class="hljs-comment">/* <br> * 新建一个节点，并将最小堆中最小节点的数据复制给该节点。<br> * 然后除最小节点之外的数据重新构造成最小堆。<br> *<br> * 返回值：<br> *     失败返回null。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> HuffmanNode <span class="hljs-title">dumpFromMinimum</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> size = mHeap.size();<br><br><span class="hljs-comment">// 如果"堆"已空，则返回</span><br><span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br><span class="hljs-comment">// 将"最小节点"克隆一份，将克隆得到的对象赋值给node</span><br>HuffmanNode node = (HuffmanNode)mHeap.get(<span class="hljs-number">0</span>).clone();<br><br><span class="hljs-comment">// 交换"最小节点"和"最后一个节点"</span><br>mHeap.set(<span class="hljs-number">0</span>, mHeap.get(size-<span class="hljs-number">1</span>));<br><span class="hljs-comment">// 删除最后的元素</span><br>mHeap.remove(size-<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">if</span> (mHeap.size() &gt; <span class="hljs-number">1</span>)<br>filterdown(<span class="hljs-number">0</span>, mHeap.size()-<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">// 销毁最小堆</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>mHeap.clear();<br>mHeap = <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * Huffman树的测试程序<br> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuffmanTest</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a[]= &#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">15</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i;<br>Huffman tree;<br><br>System.out.print(<span class="hljs-string">"== 添加数组: "</span>);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;a.length; i++) <br>System.out.print(a[i]+<span class="hljs-string">" "</span>);<br><br><span class="hljs-comment">// 创建数组a对应的Huffman树</span><br>tree = <span class="hljs-keyword">new</span> Huffman(a);<br><br>System.out.print(<span class="hljs-string">"\n== 前序遍历: "</span>);<br>tree.preOrder();<br><br>System.out.print(<span class="hljs-string">"\n== 中序遍历: "</span>);<br>tree.inOrder();<br><br>System.out.print(<span class="hljs-string">"\n== 后序遍历: "</span>);<br>tree.postOrder();<br>System.out.println();<br><br>System.out.println(<span class="hljs-string">"== 树的详细信息: "</span>);<br>tree.print();<br><br><span class="hljs-comment">// 销毁二叉树</span><br>tree.destroy();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈夫曼树&quot;&gt;&lt;a href=&quot;#哈夫曼树&quot; class=&quot;headerlink&quot; title=&quot;哈夫曼树&quot;&gt;&lt;/a&gt;&lt;strong&gt;哈夫曼树&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-定义与概念&quot;&gt;&lt;a href=&quot;#1-定义与概念&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>5.2.2.红黑树</title>
    <link href="http://yoursite.com/2021/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2.2.%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://yoursite.com/2021/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2.2.%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2021-12-19T14:32:39.000Z</published>
    <updated>2022-02-21T00:54:33.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>红黑树是平衡二叉树的一种，它保证在最坏情况下基本动态集合操作的==<strong>事件复杂度为O(log n)</strong>==。时间复杂度证明：<a href="https://www.cnblogs.com/skywang12345/p/3245399.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3245399.html</a></p><p>(1) 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入<strong>最多只需要三次旋转</strong>就能达到平衡，实现起来也更为简单。</p><p>(2) 平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。</p><p>红黑树和平衡二叉树区别如下：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlhlzai1oj315h0u043d.jpg" alt="image-20211120120927328"></p><h2 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2 特性"></a>1.2 特性</h2><p>==<strong>红黑树具有五个特性：</strong>==</p><ol><li>==<strong>每个结点要么是红的要么是黑的。</strong>==</li><li>==<strong>根结点是黑的。</strong>==</li><li>==<strong>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。</strong>==</li><li>==<strong>如果一个结点是红的，那么它的两个儿子都是黑的。</strong>==</li><li>==<strong>对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。</strong>==</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlhl6dzddj31i90u0q5x.jpg" alt="image-20211120120840570"></p><p>红黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只要求达到部分平衡。这是一种折中的方案，大大提高了结点删除和插入的效率。C++中的STL就常用到红黑树作为底层的数据结构。</p><p>红黑树应用：例如，Java集合中的<a href="http://www.cnblogs.com/skywang12345/p/3311268.html" target="_blank" rel="noopener">TreeSet</a>和<a href="http://www.cnblogs.com/skywang12345/p/3310928.html" target="_blank" rel="noopener">TreeMap</a>，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p><h2 id="1-3-红黑树的基本操作"><a href="#1-3-红黑树的基本操作" class="headerlink" title="1.3 红黑树的基本操作"></a>1.3 红黑树的基本操作</h2><h3 id="1-3-1-添加"><a href="#1-3-1-添加" class="headerlink" title="1.3.1 添加"></a>1.3.1 添加</h3><p>将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下：</p><p><strong>第一步: 将红黑树当作一颗二叉查找树，将节点插入。</strong><br>红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。<br>好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！</p><p><strong>第二步：将插入的节点着色为”红色”。</strong><br>为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：<br>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。<br>将插入的节点着色为红色，不会违背”特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。</p><p><strong>第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。</strong><br>第二步中，将插入节点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？<br>对于”特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。<br>对于”特性(2)”，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。<br>对于”特性(3)”，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。<br>对于”特性(4)”，是有可能违背的！<br>那接下来，想办法使之”满足特性(4)”，就可以将树重新构造成红黑树了。</p><ol><li><strong>添加操作的伪代码《算法导论》</strong></li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">RB-INSERT(T, z)  <br><span class="hljs-number">01</span>  y ← nil[T]                        <span class="hljs-comment">// 新建节点“y”，将y设为空节点。</span><br><span class="hljs-number">02</span>  x ← root[T]                       <span class="hljs-comment">// 设“红黑树T”的根节点为“x”</span><br><span class="hljs-number">03</span>  <span class="hljs-keyword">while</span> x ≠ nil[T]                  <span class="hljs-comment">// 找出要插入的节点“z”在二叉树T中的位置“y”</span><br><span class="hljs-number">04</span>      <span class="hljs-keyword">do</span> y ← x                      <br><span class="hljs-number">05</span>         <span class="hljs-keyword">if</span> key[z] &lt; key[x]  <br><span class="hljs-number">06</span>            then x ← left[x]  <br><span class="hljs-number">07</span>            <span class="hljs-keyword">else</span> x ← right[x]  <br><span class="hljs-number">08</span>  p[z] ← y                          <span class="hljs-comment">// 设置 “z的父亲” 为 “y”</span><br><span class="hljs-number">09</span>  <span class="hljs-keyword">if</span> y = nil[T]                     <br><span class="hljs-number">10</span>     then root[T] ← z               <span class="hljs-comment">// 情况1：若y是空节点，则将z设为根</span><br><span class="hljs-number">11</span>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> key[z] &lt; key[y]        <br><span class="hljs-number">12</span>             then left[y] ← z       <span class="hljs-comment">// 情况2：若“z所包含的值” &lt; “y所包含的值”，则将z设为“y的左孩子”</span><br><span class="hljs-number">13</span>             <span class="hljs-keyword">else</span> right[y] ← z      <span class="hljs-comment">// 情况3：(“z所包含的值” &gt;= “y所包含的值”)将z设为“y的右孩子” </span><br><span class="hljs-number">14</span>  left[z] ← nil[T]                  <span class="hljs-comment">// z的左孩子设为空</span><br><span class="hljs-number">15</span>  right[z] ← nil[T]                 <span class="hljs-comment">// z的右孩子设为空。至此，已经完成将“节点z插入到二叉树”中了。</span><br><span class="hljs-number">16</span>  color[z] ← RED                    <span class="hljs-comment">// 将z着色为“红色”</span><br><span class="hljs-number">17</span>  RB-INSERT-FIXUP(T, z)             <span class="hljs-comment">// 通过RB-INSERT-FIXUP对红黑树的节点进行颜色修改以及旋转，让树T仍然是一颗红黑树</span><br></code></pre></td></tr></table></figure><p>结合伪代码以及为代码上面的说明，先理解RB-INSERT。理解了RB-INSERT之后，我们接着对 RB-INSERT-FIXUP的伪代码进行说明。</p><ol start="2"><li><strong>添加修正操作的伪代码《算法导论》</strong></li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">RB-INSERT-FIXUP(T, z)<br><span class="hljs-number">01</span> <span class="hljs-keyword">while</span> color[p[z]] = RED                                                  <span class="hljs-comment">// 若“当前节点(z)的父节点是红色”，则进行以下处理。</span><br><span class="hljs-number">02</span>     <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> p[z] = left[p[p[z]]]                                           <span class="hljs-comment">// 若“z的父节点”是“z的祖父节点的左孩子”，则进行以下处理。</span><br><span class="hljs-number">03</span>           then y ← right[p[p[z]]]                                        <span class="hljs-comment">// 将y设置为“z的叔叔节点(z的祖父节点的右孩子)”</span><br><span class="hljs-number">04</span>                <span class="hljs-keyword">if</span> color[y] = RED                                         <span class="hljs-comment">// Case 1条件：叔叔是红色</span><br><span class="hljs-number">05</span>                   then color[p[z]] ← BLACK                    ▹ Case <span class="hljs-number">1</span>   <span class="hljs-comment">//  (01) 将“父节点”设为黑色。</span><br><span class="hljs-number">06</span>                        color[y] ← BLACK                       ▹ Case <span class="hljs-number">1</span>   <span class="hljs-comment">//  (02) 将“叔叔节点”设为黑色。</span><br><span class="hljs-number">07</span>                        color[p[p[z]]] ← RED                   ▹ Case <span class="hljs-number">1</span>   <span class="hljs-comment">//  (03) 将“祖父节点”设为“红色”。</span><br><span class="hljs-number">08</span>                        z ← p[p[z]]                            ▹ Case <span class="hljs-number">1</span>   <span class="hljs-comment">//  (04) 将“祖父节点”设为“当前节点”(红色节点)</span><br><span class="hljs-number">09</span>                   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> z = right[p[z]]                                <span class="hljs-comment">// Case 2条件：叔叔是黑色，且当前节点是右孩子</span><br><span class="hljs-number">10</span>                           then z ← p[z]                       ▹ Case <span class="hljs-number">2</span>   <span class="hljs-comment">//  (01) 将“父节点”作为“新的当前节点”。</span><br><span class="hljs-number">11</span>                                LEFT-ROTATE(T, z)              ▹ Case <span class="hljs-number">2</span>   <span class="hljs-comment">//  (02) 以“新的当前节点”为支点进行左旋。</span><br><span class="hljs-number">12</span>                           color[p[z]] ← BLACK                 ▹ Case <span class="hljs-number">3</span>   <span class="hljs-comment">// Case 3条件：叔叔是黑色，且当前节点是左孩子。(01) 将“父节点”设为“黑色”。</span><br><span class="hljs-number">13</span>                           color[p[p[z]]] ← RED                ▹ Case <span class="hljs-number">3</span>   <span class="hljs-comment">//  (02) 将“祖父节点”设为“红色”。</span><br><span class="hljs-number">14</span>                           RIGHT-ROTATE(T, p[p[z]])            ▹ Case <span class="hljs-number">3</span>   <span class="hljs-comment">//  (03) 以“祖父节点”为支点进行右旋。</span><br><span class="hljs-number">15</span>        <span class="hljs-keyword">else</span> (same as then clause with <span class="hljs-string">"right"</span> <span class="hljs-keyword">and</span> <span class="hljs-string">"left"</span> exchanged)      <span class="hljs-comment">// 若“z的父节点”是“z的祖父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。</span><br><span class="hljs-number">16</span> color[root[T]] ← BLACK<br></code></pre></td></tr></table></figure><p>根据被插入节点的父节点的情况，可以将”当节点z被着色为红色节点，并插入二叉树”划分为三种情况来处理。</p><h4 id="1-3-1-1-情况说明：被插入的节点是根节点。"><a href="#1-3-1-1-情况说明：被插入的节点是根节点。" class="headerlink" title="1.3.1.1. 情况说明：被插入的节点是根节点。"></a>1.3.1.1. <strong>情况说明：被插入的节点是根节点。</strong></h4><p>  处理方法：直接把此节点涂为黑色。</p><h4 id="1-3-1-2-情况说明：被插入的节点的父节点是黑色。"><a href="#1-3-1-2-情况说明：被插入的节点的父节点是黑色。" class="headerlink" title="1.3.1.2. 情况说明：被插入的节点的父节点是黑色。"></a>1.3.1.2. <strong>情况说明：被插入的节点的父节点是黑色。</strong></h4><p>  处理方法：什么也不需要做。节点被插入后，仍然是红黑树。</p><h4 id="1-3-1-3-情况说明：被插入的节点的父节点是红色。"><a href="#1-3-1-3-情况说明：被插入的节点的父节点是红色。" class="headerlink" title="1.3.1.3.情况说明：被插入的节点的父节点是红色。"></a>1.3.1.3.<strong>情况说明：被插入的节点的父节点是红色。</strong></h4><p>  处理方法：那么，该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据”叔叔节点的情况”，将这种情况进一步划分为3种情况(Case)。</p><table><thead><tr><th></th><th><strong>现象说明</strong></th><th><strong>处理策略</strong></th></tr></thead><tbody><tr><td>Case 1</td><td>当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</td><td>(01) 将“父节点”设为黑色。 (02) 将“叔叔节点”设为黑色。 (03) 将“祖父节点”设为“红色”。 (04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作, 即迭代。</td></tr><tr><td>Case 2</td><td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</td><td>(01) 将“父节点”作为“新的当前节点”。 (02) 以“新的当前节点”为支点进行左旋。</td></tr><tr><td>Case 3</td><td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</td><td>(01) 将“父节点”设为“黑色”。 (02) 将“祖父节点”设为“红色”。 (03) 以“祖父节点”为支点进行右旋。</td></tr></tbody></table><p>上面三种情况(Case)处理问题的核心思路都是：<strong>==将红色的节点移到根节点；然后，将根节点设为黑色==</strong>。下面对它们详细进行介绍。</p><h5 id="Case-1-叔叔是红色"><a href="#Case-1-叔叔是红色" class="headerlink" title="(Case 1)叔叔是红色"></a>(Case 1)叔叔是红色</h5><h6 id="Case1-1-现象说明"><a href="#Case1-1-现象说明" class="headerlink" title="Case1.1 现象说明"></a>Case<strong>1.1 现象说明</strong></h6><p>当前节点(即，被插入节点)的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。(插入35)</p><h6 id="Case1-2-处理策略"><a href="#Case1-2-处理策略" class="headerlink" title="Case1.2 处理策略"></a>Case<strong>1.2 处理策略</strong></h6><p>(01) 将“父节点”设为黑色。<br>(02) 将“叔叔节点”设为黑色。<br>(03) 将“祖父节点”设为“红色”。<br>(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</p><p>  <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>  “当前节点”和“父节点”都是红色，违背“特性(4)”。所以，将“父节点”设置“黑色”以解决这个问题。<br>  但是，将“父节点”由“红色”变成“黑色”之后，违背了“特性(5)”：因为，包含“父节点”的分支的黑色节点的总数增加了1。  解决这个问题的办法是：将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”。关于这里，说明几点：第一，为什么“祖父节点”之前是黑色？这个应该很容易想明白，因为在变换操作之前，该树是红黑树，“父节点”是红色，那么“祖父节点”一定是黑色。 第二，为什么将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；能解决“包含‘父节点’的分支的黑色节点的总数增加了1”的问题。这个道理也很简单。“包含‘父节点’的分支的黑色节点的总数增加了1” 同时也意味着 “包含‘祖父节点’的分支的黑色节点的总数增加了1”，既然这样，我们通过将“祖父节点”由“黑色”变成“红色”以解决“包含‘祖父节点’的分支的黑色节点的总数增加了1”的问题； 但是，这样处理之后又会引起另一个问题“包含‘叔叔’节点的分支的黑色节点的总数减少了1”，现在我们已知“叔叔节点”是“红色”，将“叔叔节点”设为“黑色”就能解决这个问题。 所以，将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；就解决了该问题。<br>  按照上面的步骤处理之后：当前节点、父节点、叔叔节点之间都不会违背红黑树特性，但祖父节点却不一定。若此时，祖父节点是根节点，直接将祖父节点设为“黑色”，那就完全解决这个问题了；若祖父节点不是根节点，那我们需要将“祖父节点”设为“新的当前节点”，接着对“新的当前节点”进行分析。</p><h6 id="Case1-3-示意图"><a href="#Case1-3-示意图" class="headerlink" title="Case1.3 示意图"></a>Case<strong>1.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251759273578917.jpg" target="_blank" rel="noopener"><strong><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljntndr2j318o0eitak.jpg" alt="img"></strong></a></p><h5 id="Case-2-叔叔是黑色，且当前节点是右孩子"><a href="#Case-2-叔叔是黑色，且当前节点是右孩子" class="headerlink" title="(Case 2)叔叔是黑色，且当前节点是右孩子"></a>(Case 2)叔叔是黑色，且当前节点是右孩子</h5><h6 id="Case2-1-现象说明"><a href="#Case2-1-现象说明" class="headerlink" title="Case2.1 现象说明"></a>Case<strong>2.1 现象说明</strong></h6><p>当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子。(插入70，图有错误)</p><h6 id="Case2-2-处理策略"><a href="#Case2-2-处理策略" class="headerlink" title="Case2.2 处理策略"></a>Case<strong>2.2 处理策略</strong></h6><p>(01) 将“父节点”作为“新的当前节点”。<br>(02) 以“新的当前节点”为支点进行左旋。</p><p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   首先，将“父节点”作为“新的当前节点”；接着，以“新的当前节点”为支点进行左旋。 为了便于理解，我们先说明第(02)步，再说明第(01)步；为了便于说明，我们设置“父节点”的代号为F(Father)，“当前节点”的代号为S(Son)。<br>为什么要“以F为支点进行左旋”呢？根据已知条件可知：S是F的右孩子。而之前我们说过，我们处理红黑树的核心思想：将红色的节点移到根节点；然后，将根节点设为黑色。既然是“将红色的节点移到根节点”，那就是说要不断的将破坏红黑树特性的红色节点上移(即向根方向移动)。 而S又是一个右孩子，因此，我们可以通过“左旋”来将S上移！<br>   按照上面的步骤(以F为支点进行左旋)处理之后：若S变成了根节点，那么直接将其设为“黑色”，就完全解决问题了；若S不是根节点，那我们需要执行步骤(01)，即“将F设为‘新的当前节点’”。那为什么不继续以S为新的当前节点继续处理，而需要以F为新的当前节点来进行处理呢？这是因为“左旋”之后，F变成了S的“子节点”，即S变成了F的父节点；而我们处理问题的时候，需要从下至上(由叶到根)方向进行处理；也就是说，必须先解决“孩子”的问题，再解决“父亲”的问题；所以，我们执行步骤(01)：将“父节点”作为“新的当前节点”。</p><h6 id="Case2-3-示意图"><a href="#Case2-3-示意图" class="headerlink" title="Case2.3 示意图"></a>Case<strong>2.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251801031546918.jpg" target="_blank" rel="noopener"><strong><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljo7qeefj31a90e30uk.jpg" alt="img"></strong></a></p><h5 id="Case-3-叔叔是黑色，且当前节点是左孩子"><a href="#Case-3-叔叔是黑色，且当前节点是左孩子" class="headerlink" title="(Case 3)叔叔是黑色，且当前节点是左孩子"></a>(Case 3)叔叔是黑色，且当前节点是左孩子</h5><h6 id="Case3-1-现象说明"><a href="#Case3-1-现象说明" class="headerlink" title="Case3.1 现象说明"></a><strong>Case3.1 现象说明</strong></h6><p>当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子。(插入40)</p><h6 id="Case3-2-处理策略"><a href="#Case3-2-处理策略" class="headerlink" title="Case3.2 处理策略"></a>Case<strong>3.2 处理策略</strong></h6><p>(01) 将“父节点”设为“黑色”。<br>(02) 将“祖父节点”设为“红色”。<br>(03) 以“祖父节点”为支点进行右旋。</p><p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“叔叔节点”为U(Uncle)，“父节点”为F(Father)，祖父节点为G(Grand-Father)。<br>   S和F都是红色，违背了红黑树的“特性(4)”，我们可以将F由“红色”变为“黑色”，就解决了“违背‘特性(4)’”的问题；但却引起了其它问题：违背特性(5)，因为将F由红色改为黑色之后，所有经过F的分支的黑色节点的个数增加了1。那我们如何解决“所有经过F的分支的黑色节点的个数增加了1”的问题呢？ 我们可以通过“将G由黑色变成红色”，同时“以G为支点进行右旋”来解决。</p><h6 id="Case3-3-示意图"><a href="#Case3-3-示意图" class="headerlink" title="Case3.3 示意图"></a>Case<strong>3.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201404/170945094945387.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljofpukej31a80e2dhp.jpg" alt="img"></a></p><p>提示：上面的进行Case 3处理之后，再将节点”120”当作当前节点，就变成了Case 2的情况。</p><h3 id="1-3-2-删除"><a href="#1-3-2-删除" class="headerlink" title="1.3.2 删除"></a>1.3.2 删除</h3><p>将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：</p><p><strong>第一步：将红黑树当作一颗二叉查找树，将节点删除。</strong><br>    这和”删除常规二叉查找树中删除节点的方法是一样的”。分3种情况：<br>    ① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。<br>    ② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。<br>    ③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了，下面就考虑后继节点。 在”被删除节点”有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然”的后继节点”不可能双子都非空，就意味着”该节点的后继节点”要么没有儿子，要么只有一个儿子。若没有儿子，则按”情况① “进行处理；若只有一个儿子，则按”情况② “进行处理。</p><p><strong>第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</strong><br>    因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p><p><strong>删除操作的伪代码《算法导论》</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">RB</span>-<span class="hljs-type">DELETE</span>(<span class="hljs-type">T</span>, z)<br><span class="hljs-number">01</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">left</span>[z] = <span class="hljs-literal">nil</span>[<span class="hljs-type">T</span>] or <span class="hljs-keyword">right</span>[z] = <span class="hljs-literal">nil</span>[<span class="hljs-type">T</span>]         <br><span class="hljs-number">02</span>    then y ← z                                  <span class="hljs-comment">// 若“z的左孩子” 或 “z的右孩子”为空，则将“z”赋值给 “y”；</span><br><span class="hljs-number">03</span>    <span class="hljs-keyword">else</span> y ← <span class="hljs-type">TREE</span>-<span class="hljs-type">SUCCESSOR</span>(z)                  <span class="hljs-comment">// 否则，将“z的后继节点”赋值给 “y”。</span><br><span class="hljs-number">04</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">left</span>[y] ≠ <span class="hljs-literal">nil</span>[<span class="hljs-type">T</span>]<br><span class="hljs-number">05</span>    then x ← <span class="hljs-keyword">left</span>[y]                            <span class="hljs-comment">// 若“y的左孩子” 不为空，则将“y的左孩子” 赋值给 “x”；</span><br><span class="hljs-number">06</span>    <span class="hljs-keyword">else</span> x ← <span class="hljs-keyword">right</span>[y]                           <span class="hljs-comment">// 否则，“y的右孩子” 赋值给 “x”。</span><br><span class="hljs-number">07</span> p[x] ← p[y]                                    <span class="hljs-comment">// 将“y的父节点” 设置为 “x的父节点”</span><br><span class="hljs-number">08</span> <span class="hljs-keyword">if</span> p[y] = <span class="hljs-literal">nil</span>[<span class="hljs-type">T</span>]                               <br><span class="hljs-number">09</span>    then root[<span class="hljs-type">T</span>] ← x                            <span class="hljs-comment">// 情况1：若“y的父节点” 为空，则设置“x” 为 “根节点”。</span><br><span class="hljs-number">10</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> y = <span class="hljs-keyword">left</span>[p[y]]                    <br><span class="hljs-number">11</span>            then <span class="hljs-keyword">left</span>[p[y]] ← x                 <span class="hljs-comment">// 情况2：若“y是它父节点的左孩子”，则设置“x” 为 “y的父节点的左孩子”</span><br><span class="hljs-number">12</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">right</span>[p[y]] ← x                <span class="hljs-comment">// 情况3：若“y是它父节点的右孩子”，则设置“x” 为 “y的父节点的右孩子”</span><br><span class="hljs-number">13</span> <span class="hljs-keyword">if</span> y ≠ z                                    <br><span class="hljs-number">14</span>    then key[z] ← key[y]                        <span class="hljs-comment">// 若“y的值” 赋值给 “z”。注意：这里只拷贝z的值给y，而没有拷贝z的颜色！！！</span><br><span class="hljs-number">15</span>         copy y's satellite data into z         <br><span class="hljs-number">16</span> <span class="hljs-keyword">if</span> color[y] = <span class="hljs-type">BLACK</span>                            <br><span class="hljs-number">17</span>    then <span class="hljs-type">RB</span>-<span class="hljs-type">DELETE</span>-<span class="hljs-type">FIXUP</span>(<span class="hljs-type">T</span>, x)                  <span class="hljs-comment">// 若“y为黑节点”，则调用</span><br><span class="hljs-number">18</span> <span class="hljs-keyword">return</span> y<br></code></pre></td></tr></table></figure><p>结合伪代码以及为代码上面的说明，先理解RB-DELETE。理解了RB-DELETE之后，接着对 RB-DELETE-FIXUP的伪代码进行说明</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">RB-DELETE-FIXUP(T, x)<br><span class="hljs-number">01</span> <span class="hljs-keyword">while</span> x ≠ root[T] <span class="hljs-keyword">and</span> color[x] = BLACK  <br><span class="hljs-number">02</span>     <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> x = left[p[x]]      <br><span class="hljs-number">03</span>           then w ← right[p[x]]                                             <span class="hljs-comment">// 若 “x”是“它父节点的左孩子”，则设置 “w”为“x的叔叔”(即x为它父节点的右孩子)                                          </span><br><span class="hljs-number">04</span>                <span class="hljs-keyword">if</span> color[w] = RED                                           <span class="hljs-comment">// Case 1: x是“黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</span><br><span class="hljs-number">05</span>                   then color[w] ← BLACK                        ▹  Case <span class="hljs-number">1</span>   <span class="hljs-comment">//   (01) 将x的兄弟节点设为“黑色”。</span><br><span class="hljs-number">06</span>                        color[p[x]] ← RED                       ▹  Case <span class="hljs-number">1</span>   <span class="hljs-comment">//   (02) 将x的父节点设为“红色”。</span><br><span class="hljs-number">07</span>                        LEFT-ROTATE(T, p[x])                    ▹  Case <span class="hljs-number">1</span>   <span class="hljs-comment">//   (03) 对x的父节点进行左旋。</span><br><span class="hljs-number">08</span>                        w ← right[p[x]]                         ▹  Case <span class="hljs-number">1</span>   <span class="hljs-comment">//   (04) 左旋后，重新设置x的兄弟节点。</span><br><span class="hljs-number">09</span>                <span class="hljs-keyword">if</span> color[left[w]] = BLACK <span class="hljs-keyword">and</span> color[right[w]] = BLACK       <span class="hljs-comment">// Case 2: x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</span><br><span class="hljs-number">10</span>                   then color[w] ← RED                          ▹  Case <span class="hljs-number">2</span>   <span class="hljs-comment">//   (01) 将x的兄弟节点设为“红色”。</span><br><span class="hljs-number">11</span>                        x ←  p[x]                               ▹  Case <span class="hljs-number">2</span>   <span class="hljs-comment">//   (02) 设置“x的父节点”为“新的x节点”。</span><br><span class="hljs-number">12</span>                   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> color[right[w]] = BLACK                          <span class="hljs-comment">// Case 3: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</span><br><span class="hljs-number">13</span>                           then color[left[w]] ← BLACK          ▹  Case <span class="hljs-number">3</span>   <span class="hljs-comment">//   (01) 将x兄弟节点的左孩子设为“黑色”。</span><br><span class="hljs-number">14</span>                                color[w] ← RED                  ▹  Case <span class="hljs-number">3</span>   <span class="hljs-comment">//   (02) 将x兄弟节点设为“红色”。</span><br><span class="hljs-number">15</span>                                RIGHT-ROTATE(T, w)              ▹  Case <span class="hljs-number">3</span>   <span class="hljs-comment">//   (03) 对x的兄弟节点进行右旋。</span><br><span class="hljs-number">16</span>                                w ← right[p[x]]                 ▹  Case <span class="hljs-number">3</span>   <span class="hljs-comment">//   (04) 右旋后，重新设置x的兄弟节点。</span><br><span class="hljs-number">17</span>                         color[w] ← color[p[x]]                 ▹  Case <span class="hljs-number">4</span>   <span class="hljs-comment">// Case 4: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的。(01) 将x父节点颜色 赋值给 x的兄弟节点。</span><br><span class="hljs-number">18</span>                         color[p[x]] ← BLACK                    ▹  Case <span class="hljs-number">4</span>   <span class="hljs-comment">//   (02) 将x父节点设为“黑色”。</span><br><span class="hljs-number">19</span>                         color[right[w]] ← BLACK                ▹  Case <span class="hljs-number">4</span>   <span class="hljs-comment">//   (03) 将x兄弟节点的右子节设为“黑色”。</span><br><span class="hljs-number">20</span>                         LEFT-ROTATE(T, p[x])                   ▹  Case <span class="hljs-number">4</span>   <span class="hljs-comment">//   (04) 对x的父节点进行左旋。</span><br><span class="hljs-number">21</span>                         x ← root[T]                            ▹  Case <span class="hljs-number">4</span>   <span class="hljs-comment">//   (05) 设置“x”为“根节点”。</span><br><span class="hljs-number">22</span>        <span class="hljs-keyword">else</span> (same as then clause with <span class="hljs-string">"right"</span> <span class="hljs-keyword">and</span> <span class="hljs-string">"left"</span> exchanged)        <span class="hljs-comment">// 若 “x”是“它父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。</span><br><span class="hljs-number">23</span> color[x] ← BLACK<br></code></pre></td></tr></table></figure><p>下面对删除函数进行分析。在分析之前，我们再次温习一下红黑树的几个特性：<br>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p><p>前面我们将”删除红黑树中的节点”大致分为两步，在第一步中”将红黑树当作一颗二叉查找树，将节点删除”后，可能违反”特性(2)、(4)、(5)”三个特性。第二步需要解决上面的三个问题，进而保持红黑树的全部特性。<br>为了便于分析，我们假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。为什么呢？<br>通过RB-DELETE算法，我们知道：删除节点y之后，x占据了原来节点y的位置。 既然删除y(y是黑色)，意味着减少一个黑色节点；那么，再在该位置上增加一个黑色即可。这样，当我们假设”x包含一个额外的黑色”，就正好弥补了”删除y所丢失的黑色节点”，也就不会违反”特性(5)”。 因此，假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。<br>现在，x不仅包含它原本的颜色属性，x还包含一个额外的黑色。即x的颜色属性是”红+黑”或”黑+黑”，它违反了”特性(1)”。</p><p>现在，我们面临的问题，由解决”违反了特性(2)、(4)、(5)三个特性”转换成了”解决违反特性(1)、(2)、(4)三个特性”。RB-DELETE-FIXUP需要做的就是通过算法恢复红黑树的特性(1)、(2)、(4)。RB-DELETE-FIXUP的思想是：将x所包含的额外的黑色不断沿树上移(向根方向移动)，直到出现下面的姿态：<br>a) x指向一个”红+黑”节点。此时，将x设为一个”黑”节点即可。<br>b) x指向根。此时，将x设为一个”黑”节点即可。<br>c) 非前面两种姿态。</p><p>将上面的姿态，可以概括为3种情况。</p><h4 id="1-3-2-1-情况说明：x是“红-黑”节点。"><a href="#1-3-2-1-情况说明：x是“红-黑”节点。" class="headerlink" title="1.3.2.1.情况说明：x是“红+黑”节点。"></a>1.3.2.1.情况说明：x是“红+黑”节点。</h4><p>  处理方法：直接把x设为黑色，结束。此时红黑树性质全部恢复。</p><h4 id="1-3-2-2-情况说明：x是“黑-黑”节点，且x是根。"><a href="#1-3-2-2-情况说明：x是“黑-黑”节点，且x是根。" class="headerlink" title="1.3.2.2.情况说明：x是“黑+黑”节点，且x是根。"></a>1.3.2.2.情况说明：x是“黑+黑”节点，且x是根。</h4><p>  处理方法：什么都不做，结束。此时红黑树性质全部恢复。</p><h4 id="1-3-2-3-情况说明：x是“黑-黑”节点，且x不是根。"><a href="#1-3-2-3-情况说明：x是“黑-黑”节点，且x不是根。" class="headerlink" title="1.3.2.3.情况说明：x是“黑+黑”节点，且x不是根。"></a>1.3.2.3.情况说明：x是“黑+黑”节点，且x不是根。</h4><p>  处理方法：这种情况又可以划分为4种子情况。这4种子情况如下表所示：</p><table><thead><tr><th></th><th><strong>现象说明</strong></th><th><strong>处理策略</strong></th></tr></thead><tbody><tr><td><strong>Case 1</strong></td><td>x是”黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</td><td>(01) 将x的兄弟节点设为“黑色”。 (02) 将x的父节点设为“红色”。 (03) 对x的父节点进行左旋。 (04) 左旋后，重新设置x的兄弟节点。</td></tr><tr><td><strong>Case 2</strong></td><td>x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</td><td>(01) 将x的兄弟节点设为“红色”。 (02) 设置“x的父节点”为“新的x节点”。</td></tr><tr><td><strong>Case 3</strong></td><td>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</td><td>(01) 将x兄弟节点的左孩子设为“黑色”。 (02) 将x兄弟节点设为“红色”。 (03) 对x的兄弟节点进行右旋。 (04) 右旋后，重新设置x的兄弟节点。</td></tr><tr><td><strong>Case 4</strong></td><td>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</td><td>(01) 将x父节点颜色 赋值给 x的兄弟节点。 (02) 将x父节点设为“黑色”。 (03) 将x兄弟节点的右子节设为“黑色”。 (04) 对x的父节点进行左旋。 (05) 设置“x”为“根节点”。</td></tr></tbody></table><h5 id="Case-1-x是”黑-黑”节点，x的兄弟节点是红色"><a href="#Case-1-x是”黑-黑”节点，x的兄弟节点是红色" class="headerlink" title="(Case 1)x是”黑+黑”节点，x的兄弟节点是红色"></a><strong>(Case 1)x是”黑+黑”节点，x的兄弟节点是红色</strong></h5><h6 id="Case1-1-现象说明-1"><a href="#Case1-1-现象说明-1" class="headerlink" title="Case1.1 现象说明"></a><strong>Case1.1 现象说明</strong></h6><p>x是”黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</p><h6 id="Case1-2-处理策略-1"><a href="#Case1-2-处理策略-1" class="headerlink" title="Case1.2 处理策略"></a><strong>Case1.2 处理策略</strong></h6><p>(01) 将x的兄弟节点设为“黑色”。<br>(02) 将x的父节点设为“红色”。<br>(03) 对x的父节点进行左旋。<br>(04) 左旋后，重新设置x的兄弟节点。</p><p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   这样做的目的是将“Case 1”转换为“Case 2”、“Case 3”或“Case 4”，从而进行进一步的处理。对x的父节点进行左旋；左旋后，为了保持红黑树特性，就需要在左旋前“将x的兄弟节点设为黑色”，同时“将x的父节点设为红色”；左旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p><h6 id="Case1-3-示意图-1"><a href="#Case1-3-示意图-1" class="headerlink" title="Case1.3 示意图"></a><strong>Case1.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251813539515702.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljurarvkj30wm08s3z7.jpg" alt="img"></a></p><h5 id="Case-2-x是”黑-黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色"><a href="#Case-2-x是”黑-黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色" class="headerlink" title="(Case 2) x是”黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色"></a><strong>(Case 2) x是”黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色</strong></h5><h6 id="2-1-现象说明"><a href="#2-1-现象说明" class="headerlink" title="2.1 现象说明"></a><strong>2.1 现象说明</strong></h6><p>x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</p><h6 id="2-2-处理策略"><a href="#2-2-处理策略" class="headerlink" title="2.2 处理策略"></a><strong>2.2 处理策略</strong></h6><p>(01) 将x的兄弟节点设为“红色”。<br>(02) 设置“x的父节点”为“新的x节点”。</p><p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   这个情况的处理思想：是将“x中多余的一个黑色属性上移(往根方向移动)”。 x是“黑+黑”节点，我们将x由“黑+黑”节点 变成 “黑”节点，多余的一个“黑”属性移到x的父节点中，即x的父节点多出了一个黑属性(若x的父节点原先是“黑”，则此时变成了“黑+黑”；若x的父节点原先时“红”，则此时变成了“红+黑”)。 此时，需要注意的是：所有经过x的分支中黑节点个数没变化；但是，所有经过x的兄弟节点的分支中黑色节点的个数增加了1(因为x的父节点多了一个黑色属性)！为了解决这个问题，我们需要将“所有经过x的兄弟节点的分支中黑色节点的个数减1”即可，那么就可以通过“将x的兄弟节点由黑色变成红色”来实现。<br>   经过上面的步骤(将x的兄弟节点设为红色)，多余的一个颜色属性(黑色)已经跑到x的父节点中。我们需要将x的父节点设为“新的x节点”进行处理。若“新的x节点”是“黑+红”，直接将“新的x节点”设为黑色，即可完全解决该问题；若“新的x节点”是“黑+黑”，则需要对“新的x节点”进行进一步处理。</p><h6 id="2-3-示意图"><a href="#2-3-示意图" class="headerlink" title="2.3 示意图"></a><strong>2.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251814572322069.jpg" target="_blank" rel="noopener"><strong><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljvz73cnj30wc08z3z9.jpg" alt="img"></strong></a></p><h5 id="Case-3-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的"><a href="#Case-3-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的" class="headerlink" title="(Case 3)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的"></a><strong>(Case 3)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的</strong></h5><h6 id="3-1-现象说明"><a href="#3-1-现象说明" class="headerlink" title="3.1 现象说明"></a><strong>3.1 现象说明</strong></h6><p>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</p><h6 id="3-2-处理策略"><a href="#3-2-处理策略" class="headerlink" title="3.2 处理策略"></a><strong>3.2 处理策略</strong></h6><p>(01) 将x兄弟节点的左孩子设为“黑色”。<br>(02) 将x兄弟节点设为“红色”。<br>(03) 对x的兄弟节点进行右旋。<br>(04) 右旋后，重新设置x的兄弟节点。</p><p>​    <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>​    我们处理“Case 3”的目的是为了将“Case 3”进行转换，转换成“Case 4”,从而进行进一步的处理。转换的方式是对x的兄弟节点进行右旋；为了保证右旋后，它仍然是红黑树，就需要在右旋前“将x的兄弟节点的左孩子设为黑色”，同时“将x的兄弟节点设为红色”；右旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p><h6 id="3-3-示意图"><a href="#3-3-示意图" class="headerlink" title="3.3 示意图"></a><strong>3.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251815496235531.jpg" target="_blank" rel="noopener"><strong><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljwiee5lj30y60ba3zb.jpg" alt="img"></strong></a></p><h5 id="Case-4-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色"><a href="#Case-4-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色" class="headerlink" title="(Case 4)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色"></a><strong>(Case 4)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色</strong></h5><h6 id="4-1-现象说明"><a href="#4-1-现象说明" class="headerlink" title="4.1 现象说明"></a><strong>4.1 现象说明</strong></h6><p>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</p><h6 id="4-2-处理策略"><a href="#4-2-处理策略" class="headerlink" title="4.2 处理策略"></a><strong>4.2 处理策略</strong></h6><p>(01) 将x父节点颜色 赋值给 x的兄弟节点。<br>(02) 将x父节点设为“黑色”。<br>(03) 将x兄弟节点的右子节设为“黑色”。<br>(04) 对x的父节点进行左旋。<br>(05) 设置“x”为“根节点”。</p><p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   我们处理“Case 4”的目的是：去掉x中额外的黑色，将x变成单独的黑色。处理的方式是“：进行颜色修改，然后对x的父节点进行左旋。下面，我们来分析是如何实现的。<br>   为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“兄弟节点的左孩子”为BLS(Brother’s Left Son)，“兄弟节点的右孩子”为BRS(Brother’s Right Son)，“父节点”为F(Father)。<br>   我们要对F进行左旋。但在左旋前，我们需要调换F和B的颜色，并设置BRS为黑色。为什么需要这里处理呢？因为左旋后，F和BLS是父子关系，而我们已知BL是红色，如果F是红色，则违背了“特性(4)”；为了解决这一问题，我们将“F设置为黑色”。 但是，F设置为黑色之后，为了保证满足“特性(5)”，即为了保证左旋之后：<br>   第一，“同时经过根节点和S的分支的黑色节点个数不变”。<br>       若满足“第一”，只需要S丢弃它多余的颜色即可。因为S的颜色是“黑+黑”，而左旋后“同时经过根节点和S的分支的黑色节点个数”增加了1；现在，只需将S由“黑+黑”变成单独的“黑”节点，即可满足“第一”。<br>   第二，“同时经过根节点和BLS的分支的黑色节点数不变”。<br>       若满足“第二”，只需要将“F的原始颜色”赋值给B即可。之前，我们已经将“F设置为黑色”(即，将B的颜色”黑色”，赋值给了F)。至此，我们算是调换了F和B的颜色。<br>   第三，“同时经过根节点和BRS的分支的黑色节点数不变”。<br>       在“第二”已经满足的情况下，若要满足“第三”，只需要将BRS设置为“黑色”即可。<br>经过，上面的处理之后。红黑树的特性全部得到的满足！接着，我们将x设为根节点，就可以跳出while循环(参考伪代码)；即完成了全部处理。</p><p>至此，我们就完成了Case 4的处理。理解Case 4的核心，是了解如何“去掉当前节点额外的黑色”。</p><h6 id="4-3-示意图"><a href="#4-3-示意图" class="headerlink" title="4.3 示意图"></a><strong>4.3 示意图</strong></h6><p><a href="https://images0.cnblogs.com/i/497634/201403/251817189983393.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwljxatt04j30v108z3z9.jpg" alt="img"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;红黑树&quot;&gt;&lt;a href=&quot;#红黑树&quot; class=&quot;headerlink&quot; title=&quot;红黑树&quot;&gt;&lt;/a&gt;红黑树&lt;/h1&gt;&lt;h2 id=&quot;1-1-定义&quot;&gt;&lt;a href=&quot;#1-1-定义&quot; class=&quot;headerlink&quot; title=&quot;1.1 定义&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>5.2.1.平衡二叉树(AVL)</title>
    <link href="http://yoursite.com/2021/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2.1.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(AVL)/"/>
    <id>http://yoursite.com/2021/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2.1.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(AVL)/</id>
    <published>2021-12-18T14:31:39.000Z</published>
    <updated>2022-02-21T00:54:33.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><strong>平衡二叉树</strong></h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>平衡二叉树又被称为AVL树，它是一棵<strong>二叉排序树</strong>，且具有以下性质：==它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。==所以它也被称为高度平衡树，<strong>n个结点的AVL树最大深度约1.44log2n</strong>。<strong>查找、插入和删除在平均和最坏情况下都是O（log n）</strong>。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p><p><strong>平衡因子</strong>：左子树高度 - 右子树高度。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlh02ck25j30gq06zgls.jpg" alt="img"></p><p>平衡二叉树的产生是为了解决二叉排序树在插入时发生线性排列的现象。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。</p><p><strong>节点定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLTree</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> AVLTreeNode&lt;T&gt; mRoot;    <span class="hljs-comment">// 根结点</span><br><br>    <span class="hljs-comment">// AVL树的节点(内部类)</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLTreeNode</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        T key;                <span class="hljs-comment">// 关键字(键值)</span><br>        <span class="hljs-keyword">int</span> height;         <span class="hljs-comment">// 高度</span><br>        AVLTreeNode&lt;T&gt; left;    <span class="hljs-comment">// 左孩子</span><br>        AVLTreeNode&lt;T&gt; right;    <span class="hljs-comment">// 右孩子</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AVLTreeNode</span><span class="hljs-params">(T key, AVLTreeNode&lt;T&gt; left, AVLTreeNode&lt;T&gt; right)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>            <span class="hljs-keyword">this</span>.height = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlh71su62j31o90u0acp.jpg" alt="image-20211120115506072"></p><p>平衡二叉树的出现能够解决上述问题，但是在构造平衡二叉树时，却需要采用不同的调整方式，使得二叉树在插入数据后保持平衡。主要的四种调整方式有LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。这里先给大家介绍下简单的单旋转操作，左旋和右旋。LR和RL本质上只是LL和RR的组合。</p><blockquote><p>在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于1时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用<strong>单旋转</strong>进行平衡化，如果这三个结点位于一条折线上，则采用<strong>双旋转</strong>进行平衡化。</p></blockquote><h3 id="左旋："><a href="#左旋：" class="headerlink" title="左旋："></a>左旋：</h3><p>S为当前需要左旋的结点，E为当前结点的父节点。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlhb2zor7j314s0gydgz.jpg" alt="image-20211120115858619"></p><p>左旋的操作可以用一句话简单表示：将当前结点S的左孩子旋转为当前结点父结点E的右孩子，同时将父结点E旋转为当前结点S的左孩子。</p><h3 id="右旋："><a href="#右旋：" class="headerlink" title="右旋："></a>右旋：</h3><p>S为当前需要左旋的结点，E为当前结点的父节点。右单旋是左单旋的镜像旋转。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlhfi56hej321y0tutbt.jpg" alt="image-20211120120313358"></p><p>将当前结点S的左孩子E的右孩子旋转为当前结点S的左孩子，同时将当前结点S旋转为左孩子E的右孩子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;平衡二叉树&quot;&gt;&lt;a href=&quot;#平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树&quot;&gt;&lt;/a&gt;&lt;strong&gt;平衡二叉树&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-1-定义&quot;&gt;&lt;a href=&quot;#1-1-定义&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
</feed>
