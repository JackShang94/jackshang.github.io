<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shang Liang Liang&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-02-21T00:38:22.516Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Shang Liang Liang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础</title>
    <link href="http://yoursite.com/2021/12/21/Java%E9%9D%A2%E8%AF%95/1.0%20Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2021/12/21/Java%E9%9D%A2%E8%AF%95/1.0%20Java%E5%9F%BA%E7%A1%80/</id>
    <published>2021-12-21T02:22:00.000Z</published>
    <updated>2022-02-21T00:38:22.516Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844904127059738631#heading-35" target="_blank" rel="noopener">https://juejin.cn/post/6844904127059738631#heading-35</a></p><p><a href="https://thinkwon.blog.csdn.net/article/details/104390612" target="_blank" rel="noopener">https://thinkwon.blog.csdn.net/article/details/104390612</a></p><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h2><h3 id="jdk1-5之后的三大版本"><a href="#jdk1-5之后的三大版本" class="headerlink" title="==jdk1.5之后的三大版本=="></a>==jdk1.5之后的三大版本==</h3><ul><li>Java SE，标准版。支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。</li><li>Java EE，企业版。提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE</li><li>Java ME，微型版。在移动设备和嵌入式设备上运行的应用程序提供一个健壮且灵活的环境。应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</li></ul><h3 id="Jdk和Jre和JVM的区别"><a href="#Jdk和Jre和JVM的区别" class="headerlink" title="==Jdk和Jre和JVM的区别=="></a>==Jdk和Jre和JVM的区别==</h3><p><strong>JVM</strong><br>Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p><p><strong>JRE</strong></p><p>包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p><p><strong>JDK</strong> </p><p>提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxc2cfso1dj30o60eqgn9.jpg" alt="img"></p><h3 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h3><ol><li>简单易学（Java语言的语法与C语言和C++语言很接近）</li><li>面向对象（封装，继承，多态）</li><li>平台无关性（Java虚拟机实现平台无关性）</li><li>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</li><li>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</li><li>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</li><li>安全性好</li></ol><h3 id="什么是字节码？采用字节码的最大好处是什么"><a href="#什么是字节码？采用字节码的最大好处是什么" class="headerlink" title="==什么是字节码？采用字节码的最大好处是什么=="></a>==什么是字节码？采用字节码的最大好处是什么==</h3><ul><li><p><strong>字节码</strong>：</p><p>Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p></li><li><p><strong>采用字节码的好处</strong>：</p><ol><li>在一定程度上解决了传统解释型语言执行效率低的问题，所以Java程序运行时比较高效。</li><li>保留了解释型语言可移植的特点，由于字节码并不专对一种特定的机器，因此，无须重新编译便可在多种不同的计算机上运行。</li></ol></li><li><p><strong>java中的编译器和解释器</strong>：</p><p>Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。</p><p>Java源代码—&gt;编译器—&gt;jvm可执行的Java字节码(即虚拟指令)—&gt;jvm—&gt;jvm中解释器—-&gt;机器可执行的二进制机器码—&gt;程序运行。</p></li></ul><h3 id="什么是Java程序的主类？应用程序和小程序的主类有何不同？"><a href="#什么是Java程序的主类？应用程序和小程序的主类有何不同？" class="headerlink" title="什么是Java程序的主类？应用程序和小程序的主类有何不同？"></a>什么是Java程序的主类？应用程序和小程序的主类有何不同？</h3><p>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p><h3 id="Java应用程序与小程序之间有那些差别？"><a href="#Java应用程序与小程序之间有那些差别？" class="headerlink" title="Java应用程序与小程序之间有那些差别？"></a>Java应用程序与小程序之间有那些差别？</h3><p>简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。</p><h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java不提供指针来直接访问内存，程序内存更加安全</li><li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><h3 id="Oracle-JDK-和-OpenJDK-的对比"><a href="#Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="==Oracle JDK 和 OpenJDK 的对比=="></a>==Oracle JDK 和 OpenJDK 的对比==</h3><ol><li>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；</li><li>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；</li><li>Oracle JDK 比 OpenJDK 更稳定。</li><li>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；</li><li>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li><li>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</li></ol><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="==数据类型=="></a>==数据类型==</h3><h4 id="Java有哪些数据类型"><a href="#Java有哪些数据类型" class="headerlink" title="==Java有哪些数据类型=="></a>==Java有哪些数据类型==</h4><ul><li>基本数据类型<ul><li>数值型<ul><li>整数类型(byte,short,int,long)</li><li>浮点类型(float,double)</li></ul></li><li>字符型(char)</li><li>布尔型(boolean)</li></ul></li><li>引用数据类型<ul><li>类(class)</li><li>接口(interface)</li><li>数组([])</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxc2s4j5myj30w50ab41r.jpg" alt="img"></p><h4 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="==自动装箱与拆箱=="></a>==自动装箱与拆箱==</h4><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><p>Java 为每个原始类型提供了包装类型：</p><ul><li>原始类型: boolean，char，byte，short，int，long，float，double</li><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li></ul><h4 id="Integer-a-127-与-Integer-b-127相等吗"><a href="#Integer-a-127-与-Integer-b-127相等吗" class="headerlink" title="==Integer a= 127 与 Integer b = 127相等吗=="></a>==Integer a= 127 与 Integer b = 127相等吗==</h4><ul><li>对于对象引用类型：==比较的是对象的内存地址。</li><li>对于基本数据类型：==比较的是值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer a = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">3</span>);<br>    Integer b = <span class="hljs-number">3</span>;  <span class="hljs-comment">// 将3自动装箱成Integer类型</span><br>    <span class="hljs-keyword">int</span> c = <span class="hljs-number">3</span>;<br>    System.out.println(a == b); <span class="hljs-comment">// false 两个引用没有引用同一对象</span><br>    System.out.println(a == c); <span class="hljs-comment">// true a自动拆箱成int类型再和c比较</span><br>    System.out.println(b == c); <span class="hljs-comment">// true b自动拆箱成int类型再和c比较</span><br><span class="hljs-comment">// 如果整型自变量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，</span><br>    <span class="hljs-comment">// 超过范围 a1==b1的结果是false</span><br>    Integer a1 = <span class="hljs-number">128</span>;<br>    Integer b1 = <span class="hljs-number">128</span>;<br>    System.out.println(a1 == b1); <span class="hljs-comment">// false</span><br><br>    Integer a2 = <span class="hljs-number">127</span>;<br>    Integer b2 = <span class="hljs-number">127</span>;<br>    System.out.println(a2 == b2); <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上"><a href="#switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上" class="headerlink" title="==switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上=="></a>==switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上==</h4><p>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。<br>从 Java 5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，<br>从 Java 7 开始，expr 还可以是字符串（String），<br>但是长整型（long）在目前所有的版本中都是不可以的。</p><h4 id="用最有效率的方法计算-2-乘以-8"><a href="#用最有效率的方法计算-2-乘以-8" class="headerlink" title="用最有效率的方法计算 2 乘以 8"></a>用最有效率的方法计算 2 乘以 8</h4><p>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）</p><h4 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少？Math.round(-11.5)等于多少"></a>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</h4><p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。<strong>四舍五入的原理是在参数上加 0.5 然后进行下取整。</strong></p><h4 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f=3.4;是否正确"></a>float f=3.4;是否正确</h4><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。</p><h4 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗"></a>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</h4><ul><li><p>对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。</p></li><li><p>而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</p></li></ul><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="Java语言采用何种编码方案？有何特点？"><a href="#Java语言采用何种编码方案？有何特点？" class="headerlink" title="Java语言采用何种编码方案？有何特点？"></a>Java语言采用何种编码方案？有何特点？</h4><p>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="==访问修饰符=="></a>==访问修饰符==</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxc34k3rdkj30eg03xweu.jpg" alt="img"></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="==&amp;和&amp;&amp;的区别=="></a>==&amp;和&amp;&amp;的区别==</h4><ul><li>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</li><li>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</li></ul><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="Java-有没有-goto"><a href="#Java-有没有-goto" class="headerlink" title="Java 有没有 goto"></a>Java 有没有 goto</h4><p>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p><h4 id="final-有什么用？"><a href="#final-有什么用？" class="headerlink" title="==final 有什么用？=="></a>==final 有什么用？==</h4><ul><li>被final修饰的类不可以被继承</li><li>被final修饰的方法不可以被重写</li><li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的。</li></ul><h4 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="headerlink" title="==final finally finalize区别=="></a>==final finally finalize区别==</h4><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表 示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块 中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调 用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。</li></ul><h4 id="this关键字的用法"><a href="#this关键字的用法" class="headerlink" title="this关键字的用法"></a>this关键字的用法</h4><ul><li><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p></li><li><p>this的用法在java中大体可以分为3种：</p><ol><li>普通的直接引用，this相当于是指向当前对象本身。</li><li>形参与成员名字重名，用this来区分：</li><li>引用本类的构造函数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(name);<span class="hljs-comment">// 这里</span><br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="super关键字的用法"><a href="#super关键字的用法" class="headerlink" title="super关键字的用法"></a>super关键字的用法</h4><ul><li>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</li><li>super也有三种用法：<ol><li>普通的直接引用.</li><li>子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分.</li><li>引用父类构造函数</li></ol></li></ul><h4 id="this与super的区别"><a href="#this与super的区别" class="headerlink" title="this与super的区别"></a>this与super的区别</h4><ul><li>super()和this()均需放在构造方法内第一行。</li><li>尽管可以用this调用一个构造器，但却不能调用两个。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li><li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li></ul><h4 id="static存在的主要意义"><a href="#static存在的主要意义" class="headerlink" title="==static存在的主要意义=="></a>==static存在的主要意义==</h4><ul><li>static的主要意义是在于创建独立于具体对象的域变量或者方法。<strong>以致于即使没有创建对象，也能使用属性和调用方法</strong>！</li><li>static关键字还有一个比较关键的作用就是 <strong>用来形成静态代码块以优化程序性能</strong>。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</li><li>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</li></ul><h4 id="static的独特之处"><a href="#static的独特之处" class="headerlink" title="static的独特之处"></a>static的独特之处</h4><ol><li>被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法<strong>不属于任何一个实例对象，而是被类的实例对象所共享</strong>。</li><li>在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</li><li>static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的。</li><li>被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</li></ol><h4 id="static应用场景"><a href="#static应用场景" class="headerlink" title="static应用场景"></a>static应用场景</h4><p>1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部类】 5、静态导包</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h3><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="==面向对象和面向过程的区别=="></a>==面向对象和面向过程的区别==</h4><p><strong>面向过程</strong>：</p><ul><li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护、易复用、易扩展</li></ul><p><strong>面向对象</strong>：</p><ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li><li>缺点：性能比面向过程低</li></ul><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="==面向对象三大特性=="></a>==面向对象三大特性==</h3><h4 id="面向对象的特征有哪些方面"><a href="#面向对象的特征有哪些方面" class="headerlink" title="面向对象的特征有哪些方面"></a>面向对象的特征有哪些方面</h4><ul><li><p><strong>封装</strong>把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p></li><li><p><strong>继承</strong>是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><p>  关于继承如下 3 点请记住：</p><ul><li>子类拥有父类非 private 的属性和方法。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ul></li><li><p><strong>多态</strong>：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p></li></ul><h4 id="Java语言是如何实现多态的？"><a href="#Java语言是如何实现多态的？" class="headerlink" title="Java语言是如何实现多态的？"></a>Java语言是如何实现多态的？</h4><ul><li>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</li></ul><p><strong>多态的实现</strong></p><ul><li>Java实现多态有三个必要条件：继承、重写、向上转型。<ul><li>继承：在多态中必须存在有继承关系的子类和父类。</li><li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li><li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li></ul></li></ul><h4 id="面向对象五大基本原则是什么（可选）"><a href="#面向对象五大基本原则是什么（可选）" class="headerlink" title="面向对象五大基本原则是什么（可选）"></a>面向对象五大基本原则是什么（可选）</h4><ol><li><strong>单一职责原则</strong>SRP(Single Responsibility Principle)<br> 类的功能要单一，不能包罗万象，跟杂货铺似的。</li><li><strong>开放封闭原则</strong>OCP(Open－Close Principle)<br> 一个模块对于拓展是开放的，对于修改是封闭的。</li><li><strong>里式替换原则</strong>LSP(the Liskov Substitution Principle LSP)<br> 子类可以替换父类出现在父类能够出现的任何地方。</li><li><strong>依赖倒置原则</strong>DIP(the Dependency Inversion Principle DIP)<br> 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</li><li><strong>接口分离原则</strong>ISP(the Interface Segregation Principle ISP)<br> 设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</li></ol><h3 id="Java-Bean"><a href="#Java-Bean" class="headerlink" title="Java Bean"></a>Java Bean</h3><p>参考：<a href="https://www.zhihu.com/question/19773379，https://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680" target="_blank" rel="noopener">https://www.zhihu.com/question/19773379，https://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680</a></p><p>简单来说：一种规范，表达实体和信息的规范，便于封装重用</p><p>1、所有属性为private</p><p>2、提供默认构造方法</p><p>3、提供getter和setter</p><p>4、实现serializable接口</p><h3 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h3><p><a href="https://www.runoob.com/w3cnote/java-annotation.html，" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/java-annotation.html，</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265102413966176" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1265102413966176</a></p><p><a href="https://blog.csdn.net/javazejian/article/details/71860633" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/71860633</a></p><p><a href="https://www.jianshu.com/p/5cac4cb9be54" target="_blank" rel="noopener">https://www.jianshu.com/p/5cac4cb9be54</a></p><p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p><p><strong>注解的作用</strong></p><ul><li><strong>格式检查：</strong>告诉编译器信息，比如被@Override标记的方法如果不是父类的某个方法，IDE会报错；</li><li><strong>减少配置：</strong>运行时动态处理，得到注解信息，实现代替配置文件的功能；</li><li><strong>减少重复工作：</strong>比如第三方框架xUtils，通过注解@ViewInject减少对findViewById的调用，类似的还有（JUnit、ActiveAndroid等）；</li></ul><h3 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h3><h4 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="==抽象类和接口的对比=="></a>==抽象类和接口的对比==</h4><p><strong>相同点</strong></p><ul><li>接口和抽象类都不能实例化</li><li>都位于继承的顶端，用于被其他实现或继承</li><li>都包含抽象方法，其子类都必须覆写这些抽象方法</li></ul><p><strong>不同点</strong></p><table><thead><tr><th>参数</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>声明</td><td>抽象类使用abstract关键字声明</td><td>接口使用interface关键字声明</td></tr><tr><td>实现</td><td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td><td>子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td></tr><tr><td>构造器</td><td>抽象类可以有构造器</td><td>接口不能有构造器</td></tr><tr><td>访问修饰符</td><td>抽象类中的方法可以是任意访问修饰符</td><td>接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td></tr><tr><td>多继承</td><td>一个类最多只能继承一个抽象类</td><td>一个类可以实现多个接口</td></tr><tr><td>字段声明</td><td>抽象类的字段声明可以是任意的</td><td>接口的字段默认都是 static 和 final 的</td></tr></tbody></table><p><strong>备注</strong>：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p><h4 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h4><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><h4 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h4><ul><li>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承。</li></ul><h4 id="创建一个对象用什么关键字？对象实例与对象引用有何不同？"><a href="#创建一个对象用什么关键字？对象实例与对象引用有何不同？" class="headerlink" title="创建一个对象用什么关键字？对象实例与对象引用有何不同？"></a>创建一个对象用什么关键字？对象实例与对象引用有何不同？</h4><ul><li>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</li></ul><h3 id="变量与方法"><a href="#变量与方法" class="headerlink" title="变量与方法"></a>变量与方法</h3><h4 id="成员变量与局部变量的区别有哪些"><a href="#成员变量与局部变量的区别有哪些" class="headerlink" title="成员变量与局部变量的区别有哪些"></a>成员变量与局部变量的区别有哪些</h4><p><strong>变量存储位置</strong></p><ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。</li><li>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</li></ul><h4 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="==构造方法有哪些特性？=="></a>==构造方法有哪些特性？==</h4><ul><li>名字与类名相同；</li><li>没有返回值，但不能用void声明构造函数；</li><li>生成类的对象时自动执行，无需调用。</li></ul><h4 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="==在Java中定义一个不做事且没有参数的构造方法的作用=="></a>==在Java中定义一个不做事且没有参数的构造方法的作用==</h4><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><h4 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</h4><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="==重写与重载=="></a>==重写与重载==</h3><p>参考：<a href="https://www.runoob.com/java/java-override-overload.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-override-overload.html</a></p><h4 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="==构造器（constructor）是否可被重写（override）=="></a>==构造器（constructor）是否可被重写（override）==</h4><p>构造器不能被继承，因此不能被重写，但可以被重载。</p><h4 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h4><ul><li>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</li><li>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</li><li>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</li></ul><table><thead><tr><th align="left">区别点</th><th align="left">重载方法</th><th align="left">重写方法</th></tr></thead><tbody><tr><td align="left">参数列表</td><td align="left">必须修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">返回类型</td><td align="left">可以修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">异常</td><td align="left">可以修改</td><td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td align="left">访问</td><td align="left">可以修改</td><td align="left">一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table><h3 id="对象相等判断"><a href="#对象相等判断" class="headerlink" title="对象相等判断"></a>对象相等判断</h3><h4 id="和-equals-的区别是什么"><a href="#和-equals-的区别是什么" class="headerlink" title="==== 和 equals 的区别是什么=="></a>==== 和 equals 的区别是什么==</h4><ul><li><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</p></li><li><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li><p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</p></li><li><p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p></li><li><p>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</p></li><li><p>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String a = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"ab"</span>); <span class="hljs-comment">// a 为一个引用</span><br>        String b = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"ab"</span>); <span class="hljs-comment">// b为另一个引用,对象的内容一样</span><br>        String aa = <span class="hljs-string">"ab"</span>; <span class="hljs-comment">// 放在常量池中</span><br>        String bb = <span class="hljs-string">"ab"</span>; <span class="hljs-comment">// 从常量池中查找</span><br>        <span class="hljs-keyword">if</span> (aa == bb) <span class="hljs-comment">// true</span><br>            System.out.println(<span class="hljs-string">"aa==bb"</span>);<br>        <span class="hljs-keyword">if</span> (a == b) <span class="hljs-comment">// false，非同一对象</span><br>            System.out.println(<span class="hljs-string">"a==b"</span>);<br>        <span class="hljs-keyword">if</span> (a.equals(b)) <span class="hljs-comment">// true</span><br>            System.out.println(<span class="hljs-string">"aEQb"</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">42</span> == <span class="hljs-number">42.0</span>) &#123; <span class="hljs-comment">// true</span><br>            System.out.println(<span class="hljs-string">"true"</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="hashCode-与-equals-重要"><a href="#hashCode-与-equals-重要" class="headerlink" title="==hashCode 与 equals (重要)=="></a>==hashCode 与 equals (重要)==</h4><p><strong>hashCode()介绍</strong></p><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p><p><strong>为什么要有 hashCode</strong></p><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p><strong>hashCode()与equals()的相关规定</strong></p><ul><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等，对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li></ul><p>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</p><h4 id="对象的相等与指向他们的引用相等，两者有什么不同？"><a href="#对象的相等与指向他们的引用相等，两者有什么不同？" class="headerlink" title="对象的相等与指向他们的引用相等，两者有什么不同？"></a>对象的相等与指向他们的引用相等，两者有什么不同？</h4><ul><li>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。</li></ul><h3 id="对象的克隆"><a href="#对象的克隆" class="headerlink" title="==对象的克隆=="></a>==对象的克隆==</h3><p>参考：<a href="https://www.cnblogs.com/qian123/p/5710533.html" target="_blank" rel="noopener">https://www.cnblogs.com/qian123/p/5710533.html</a></p><h4 id="为什么要克隆？"><a href="#为什么要克隆？" class="headerlink" title="==为什么要克隆？=="></a>==为什么要克隆？==</h4><ul><li><p>克隆的对象可能包含一些已经修改过的属性，而new出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠clone方法了。那么我把这个对象的临时属性一个一个的赋值给我新new的对象不也行嘛？可以是可以，但是一来麻烦不说，二来，大家通过上面的源码都发现了clone是一个native方法，就是快啊，在底层实现的。</p></li><li><p>提个醒，我们常见的Object a=new Object();Object b;b=a;这种形式的代码复制的是引用，即对象在内存中的地址，a和b对象仍然指向了同一个对象。而通过clone方法赋值的对象跟原来的对象时同时独立存在的。</p></li></ul><h4 id="浅拷贝深拷贝的区别？"><a href="#浅拷贝深拷贝的区别？" class="headerlink" title="==浅拷贝深拷贝的区别？=="></a>==浅拷贝深拷贝的区别？==</h4><ul><li>在Java语言中，数据类型分为值类型（基本数据类型）和引用类型，值类型包括int、double、byte、boolean、char等简单数据类型，引用类型包括类、接口、数组等复杂类型。浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制。不可变引用数据类型（String）的数据可以被浅拷贝。</li></ul><h5 id="浅复制（浅克隆）"><a href="#浅复制（浅克隆）" class="headerlink" title="浅复制（浅克隆）"></a>浅复制（浅克隆）</h5><ul><li><p>实现 Cloneable 接⼝并重写 Object 类中的 clone() ⽅法;（浅拷贝）</p></li><li><p>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。</p></li><li><p>换言之，<strong>浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。</strong></p></li></ul><h5 id="深复制（深克隆）"><a href="#深复制（深克隆）" class="headerlink" title="深复制（深克隆）"></a>深复制（深克隆）</h5><ul><li><p>实现 Serializable 接⼝，通过对象的序列化和反序列化实现克隆（深拷贝）</p></li><li><p>被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。</p></li><li><p>那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。</p></li><li><p>换言之，<strong>深复制把要复制的对象所引用的对象都复制了一遍</strong>。</p></li></ul><h4 id="如何实现克隆？"><a href="#如何实现克隆？" class="headerlink" title="==如何实现克隆？=="></a>==如何实现克隆？==</h4><ul><li><strong>浅克隆：</strong></li></ul><ol><li><p>被复制的类需要实现Clonenable接口（不实现的话在调用clone方法会抛出CloneNotSupportedException异常)， 该接口为标记接口(不含任何方法)</p></li><li><p>覆盖clone()方法，访问修饰符设为public。方法中调用super.clone()方法得到需要的复制对象。（native为本地方法)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;  <br>  <br>... getter(),setter()...<br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;  <br>        Student stu = <span class="hljs-keyword">null</span>;  <br>        <span class="hljs-keyword">try</span>&#123;  <br>            stu = (Student)<span class="hljs-keyword">super</span>.clone();  <br>        &#125;<span class="hljs-keyword">catch</span>(CloneNotSupportedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> stu;  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;  <br>  Student stu1 = <span class="hljs-keyword">new</span> Student();  <br>        stu1.setNumber(<span class="hljs-number">12345</span>);  <br>        Student stu2 = (Student)stu1.clone();  <br>          <br>        System.out.println(<span class="hljs-string">"学生1:"</span> + stu1.getNumber());  <br>        System.out.println(<span class="hljs-string">"学生2:"</span> + stu2.getNumber());  <br>          <br>        stu2.setNumber(<span class="hljs-number">54321</span>);  <br>      <br>        System.out.println(<span class="hljs-string">"学生1:"</span> + stu1.getNumber());  <br>        System.out.println(<span class="hljs-string">"学生2:"</span> + stu2.getNumber()); <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">学生<span class="hljs-number">1</span>:<span class="hljs-number">12345</span>  学生<span class="hljs-number">2</span>:<span class="hljs-number">12345</span>  学生<span class="hljs-number">1</span>:<span class="hljs-number">12345</span>  学生<span class="hljs-number">2</span>:<span class="hljs-number">54321</span><br></code></pre></td></tr></table></figure><p>验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(stu1 == stu2); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><ul><li><strong>深克隆：</strong></li></ul><ol><li><p>实现深克隆，可以通过序列化(Serialization)方式来实现。</p></li><li><p>序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。需要注意的是能够实现序列化的对象其类必须实现Serializable接口，否则无法实现序列化操作。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;  <br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;  <br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;  <br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;  <br><span class="hljs-keyword">import</span> java.io.Serializable;  <br><span class="hljs-comment">//利用序列化来做深复制  </span><br><span class="hljs-comment">//深clone  </span><br>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeepCloneTest</span>  <br></span>&#123;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception  <br>    </span>&#123;  <br>        <span class="hljs-comment">// teacher对象将不被clone出来的Student对象共享.  </span><br>        Teacher teacher = <span class="hljs-keyword">new</span> Teacher();  <br>        teacher.setAge(<span class="hljs-number">40</span>);  <br>        teacher.setName(<span class="hljs-string">"Teacher zhang"</span>);  <br>  <br>        Student student1 = <span class="hljs-keyword">new</span> Student();  <br>        student1.setAge(<span class="hljs-number">20</span>);  <br>        student1.setName(<span class="hljs-string">"zhangsan"</span>);  <br>        student1.setTeacher(teacher);  <br>  <br>        <span class="hljs-comment">// 复制出来一个对象student2  </span><br>        Student student2 = (Student) student1.deepCopy();  <br>        System.out.println(student2.getAge());  <br>        System.out.println(student2.getName());  <br>  <br>        System.out.println(<span class="hljs-string">"~~~~~~~~~~~~~~~~~~~~~~"</span>);  <br>        System.out.println(student1.getTeacher().getAge());  <br>        System.out.println(student1.getTeacher().getName());  <br>  <br>        <span class="hljs-comment">// 修改student2的引用对象  </span><br>        student2.getTeacher().setAge(<span class="hljs-number">50</span>);  <br>        student2.getTeacher().setName(<span class="hljs-string">"Teacher Li"</span>);  <br>  <br>        System.out.println(<span class="hljs-string">"~~~~~~~~~~~~~~~~~~~~~~"</span>);  <br>        System.out.println(student1.getTeacher().getAge());  <br>        System.out.println(student1.getTeacher().getName());  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>  <br></span>&#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">8834559347461591191L</span>;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;  <br>    <span class="hljs-keyword">public</span> String name;  <br>  ... getter(),setter()...<br>&#125;  <br>  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>  <br></span>&#123;  <br>  <br>    <span class="hljs-comment">// serialVersionUID  </span><br>    <span class="hljs-comment">// 如果你的对象序列化后存到硬盘上面后，可是后来你却更改了类的field(增加或减少或改名)，当你</span><br>    <span class="hljs-comment">// 反序列化时，就会出现Exception的，这样就会造成不兼容性的问题。  </span><br>    <span class="hljs-comment">// 但当serialVersionUID相同时，它就会将不一样的field以type的</span><br>    <span class="hljs-comment">// 缺省值赋值(如int型的是0,String型的是null等)，这个可以避开不兼容性的问题。</span><br>    <span class="hljs-comment">// 所以最好给serialVersionUID赋值  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7991552226614088458L</span>;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;  <br>    <span class="hljs-keyword">public</span> String name;  <br>    <span class="hljs-keyword">public</span> Teacher teacher;  <br>  <br>... getter(),setter()...<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">deepCopy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception  <br>    </span>&#123;  <br>        <span class="hljs-comment">// 将该对象序列化成流,因为写在流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。</span><br>        <span class="hljs-comment">// 所以利用这个特性可以实现对象的深拷贝。  </span><br>        ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();  <br>  <br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);  <br>  <br>        oos.writeObject(<span class="hljs-keyword">this</span>);  <br>  <br>        <span class="hljs-comment">// 将流序列化成对象  </span><br>        ByteArrayInputStream bis = <span class="hljs-keyword">new</span> ByteArrayInputStream(bos.toByteArray());  <br>  <br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis);  <br>  <br>        <span class="hljs-keyword">return</span> ois.readObject();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">20</span>  <span class="hljs-string"></span><br><span class="hljs-attr">zhangsan</span>  <span class="hljs-string"></span><br><span class="hljs-meta">~~~~~~~~~~~~~~~~~~~~~~</span>  <span class="hljs-string"></span><br><span class="hljs-attr">40</span>  <span class="hljs-string"></span><br><span class="hljs-attr">Teacher</span> <span class="hljs-string">zhang  </span><br><span class="hljs-meta">~~~~~~~~~~~~~~~~~~~~~~</span>  <span class="hljs-string"></span><br><span class="hljs-attr">40</span>  <span class="hljs-string"></span><br><span class="hljs-attr">Teacher</span> <span class="hljs-string">zhang</span><br></code></pre></td></tr></table></figure><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><h4 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</h4><p>是值传递。<strong>Java 语言的方法调用只支持参数的值传递</strong>。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</p><h4 id="为什么-Java-中只有值传递"><a href="#为什么-Java-中只有值传递" class="headerlink" title="==为什么 Java 中只有值传递=="></a>==为什么 Java 中只有值传递==</h4><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p><p><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p><ul><li>例子1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> num2 = <span class="hljs-number">20</span>;<br><br>    swap(num1, num2);<br><br>    System.out.println(<span class="hljs-string">"num1 = "</span> + num1);<br>    System.out.println(<span class="hljs-string">"num2 = "</span> + num2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> temp = a;<br>    a = b;<br>    b = temp;<br><br>    System.out.println(<span class="hljs-string">"a = "</span> + a);<br>    System.out.println(<span class="hljs-string">"b = "</span> + b);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">a = <span class="hljs-number">20</span> b = <span class="hljs-number">10</span> num1 = <span class="hljs-number">10</span> num2 = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>通过上面例子，我们已经知道了<strong>==一个方法不能修改一个基本数据类型的参数==</strong>，而对象引用作为参数就不一样，请看例子2.</p><p>解析</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxccp9mgroj30dg0atmxb.jpg" alt="在这里插入图片描述"></p><ul><li>例子2</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>    change(arr);<br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;<br>    <span class="hljs-comment">// 将数组的第一个元素变为0</span><br>    array[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p><p>解析</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxccpqctb7j30fw08nweh.jpg" alt="在这里插入图片描述"></p><ul><li>例子3</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        Student s1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小张"</span>);<br>        Student s2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小李"</span>);<br>        Test.swap(s1, s2);<br>        System.out.println(<span class="hljs-string">"s1:"</span> + s1.getName());<br>        System.out.println(<span class="hljs-string">"s2:"</span> + s2.getName());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Student x, Student y)</span> </span>&#123;<br>        Student temp = x;<br>        x = y;<br>        y = temp;<br>        System.out.println(<span class="hljs-string">"x:"</span> + x.getName());<br>        System.out.println(<span class="hljs-string">"y:"</span> + y.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x:小李 y:小张 s1:小张 s2:小李<br></code></pre></td></tr></table></figure><ul><li>解析：</li><li>交换之前：</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxccqtrbssj30iv09ogls.jpg" alt="在这里插入图片描述"></p><ul><li>交换之后：</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxccqsy2inj30iv09ot8w.jpg" alt="在这里插入图片描述"></p><p>通过上面两张图可以很清晰的看出：<code>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</code></p><h4 id="值传递和引用传递有什么区别"><a href="#值传递和引用传递有什么区别" class="headerlink" title="值传递和引用传递有什么区别"></a>值传递和引用传递有什么区别</h4><ul><li>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</li><li>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）</li></ul><h3 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h3><h4 id="JDK-中常用的包有哪些"><a href="#JDK-中常用的包有哪些" class="headerlink" title="JDK 中常用的包有哪些"></a>JDK 中常用的包有哪些</h4><ul><li>java.lang：这个是系统的基础类；</li><li>java.io：这里面是所有输入输出有关的类，比如文件操作等；</li><li>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；</li><li>java.net：这里面是与网络有关的类；</li><li>java.util：这个是系统辅助类，特别是集合类；</li><li>java.sql：这个是数据库操作的类。</li></ul><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>详情见 1.2  JavaIO</p><h3 id="java-中-IO-流分为几种"><a href="#java-中-IO-流分为几种" class="headerlink" title="java 中 IO 流分为几种?"></a>java 中 IO 流分为几种?</h3><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><blockquote><p>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p><p>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxce6h0r4jj30k00evwfg.jpg" alt="img"></p><h3 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="==BIO,NIO,AIO 有什么区别?=="></a>==BIO,NIO,AIO 有什么区别?==</h3><ul><li>简答<ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul></li></ul><h3 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h3><ul><li>Files. exists()：检测文件路径是否存在。</li><li>Files. createFile()：创建文件。</li><li>Files. createDirectory()：创建文件夹。</li><li>Files. delete()：删除一个文件或目录。</li><li>Files. copy()：复制文件。</li><li>Files. move()：移动文件。</li><li>Files. size()：查看文件个数。</li><li>Files. read()：读取文件。</li><li>Files. write()：写入文件。</li></ul><h2 id="泛型与反射"><a href="#泛型与反射" class="headerlink" title="泛型与反射"></a>泛型与反射</h2><h3 id="Java-的泛型是如何工作的-什么是类型擦除"><a href="#Java-的泛型是如何工作的-什么是类型擦除" class="headerlink" title="Java 的泛型是如何工作的 ? 什么是类型擦除 ?"></a>Java 的泛型是如何工作的 ? 什么是类型擦除 ?</h3><p>泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运⾏时不存在任何类型相关的信息。例如:List<String> 在运行时仅⽤一个 List 来表示。这样做的目的，是确保能和 Java 5 之前的版本开发⼆进制类库进行兼容。</p><p>类型擦除:泛型信息只存在于代码编译阶段，在进⼊ JVM 之前，与泛型相关的信息会被擦除掉。在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 &lt; T &gt; 则会被转译成普通的 Object 类型，如果指定了上限如 &lt; T extends String &gt; 则类型参数就被替换成类型上限。</p><p><strong>补充</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br></code></pre></td></tr></table></figure><p>1、两个 String 其实只有第一个起作用，后⾯一个没什么卵用，只不过 JDK7 才开始⽀支持<code>List&lt;String&gt;list = new ArrayList&lt;&gt;</code> 这种写法。<br>2、第⼀个 String 就是告诉编译器，List 中存储的是 String 对象，也就是起类型检查的作用，之后编译器会擦除泛型占位符，以保证兼容以前的代码。</p><h3 id="什么是泛型中的限定通配符和非限定通配符"><a href="#什么是泛型中的限定通配符和非限定通配符" class="headerlink" title="什么是泛型中的限定通配符和非限定通配符 ?"></a>什么是泛型中的限定通配符和非限定通配符 ?</h3><p>限定通配符对类型进行了限制。有两种限定通配符，一种是&lt; ? extends T &gt; 它通过确保类型必须是 T 的子类来设定类型的上界，另一种是&lt; ? super T &gt;它通过确保类型必须是 T 的⽗类来设定类型的下界。泛型类型必须⽤限定内的类型来进行初始化，否则会导致编译错误。另⼀⽅面 &lt; ? &gt; 表示了非限定通配符，因为 &lt; ? &gt; 可以⽤任意类型来替代。</p><h3 id="List-lt-extends-T-gt-和-List-lt-super-T-gt-之间有什么区别"><a href="#List-lt-extends-T-gt-和-List-lt-super-T-gt-之间有什么区别" class="headerlink" title="List&lt;? extends T&gt; 和 List &lt;? super T&gt; 之间有什么区别 ?"></a>List&lt;? extends T&gt; 和 List &lt;? super T&gt; 之间有什么区别 ?</h3><p>这两个 List 的声明都是限定通配符的例子，List&lt; ? extends T &gt; 可以接受任何继承⾃ T 的类型的 List，而List &lt; ? super T &gt; 可以接受任何 T 的⽗类构成的 List。例如 List&lt; ? extends Number &gt; 可以接受 List&lt; Integer &gt; 或 List&lt; Float &gt; 。<br>Array 不支持泛型，要⽤List 代替 Array，因为 List 可以提供编译器的类型安全保证，⽽Array却不能。</p><h3 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a>什么是反射机制？</h3><ul><li>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</li><li>静态编译和动态编译<ul><li>静态编译：在编译时确定类型，绑定对象</li><li>动态编译：运行时确定类型，绑定对象</li></ul></li></ul><h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="==反射机制优缺点=="></a>==反射机制优缺点==</h3><ul><li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li><li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li></ul><h3 id="反射机制的应用场景有哪些？"><a href="#反射机制的应用场景有哪些？" class="headerlink" title="反射机制的应用场景有哪些？"></a>反射机制的应用场景有哪些？</h3><ul><li><p>反射是框架设计的灵魂。如Spring/Hibernate 动态代理设计模式也采用了反射机制</p></li><li><p>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。</p></li></ul><blockquote><p>Spring 通过 XML 配置模式装载 Bean 的过程：</p><p>1) 将程序内所有 XML 或 Properties 配置文件加载入内存中;<br>2) Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;<br>3) 使用反射机制，根据这个字符串获得某个类的Class实例;<br>4) 动态配置实例的属性</p></blockquote><h3 id="Java获取反射的三种方法"><a href="#Java获取反射的三种方法" class="headerlink" title="Java获取反射的三种方法"></a>Java获取反射的三种方法</h3><p>1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> sex;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> score;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Get</span> </span>&#123;<br>    <span class="hljs-comment">//获取反射机制三种方式</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        <span class="hljs-comment">//方式一(通过建立对象)</span><br>        Student stu = <span class="hljs-keyword">new</span> Student();<br>        Class classobj1 = stu.getClass();<br>        System.out.println(classobj1.getName());<br>        <span class="hljs-comment">//方式二（所在通过路径-相对路径）</span><br>        Class classobj2 = Class.forName(<span class="hljs-string">"fanshe.Student"</span>);<br>        System.out.println(classobj2.getName());<br>        <span class="hljs-comment">//方式三（通过类名）</span><br>        Class classobj3 = Student<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;<br>        System.out.println(classobj3.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Java字符串"><a href="#Java字符串" class="headerlink" title="Java字符串"></a>Java字符串</h2><h3 id="什么是字符串常量池？"><a href="#什么是字符串常量池？" class="headerlink" title="什么是字符串常量池？"></a>什么是字符串常量池？</h3><ul><li>字符串常量池位于<strong>堆内存</strong>中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</li></ul><h3 id="String有哪些特性"><a href="#String有哪些特性" class="headerlink" title="String有哪些特性"></a>String有哪些特性</h3><ul><li>不变性：String 是只读字符串，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</li><li>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</li><li>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li></ul><h3 id="String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="==String str=”i”与 String str=new String(“i”)一样吗？=="></a>==String str=”i”与 String str=new String(“i”)一样吗？==</h3><ul><li>不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</li></ul><h3 id="String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="String s = new String(“xyz”);创建了几个字符串对象"></a>String s = new String(“xyz”);创建了几个字符串对象</h3><ul><li>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</li></ul><h3 id="如何将字符串反转？"><a href="#如何将字符串反转？" class="headerlink" title="==如何将字符串反转？=="></a>==如何将字符串反转？==</h3><ul><li>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// StringBuffer reverse</span><br>StringBuffer stringBuffer = <span class="hljs-keyword">new</span> StringBuffer();<br>stringBuffer.append(<span class="hljs-string">"abcdefg"</span>);<br>System.out.println(stringBuffer.reverse()); <span class="hljs-comment">// gfedcba</span><br><span class="hljs-comment">// StringBuilder reverse</span><br>StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>stringBuilder.append(<span class="hljs-string">"abcdefg"</span>);<br>System.out.println(stringBuilder.reverse()); <span class="hljs-comment">// gfedcba</span><br></code></pre></td></tr></table></figure><h3 id="数组有没有-length-方法？String-有没有-length-方法"><a href="#数组有没有-length-方法？String-有没有-length-方法" class="headerlink" title="数组有没有 length()方法？String 有没有 length()方法"></a>数组有没有 length()方法？String 有没有 length()方法</h3><ul><li>数组没有 length()方法 ，有 length 的属性。String 有 length()方法。</li></ul><h3 id="String-类的常用方法都有那些？"><a href="#String-类的常用方法都有那些？" class="headerlink" title="==String 类的常用方法都有那些？=="></a>==String 类的常用方法都有那些？==</h3><ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul><h3 id="在使用-HashMap-的时候，用-String-做-key-有什么好处？"><a href="#在使用-HashMap-的时候，用-String-做-key-有什么好处？" class="headerlink" title="在使用 HashMap 的时候，用 String 做 key 有什么好处？"></a>在使用 HashMap 的时候，用 String 做 key 有什么好处？</h3><ul><li>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</li></ul><h3 id="String和StringBuffer、StringBuilder的区别是什么？"><a href="#String和StringBuffer、StringBuilder的区别是什么？" class="headerlink" title="==String和StringBuffer、StringBuilder的区别是什么？=="></a>==String和StringBuffer、StringBuilder的区别是什么？==</h3><table><thead><tr><th>可变性</th><th>String 不可变<br />StringBuilder可变<br />StringBuffer可变</th></tr></thead><tbody><tr><td>线程安全性</td><td>String 安全<br />StringBuilder不安全<br />StringBuffer安全（加了同步锁Synchronized）</td></tr><tr><td>性能</td><td>StringBuilder &gt; StringBuffer &gt; String</td></tr></tbody></table><p><strong>对于三者使用的总结</strong></p><ul><li>如果要操作少量的数据用 = String</li><li>单线程操作字符串缓冲区下操作大量数据 = StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</li></ul><h2 id="Java日期类"><a href="#Java日期类" class="headerlink" title="Java日期类"></a>Java日期类</h2><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><h4 id="java-util-Date"><a href="#java-util-Date" class="headerlink" title="java.util.Date"></a>java.util.Date</h4><ul><li>两个构造函数；1. 无参构造。 2.提供毫秒数（时间戳）构造。</li><li>包含有年月日时分秒，精确到毫秒级别。从1970-01-01开始的毫秒数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">java.util.Date<br><span class="hljs-comment">// 语句</span><br>Date date = <span class="hljs-keyword">new</span> Date();<br>System.out.println(date);<br><br><span class="hljs-comment">//输出结果</span><br>Sat Feb <span class="hljs-number">03</span> <span class="hljs-number">14</span>:<span class="hljs-number">48</span>:<span class="hljs-number">47</span> CST <span class="hljs-number">2018</span><br></code></pre></td></tr></table></figure><ul><li>线程不安全</li><li>时间比较，before(),after().</li></ul><h4 id="java-sql-Date"><a href="#java-sql-Date" class="headerlink" title="java.sql.Date"></a>java.sql.Date</h4><ul><li>包含年月日，时分秒都被设置为0，之所以这样设计是为了适应SQL中的<code>DATE</code>类型。</li><li>注意，虽然说这个类是使用年月日的，但是初始化的时候，需要一个long类型的参数，这个参数代表着January 1, 1970, 00:00:00 GMT到某个时间的毫秒数。如果是当前时间的话，可以用System.currentTimeMillis()或者new Date().getTime()获取。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 语句</span><br>java.sql.Date sqlDate = <span class="hljs-keyword">new</span> java.sql.Date(System.currentTimeMillis());<br>System.out.println(sqlDate);<br><br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-number">2018</span>-<span class="hljs-number">02</span>-<span class="hljs-number">03</span><br></code></pre></td></tr></table></figure><h4 id="java-sql-Time"><a href="#java-sql-Time" class="headerlink" title="java.sql.Time"></a>java.sql.Time</h4><ul><li>包含时分秒，这个也是为了SQL中的<code>TIME</code>类型而出现的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 语句</span><br>Time time = <span class="hljs-keyword">new</span> Time(System.currentTimeMillis());<br>System.out.println(time);<br><br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-number">15</span>:<span class="hljs-number">07</span>:<span class="hljs-number">35</span><br></code></pre></td></tr></table></figure><h4 id="java-sql-Timestamp"><a href="#java-sql-Timestamp" class="headerlink" title="java.sql.Timestamp"></a>java.sql.Timestamp</h4><ul><li>时间戳，适配于SQL中的<code>TIMESTAMP</code>类型而出现的，精确到纳秒级别。</li></ul><h3 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h3><ul><li>非线程安全</li><li>SimpleDateFormat类：时间转字符串format()，字符串转时间parse()。</li><li>保证 SimpleDateFormat 线程安全的方式如下：<ul><li>使用 Synchronized，在需要时间格式化的操作使用 Synchronized 关键字进行包装，保证线程堵塞格式化；</li><li>手动加锁，把需要格式化时间的代码，写到加锁部分，相对 Synchronized 来说，编码效率更低，性能略好，代码风险较大（风险在于不要忘记在操作的最后，手动释放锁）；</li><li>使用 JDK 8 的 DateTimeFormatter 替代 SimpleDateFormat。</li></ul></li></ul><h3 id="java-util-Calendar类"><a href="#java-util-Calendar类" class="headerlink" title="java.util.Calendar类"></a>java.util.Calendar类</h3><ul><li>日历类，这个类大多被用于获取时间的特殊属性，比如说获取某个时间对象的年份、月份、星期等</li></ul><h3 id="JDK-8-之前的时间操作"><a href="#JDK-8-之前的时间操作" class="headerlink" title="JDK 8 之前的时间操作"></a><strong>JDK 8 之前的时间操作</strong></h3><p><strong>1 获取时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Date date = <span class="hljs-keyword">new</span> Date();<br>System.out.println(date);<br>Calendar calendar = Calendar.getInstance();<br>Date time = calendar.getTime();<br>System.out.println(time);<br></code></pre></td></tr></table></figure><p><strong>2 获取时间戳</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> ts = <span class="hljs-keyword">new</span> Date().getTime();<br>System.out.println(ts);<br><span class="hljs-keyword">long</span> ts2 = System.currentTimeMillis();<br>System.out.println(ts2);<br><span class="hljs-keyword">long</span> ts3 = Calendar.getInstance().getTimeInMillis();<br>System.out.println(ts3);<br></code></pre></td></tr></table></figure><p><strong>3 格式化时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">SimpleDateFormat sf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);<br>System.out.println(sf.format(<span class="hljs-keyword">new</span> Date()));  <span class="hljs-comment">// output:2019-08-16 21:46:22</span><br></code></pre></td></tr></table></figure><p><strong>4 时间转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">SimpleDateFormat sf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);<br><span class="hljs-comment">// String 转 Date</span><br>String str = <span class="hljs-string">"2019-10-10 10:10:10"</span>;<br>System.out.println(sf.parse(str));<br><span class="hljs-comment">//时间戳的字符串 转 DateString ts</span><br>String = <span class="hljs-string">"1556788591462"</span>;<br><span class="hljs-comment">// import java.sql</span><br>Timestamp ts = <span class="hljs-keyword">new</span> Timestamp(Long.parseLong(tsString)); <span class="hljs-comment">// 时间戳的字符串转 Date</span><br>System.out.println(sf.format(ts));<br></code></pre></td></tr></table></figure><p><strong>5 获得昨天此刻时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Calendar calendar = Calendar.getInstance();<br>calendar.add(Calendar.DATE, -<span class="hljs-number">1</span>);<br>System.out.println(calendar.getTime());<br></code></pre></td></tr></table></figure><h3 id="Instant时间戳（Java-8，线程安全）"><a href="#Instant时间戳（Java-8，线程安全）" class="headerlink" title="Instant时间戳（Java 8，线程安全）"></a>Instant时间戳（Java 8，线程安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> milli = Instant.now().toEpochMilli(); <span class="hljs-comment">// 获取当前时间戳（精确到毫秒）</span><br><span class="hljs-keyword">long</span> second = Instant.now().getEpochSecond(); <span class="hljs-comment">// 获取当前时间戳（精确到秒）</span><br>System.out.println(milli);  <span class="hljs-comment">// output:1565932435792</span><br>System.out.println(second); <span class="hljs-comment">// output:1565932435</span><br></code></pre></td></tr></table></figure><p><code>Instant</code>类一般不单独使用，比较常见的用法就是在新老日期键进行转换。Java 8为旧日期类型全部添加了<code>toInstant()</code>方法，可以将日期转换为<code>Instant</code>实例，然后将<code>Instant</code>实例转换为新日期类型。反过来也是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//旧日期转换为新日期</span><br>Date date = <span class="hljs-keyword">new</span> Date();<br>LocalDateTime dateTime = LocalDateTime.ofInstant(date.toInstant(), ZoneId.of(<span class="hljs-string">"Asia/Shanghai"</span>));<br>System.out.println(dateTime);<br><span class="hljs-comment">//新日期转换为旧日期</span><br>Date now = Date.from(Instant.now());<br>System.out.println(now);<br></code></pre></td></tr></table></figure><h3 id="java-time-LocalDate（Java-8，线程安全）"><a href="#java-time-LocalDate（Java-8，线程安全）" class="headerlink" title="java.time.LocalDate（Java 8，线程安全）"></a>java.time.LocalDate（Java 8，线程安全）</h3><ul><li>只包含日期，不包含时间，不可变类，且线程安全。</li><li>经常被用于展示<code>year-month-day,day-of-year,day-of-week,week-of-year</code>等格式的信息。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDate localDate = LocalDate.now();<br><span class="hljs-comment">// 获取当天是几号</span><br><span class="hljs-keyword">int</span> dayOfMonth = localDate.getDayOfMonth();<br><span class="hljs-comment">// 获取当天是星期几</span><br>DayOfWeek dayOfWeek = localDate.getDayOfWeek();<br><span class="hljs-comment">// 获取本月的第一天</span><br>LocalDate firstDayOfMonth = localDate.with(TemporalAdjusters.firstDayOfMonth());<br><span class="hljs-comment">// 取本月最后一天</span><br>LocalDate lastDayOfThisMonth = localDate.with(TemporalAdjusters.lastDayOfMonth());<br></code></pre></td></tr></table></figure><h3 id="java-time-LocalTime（Java-8，线程安全）"><a href="#java-time-LocalTime（Java-8，线程安全）" class="headerlink" title="java.time.LocalTime（Java 8，线程安全）"></a>java.time.LocalTime（Java 8，线程安全）</h3><ul><li>只包含时间，不包含日期，不可变类，且线程安全。</li><li>常被用于展示<code>hour-minute-second</code>格式的信息。可以对时间进行加减等操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 样例</span><br>LocalTime localTime = LocalTime.now();<br><span class="hljs-comment">// 获取当前的小时</span><br><span class="hljs-keyword">int</span> hour = localTime.getHour();<br>System.out.println(hour);<br><span class="hljs-comment">// 小时数加1</span><br>LocalTime addTwoHours = localTime.plusHours(<span class="hljs-number">2L</span>);<br>System.out.println(addTwoHours.getHour());<br><br><span class="hljs-comment">// 结果</span><br><span class="hljs-number">16</span><br><span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><h3 id="java-time-LocalDateTime（Java-8，线程安全）"><a href="#java-time-LocalDateTime（Java-8，线程安全）" class="headerlink" title="java.time.LocalDateTime（Java 8，线程安全）"></a>java.time.LocalDateTime（Java 8，线程安全）</h3><ul><li>既包含了时间又包含了日期，精确到纳秒级别，不可变类，且线程安全。</li><li>操作时间中的年月日时分秒并且可以获取其中的属性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDateTime localDateTime = LocalDateTime.now();<br><span class="hljs-comment">// 获取年</span><br><span class="hljs-keyword">int</span> year = localDateTime.getYear();<br><span class="hljs-comment">// 获取小时</span><br><span class="hljs-keyword">int</span> hour = localDateTime.getHour();<br><span class="hljs-comment">// 增加一年</span><br>LocalDateTime addOneYear = localDateTime.plusYears(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="DateTimeFormatter类"><a href="#DateTimeFormatter类" class="headerlink" title="DateTimeFormatter类"></a>DateTimeFormatter类</h3><p><strong>时间格式化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 时间格式化①</span><br>DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);<br>String timeFormat = dateTimeFormatter.format(LocalDateTime.now());<br>System.out.println(timeFormat);  <span class="hljs-comment">// output:2019-08-16 21:15:43</span><br><span class="hljs-comment">// 时间格式化②</span><br>String timeFormat2 = LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>));<br>System.out.println(timeFormat2);    <span class="hljs-comment">// output:2019-08-16 21:17:48</span><br></code></pre></td></tr></table></figure><p><strong>时间转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String timeStr = <span class="hljs-string">"2019-10-10 06:06:06"</span>;<br>LocalDateTime dateTime = LocalDateTime.parse(timeStr,DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>));<br>System.out.println(dateTime);<br></code></pre></td></tr></table></figure><h3 id="如何优雅地计算两个时间的相隔时间？"><a href="#如何优雅地计算两个时间的相隔时间？" class="headerlink" title="如何优雅地计算两个时间的相隔时间？"></a><strong>如何优雅地计算两个时间的相隔时间？</strong></h3><p>答：JDK 8 中可以使用 Duration 类来优雅地计算两个时间的相隔时间，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDateTime dt1 = LocalDateTime.now();<br>LocalDateTime dt2 = dt1.plusSeconds(<span class="hljs-number">60</span>);<br>Duration duration = Duration.between(dt1, dt2);<br>System.out.println(duration.getSeconds());  <span class="hljs-comment">// output:60</span><br></code></pre></td></tr></table></figure><h3 id="如何优雅地计算两个日期的相隔日期？"><a href="#如何优雅地计算两个日期的相隔日期？" class="headerlink" title="如何优雅地计算两个日期的相隔日期？"></a><strong>如何优雅地计算两个日期的相隔日期？</strong></h3><p>答：JDK 8 中可以使用 Period 类来优雅地计算两个日期的相隔日期，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDate d1 = LocalDate.now();<br>LocalDate d2 = d1.plusDays(<span class="hljs-number">2</span>);<br>Period period = Period.between(d1, d2);<br>System.out.println(period.getDays());   <span class="hljs-comment">//output:2</span><br></code></pre></td></tr></table></figure><h3 id="如何比较两个时间（Date）的大小？"><a href="#如何比较两个时间（Date）的大小？" class="headerlink" title="如何比较两个时间（Date）的大小？"></a><strong>如何比较两个时间（Date）的大小？</strong></h3><p>时间比较有以下三种方式：</p><ul><li>获取两个时间的时间戳，得到两个 long 类型的变量，两个变量相减，通过结果的正负值来判断大小；</li><li>通过 Date 自带的 before()、after()、equals() 等方法比较，代码示例 date1.before(date2)；</li><li>通过 compareTo() 方法比较，代码示例：date1.compareTo(date2)，返回值 -1 表示前一个时间比后一个时间小，0 表示两个时间相等，1 表示前一个时间大于后一个时间。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844904127059738631#heading-35&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.cn/post/6844904127059738631
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://yoursite.com/2021/12/08/Java%E9%9D%A2%E8%AF%95/Redis/"/>
    <id>http://yoursite.com/2021/12/08/Java%E9%9D%A2%E8%AF%95/Redis/</id>
    <published>2021-12-08T09:53:31.000Z</published>
    <updated>2021-12-08T04:07:50.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reddis"><a href="#Reddis" class="headerlink" title="Reddis"></a>Reddis</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="1-什么是-Redis？"><a href="#1-什么是-Redis？" class="headerlink" title="1. 什么是 Redis？"></a><strong>1. 什么是 Redis？</strong></h3><p>Redis 的全称是：Remote Dictionary Server，是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。本质上是一个 Key-Value 类型的内存数据库，很像memcached，<strong>整个数据库统统加载在内存当中进行操作</strong>，定期通过<strong>异步操作</strong>把数据库数据 flush 到硬盘上进行保存。</p><h3 id="2-简述它的优缺点？"><a href="#2-简述它的优缺点？" class="headerlink" title="2.简述它的优缺点？"></a>2.<strong>简述它的优缺点？</strong></h3><p>优点:</p><ul><li>读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。</li><li>支持数据持久化，支持AOF和RDB两种持久化方式。</li><li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li><li>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。</li><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li></ul><p>缺点:</p><ul><li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li><li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li><li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li></ul><h3 id="3-为什么要用-Redis-为什么要用缓存"><a href="#3-为什么要用-Redis-为什么要用缓存" class="headerlink" title="3. 为什么要用 Redis /为什么要用缓存"></a>3. 为什么要用 Redis /为什么要用缓存</h3><p><strong>高性能：</strong></p><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p><p><strong>高并发：</strong></p><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><h3 id="4-为什么要用-Redis-而不用-map-guava-做缓存"><a href="#4-为什么要用-Redis-而不用-map-guava-做缓存" class="headerlink" title="4. 为什么要用 Redis 而不用 map/guava 做缓存?"></a>4. 为什么要用 Redis 而不用 map/guava 做缓存?</h3><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是<strong>本地缓存</strong>，最主要的特点是<strong>轻量以及快速</strong>，<strong>生命周期随着 jvm 的销毁而结束</strong>，并且在多实例的情况下，<strong>每个实例都需要各自保存一份缓存</strong>，<strong>缓存不具有一致性</strong>。</p><p>使用 redis 或 memcached 之类的称为<strong>分布式缓存</strong>，<strong>在多实例的情况下，各实例共用一份缓存数据</strong>，缓存具有一致性。<strong>缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</strong></p><h3 id="5-Redis为什么这么快"><a href="#5-Redis为什么这么快" class="headerlink" title="5. Redis为什么这么快"></a>5. Redis为什么这么快</h3><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。</p><p>2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</p><p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>4、使用多路 I/O 复用模型，非阻塞 IO；</p><p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p><h3 id="6-Redis-与-memcached-相比有哪些优势？"><a href="#6-Redis-与-memcached-相比有哪些优势？" class="headerlink" title="6. Redis 与 memcached 相比有哪些优势？"></a>6. <strong>Redis 与 memcached 相比有哪些优势？</strong></h3><p>两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，Redis 与 Memcached 主要有以下不同：</p><table><thead><tr><th>对比参数</th><th>Redis</th><th>Memcached</th></tr></thead><tbody><tr><td>类型</td><td>1. 支持内存 2. 非关系型数据库</td><td>1. 支持内存 2. 键值对形式 3. 缓存形式</td></tr><tr><td><strong>数据存储类型</strong></td><td>1. String 2. List 3. Set 4. Hash 5. Sort Set 【俗称ZSet】</td><td>1. 文本型 2. 二进制类型</td></tr><tr><td>查询【操作】类型</td><td>1. 批量操作 2. 事务支持 3. 每个类型不同的CRUD</td><td>1.常用的CRUD 2. 少量的其他命令</td></tr><tr><td>附加功能</td><td>1. 发布/订阅模式 2. 主从分区 3. 序列化支持 4. 脚本支持【Lua脚本】</td><td>1. 多线程服务支持</td></tr><tr><td><strong>网络IO模型</strong></td><td>1. 单线程的多路 IO 复用模型</td><td>1. 多线程，非阻塞IO模式</td></tr><tr><td>事件库</td><td>自封转简易事件库AeEvent</td><td>贵族血统的LibEvent事件库</td></tr><tr><td><strong>持久化支持</strong></td><td>1. RDB 2. AOF</td><td>不支持</td></tr><tr><td><strong>集群模式</strong></td><td>原生支持 cluster 模式，可以实现主从复制，读写分离</td><td>没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</td></tr><tr><td>内存管理机制</td><td>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘</td><td>Memcached 的数据则会一直在内存中，Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</td></tr><tr><td><strong>适用场景</strong></td><td>复杂数据结构，有持久化，高可用需求，value存储内容较大</td><td>纯key-value，数据量非常大，并发量非常大的业务</td></tr></tbody></table><p>1.memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型</p><p>2.redis 的速度比 memcached 快很多。</p><p>3.redis 可以持久化其数据 </p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="7-Redis有哪些数据类型"><a href="#7-Redis有哪些数据类型" class="headerlink" title="==7. Redis有哪些数据类型=="></a>==7. Redis有哪些数据类型==</h3><p>Redis主要有5种数据类型，包括String，List，Set，Zset，Hash。</p><p>底层：</p><p>String (简单动态字符串(SDS)),</p><p>List(双端链表),</p><p>Hash(字典，拉链法（压缩，扩展）)，</p><p>Set（整数小于512使用intSet，字典），</p><p>SortedSet(zipList空间站位，字典+跳跃表)</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>可以存储的值</strong></th><th><strong>操作</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td>STRING</td><td>字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作，<br />对整数和浮点数执行自增或者自减操作</td><td>做简单的键值对缓存</td></tr><tr><td>LIST</td><td>列表</td><td>从两端压入或者弹出元素 <br />对单个或者多个元素进行修剪， 只保留一个范围内的元素</td><td>存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据</td></tr><tr><td>SET</td><td>无序集合</td><td>添加、获取、移除单个元素 <br />检查一个元素是否存在于集合中 <br />计算交集、并集、差集 <br />从集合里面随机获取元素</td><td>交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集</td></tr><tr><td>ZSET</td><td>有序集合</td><td>添加、获取、删除元素 <br />根据分值范围或者成员来获取元素 <br />计算一个键的排名</td><td>去重但可以排序，如获取排名前几名的用户</td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对 <br />获取所有键值对 <br />检查某个键是否存在</td><td>结构化的数据，比如一个对象</td></tr></tbody></table><p>高级的4种：</p><ul><li>HyperLogLog：通常用于基数统计。使用少量固定大小的内存，来统计集合中唯一元素的数量。统计结果不是精确值，而是一个带有0.81%标准差（standard error）的近似值。所以，HyperLogLog适用于一些对于统计结果精确度要求不是特别高的场景，例如网站的UV统计。</li><li>Geo：redis 3.2 版本的新特性。可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作：获取2个位置的距离、根据给定地理位置坐标获取指定范围内的地理位置集合。</li><li>Bitmap：位图。</li><li>Stream：主要用于消息队列，类似于 kafka，可以认为是 pub/sub 的改进版。提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</li></ul><h3 id="8-Redis的应用场景"><a href="#8-Redis的应用场景" class="headerlink" title="==8. Redis的应用场景=="></a>==8. Redis的应用场景==</h3><h4 id="总结一"><a href="#总结一" class="headerlink" title="总结一"></a>总结一</h4><p><strong>计数器</strong></p><p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p><p><strong>缓存</strong></p><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p><p><strong>会话缓存</strong></p><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p><p><strong>全页缓存（FPC）</strong></p><p>除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p><p><strong>查找表</strong></p><p>例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。<strong>但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源</strong>。</p><p><strong>消息队列(发布/订阅功能)</strong></p><p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</p><p><strong>分布式锁实现</strong></p><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p><p><strong>其它</strong></p><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p><h4 id="总结二"><a href="#总结二" class="headerlink" title="总结二"></a><strong>总结二</strong></h4><p>Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。</p><p>string——适合最简单的k-v存储，类似于memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储。</p><p>hash——一般key为ID或者唯一标示，value对应的就是详情了。如商品详情，个人信息详情，新闻详情等。</p><p>list——因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为list是有序的，适合根据写入的时间来排序，如：最新的***，消息队列等。</p><p>set——可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set最牛的地方在于，可以对两个set提供交集、并集、差集操作。例如：查找两个人共同的好友等。</p><p>Sorted Set——是set的增强版本，增加了一个score参数，自动会根据score的值进行排序。比较适合类似于top 10等不根据插入的时间来排序的数据。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="9-什么是Redis持久化？"><a href="#9-什么是Redis持久化？" class="headerlink" title="9. 什么是Redis持久化？"></a>9. 什么是Redis持久化？</h3><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p><h3 id="10-Redis-的持久化机制是什么？各自的优缺点"><a href="#10-Redis-的持久化机制是什么？各自的优缺点" class="headerlink" title="==10. Redis 的持久化机制是什么？各自的优缺点=="></a>==10. Redis 的持久化机制是什么？各自的优缺点==</h3><p>Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制:</p><h4 id="RDB：是Redis-DataBase缩写快照"><a href="#RDB：是Redis-DataBase缩写快照" class="headerlink" title="RDB：是Redis DataBase缩写快照"></a><strong>RDB：是Redis DataBase缩写快照</strong></h4><p>RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx52half1tj30gm03idg5.jpg" alt="img"></p><p>优点：</p><ol><li>只有一个文件 dump.rdb，方便持久化。</li><li>容灾性好，一个文件可以保存到安全的磁盘。</li><li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li><li>相对于数据集大时，比 AOF 的启动效率更高。</li></ol><p>缺点：</p><ol><li>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</li><li>AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。</li></ol><h4 id="AOF：持久化"><a href="#AOF：持久化" class="headerlink" title="AOF：持久化"></a>AOF：持久化</h4><p>AOF持久化(即Append Only File持久化)，则是将Redis执行的每次<strong>写命令记录到单独的日志文件中</strong>，<strong>当重启Redis会重新将持久化的日志中文件恢复数据。</strong></p><p>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx52jdijajj30fo066mxk.jpg" alt="img"></p><p>优点：</p><ol><li><strong>数据安全</strong>，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 aof 文件中一次。</li><li>通过 append 模式写文件，即使中途服务器宕机，可以<strong>通过 redis-check-aof 工具解决数据一致性问题</strong>。</li><li>AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</li></ol><p>缺点：</p><ol><li>AOF 文件比 RDB 文件大，且恢复速度慢。</li><li>数据集大的时候，比 rdb 启动效率低。</li></ol><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li>AOF文件比RDB更新频率高，优先使用AOF还原数据。</li><li>AOF比RDB更安全也更大</li><li>RDB性能比AOF好</li><li>如果两个都配了优先加载AOF</li></ul><h3 id="11-如何选择合适的持久化方式"><a href="#11-如何选择合适的持久化方式" class="headerlink" title="11. 如何选择合适的持久化方式"></a>11. 如何选择合适的持久化方式</h3><ul><li><p>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</p></li><li><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</p></li><li><p>有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。</p></li><li><p>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</p></li></ul><h3 id="12-Redis持久化数据和缓存怎么做扩容？"><a href="#12-Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="12. Redis持久化数据和缓存怎么做扩容？"></a>12. Redis持久化数据和缓存怎么做扩容？</h3><ul><li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li><li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li></ul><h2 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h2><h3 id="13-Redis的过期键的删除策略"><a href="#13-Redis的过期键的删除策略" class="headerlink" title="==13. Redis的过期键的删除策略=="></a>==13. Redis的过期键的删除策略==</h3><p>过期策略通常有以下三种：</p><ul><li><strong>定时过期</strong>：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li><li><strong>惰性过期</strong>：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li><li><strong>定期过期</strong>：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)<br><strong>Redis中同时使用了惰性过期和定期过期。</strong></li></ul><h3 id="14-Redis-key的过期时间和永久有效分别怎么设置？"><a href="#14-Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="14. Redis key的过期时间和永久有效分别怎么设置？"></a>14. Redis key的过期时间和永久有效分别怎么设置？</h3><p>EXPIRE和PERSIST命令。</p><h3 id="15-我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢"><a href="#15-我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢" class="headerlink" title="15. 我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?"></a>15. 我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?</h3><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p><ol><li>定时去清理过期的缓存；</li><li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li></ol><p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！</p><h2 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h2><h3 id="16-MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#16-MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="16. MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"></a>16. MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</h3><p>redis内存数据集大小上升到一定大小的时候，就会施行<strong>数据淘汰策略</strong>。</p><h3 id="17-Redis的内存淘汰策略有哪些"><a href="#17-Redis的内存淘汰策略有哪些" class="headerlink" title="==17. Redis的内存淘汰策略有哪些=="></a>==17. Redis的内存淘汰策略有哪些==</h3><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p><p><strong>全局的键空间选择性移除</strong></p><ul><li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（<strong>最常用</strong>）</li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li></ul><p><strong>设置过期时间的键空间选择性移除</strong></p><ul><li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li></ul><p><strong>总结</strong></p><p>Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p><h3 id="18-Redis主要消耗什么物理资源？"><a href="#18-Redis主要消耗什么物理资源？" class="headerlink" title="18. Redis主要消耗什么物理资源？"></a>18. Redis主要消耗什么物理资源？</h3><p>内存</p><h3 id="19-Redis的内存用完了会发生什么？"><a href="#19-Redis的内存用完了会发生什么？" class="headerlink" title="19. Redis的内存用完了会发生什么？"></a>19. Redis的内存用完了会发生什么？</h3><p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p><h3 id="20-Redis如何做内存优化？"><a href="#20-Redis如何做内存优化？" class="headerlink" title="==20. Redis如何做内存优化？=="></a>==20. Redis如何做内存优化？==</h3><p>可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面</p><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="21-Redis线程模型"><a href="#21-Redis线程模型" class="headerlink" title="21. Redis线程模型"></a>21. Redis线程模型</h3><p>redis 4.0 之前，redis 是<strong>完全单线程的</strong>。</p><p>redis 4.0 时，redis 引入了多线程，但是<strong>额外的线程只是用于后台处理</strong>，例如：删除对象，核心流程还是完全单线程的。这也是为什么有些人说 4.0 是单线程的，因为他们指的是核心流程是单线程的。</p><p>redis 6.0 中，<strong>多线程主要用于网络 I/O 阶段</strong>，要去Conf文件里面配置，也就是接收命令和写回结果阶段，而在执行命令阶段，还是由单线程串行执行。由于执行时还是串行，因此无需考虑并发安全问题。</p><p>值得注意的时，redis 中的多线程组不会同时存在“读”和“写”，这个多线程组只会同时“读”或者同时“写”。</p><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。<strong>因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</strong></p><ul><li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="22-什么是事务？"><a href="#22-什么是事务？" class="headerlink" title="22. 什么是事务？"></a>22. 什么是事务？</h3><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。<br>事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><h3 id="23-Redis事务的概念"><a href="#23-Redis事务的概念" class="headerlink" title="==23. Redis事务的概念=="></a>==23. Redis事务的概念==</h3><p>Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><p>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p><h3 id="24-Redis事务的三个阶段"><a href="#24-Redis事务的三个阶段" class="headerlink" title="24. Redis事务的三个阶段"></a>24. Redis事务的三个阶段</h3><ol><li>事务开始 MULTI</li><li>命令入队</li><li>事务执行 EXEC</li></ol><p>事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队</p><h3 id="25-Redis事务相关命令"><a href="#25-Redis事务相关命令" class="headerlink" title="==25. Redis事务相关命令=="></a>==25. Redis事务相关命令==</h3><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p><p>Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p><ol><li>redis <strong>不支持回滚</strong>，“<strong>Redis 在事务失败时不进行回滚，而是继续执行余下的命令</strong>”， 所以 Redis 的内部可以保持简单且快速。</li><li>如果在一个事务中的命令出现错误，那么所有的命令都不会执行；</li><li>如果在一个事务中出现运行错误，那么正确的命令会被执行。</li></ol><ul><li><strong>WATCH</strong> 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li><li><strong>MULTI</strong>命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li><li><strong>EXEC</strong>：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil </li><li><strong>DISCARD</strong>，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</li><li><strong>UNWATCH</strong>命令可以取消watch对所有key的监控。</li></ul><h3 id="26-事务管理（ACID）概述"><a href="#26-事务管理（ACID）概述" class="headerlink" title="26. 事务管理（ACID）概述"></a>26. 事务管理（ACID）概述</h3><p><strong>原子性</strong>（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p><p><strong>一致性</strong>（Consistency）<br>事务前后数据的完整性必须保持一致。</p><p><strong>隔离性</strong>（Isolation）<br>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</p><p><strong>持久性</strong>（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p><p><strong>==Redis的事务总是具有ACID中的一致性和隔离性==</strong>，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p><h3 id="27-Redis事务支持隔离性吗"><a href="#27-Redis事务支持隔离性吗" class="headerlink" title="27. Redis事务支持隔离性吗"></a>27. Redis事务支持隔离性吗</h3><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</p><h3 id="28-Redis事务保证原子性吗，支持回滚吗"><a href="#28-Redis事务保证原子性吗，支持回滚吗" class="headerlink" title="==28. Redis事务保证原子性吗，支持回滚吗=="></a>==28. Redis事务保证原子性吗，支持回滚吗==</h3><p>Redis中，单条命令是原子性执行的，但<strong>事务不保证原子性，且没有回滚</strong>。事务中任意命令执行失败，其余的命令仍会被执行。</p><h3 id="29-Redis事务其他实现"><a href="#29-Redis事务其他实现" class="headerlink" title="29. Redis事务其他实现"></a>29. Redis事务其他实现</h3><p>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，<br><strong>其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</strong><br>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐</p><h2 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h2><h3 id="30-哨兵模式"><a href="#30-哨兵模式" class="headerlink" title="==30. 哨兵模式=="></a>==30. 哨兵模式==</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx5gna6tp9j30nj0j9765.jpg" alt="img"></p><p><strong>哨兵的介绍</strong></p><p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：</p><ul><li>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</li><li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li><li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li><li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li></ul><p><strong>哨兵用于实现 redis 集群的高可用</strong>，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p><ul><li><p>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</p></li><li><p>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</p></li></ul><p>==<strong>哨兵的核心知识</strong>==</p><ul><li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li><li>哨兵 + redis 主从的部署架构，是<strong>不保证数据零丢失</strong>的，只能保证 redis 集群的高可用性。</li><li>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li></ul><h3 id="31-官方Redis-Cluster-方案-服务端路由查询，hash槽"><a href="#31-官方Redis-Cluster-方案-服务端路由查询，hash槽" class="headerlink" title="31. 官方Redis Cluster 方案(服务端路由查询，hash槽)"></a>31. 官方Redis Cluster 方案(服务端路由查询，hash槽)</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx5gsuk2ljj30kq07twf4.jpg" alt="img"></p><p><strong>简介</strong></p><p>Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。Redis Cluster并没有使用一致性hash，而是采用slot(槽)的概念，一共分成<strong>==16384==</strong>个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行</p><p><strong>方案说明</strong></p><ol><li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位</li><li>每份数据分片会存储在多个互为主从的多节点上</li><li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</li><li>同一分片多个节点间的数据不保持一致性<br>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点<br>扩容时时需要需要把旧节点的数据迁移一部分到新节点</li></ol><p>在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w 的端口号，比如 16379。</p><p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间</p><p><strong>节点间的内部通信机制</strong></p><p>基本通信原理</p><p>集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。</p><p><strong>分布式寻址算法</strong></p><ul><li>hash 算法（大量缓存重建）</li><li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li><li>redis cluster 的 hash slot 算法</li></ul><p><strong>优点</strong>:</p><ul><li>无中心架构，支持动态扩容，对业务透明</li><li>具备Sentinel的监控和自动Failover(故障转移)能力</li><li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可</li><li>高性能，客户端直连redis服务，免去了proxy代理的损耗</li></ul><p><strong>缺点</strong>:</p><ul><li>运维也很复杂，数据迁移需要人工干预</li><li>只能使用0号数据库</li><li>不支持批量操作(pipeline管道操作)</li><li>分布式逻辑和存储模块耦合等</li></ul><h3 id="32-基于客户端分配"><a href="#32-基于客户端分配" class="headerlink" title="32. 基于客户端分配"></a>32. 基于客户端分配</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx5lsc44suj30fc0aymxe.jpg" alt="img"></p><p><strong>简介</strong></p><p>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool</p><p><strong>优点</strong></p><ul><li>优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强</li></ul><p><strong>缺点</strong></p><ul><li>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</li><li>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化</li></ul><h3 id="33-基于代理服务器分片"><a href="#33-基于代理服务器分片" class="headerlink" title="33. 基于代理服务器分片"></a>33. 基于代理服务器分片</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx5lwrysk7j30e10azmxc.jpg" alt="img"></p><p><strong>简介</strong></p><p>客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端</p><p><strong>特征</strong></p><ul><li>透明接入，业务程序不用关心后端Redis实例，切换成本低</li><li>Proxy 的逻辑和存储的逻辑是隔离的</li><li>代理层多了一次转发，性能有所损耗</li></ul><p><strong>业界开源方案</strong></p><p>Twtter开源的Twemproxy，豌豆荚开源的Codis</p><h3 id="34-Redis-主从架构"><a href="#34-Redis-主从架构" class="headerlink" title="==34. Redis 主从架构=="></a>==34. Redis 主从架构==</h3><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑<strong>读高并发</strong>的。因此架构做成主从(master-slave)架构，一主多从，<strong>主负责写</strong>，并且将数据复制到其它的 slave 节点，<strong>从节点负责读。所有的读请求全部走从节点</strong>。这样也可以很轻松实现水平扩容，<strong>支撑读高并发</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx5m08a3qbj30dj09taa7.jpg" alt="redis-master-slave"></p><p>redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p><p><strong>redis replication 的核心机制</strong></p><ul><li>redis 采用<strong>异步方式</strong>复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li><li>一个 master node 是可以配置多个 slave node 的；</li><li>slave node 也可以连接其他的 slave node；</li><li>slave node 做复制的时候，不会 block master node 的正常工作；</li><li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li><li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li></ul><p>注意，如果采用了主从架构，那么建议必须<strong>开启 master node 的持久化</strong>，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p><p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能<strong>确保启动的时候，是有数据的</strong>，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p><p>==<strong>redis 主从复制(主从同步)的核心原理</strong>==</p><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。</p><p>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，</p><p>同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会<strong>先写入本地磁盘，然后再从本地磁盘加载到内存中，</strong></p><p>接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</p><p>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx5m74xrroj30ka06iglq.jpg" alt="redis-master-slave-replication"></p><p><strong>过程原理</strong></p><ol><li>当从库和主库建立MS关系后，会向主数据库发送SYNC命令</li><li>主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存起来</li><li>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis</li><li>从Redis接收到后，会载入快照文件并且执行收到的缓存的命令</li><li>之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致</li></ol><p><strong>缺点</strong></p><p>所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决</p><h3 id="35-Redis集群的主从复制模型是怎样的？"><a href="#35-Redis集群的主从复制模型是怎样的？" class="headerlink" title="35. Redis集群的主从复制模型是怎样的？"></a>35. Redis集群的主从复制模型是怎样的？</h3><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品</p><h3 id="36-生产环境中的-redis-是怎么部署的？"><a href="#36-生产环境中的-redis-是怎么部署的？" class="headerlink" title="36. 生产环境中的 redis 是怎么部署的？"></a>36. 生产环境中的 redis 是怎么部署的？</h3><p>redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求/s。</p><p>机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是10g内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p><p>5 台机器对外提供读写，一共有 50g 内存。</p><p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。</p><p>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</p><h3 id="37-说说Redis哈希槽的概念？"><a href="#37-说说Redis哈希槽的概念？" class="headerlink" title="==37. 说说Redis哈希槽的概念？=="></a>==37. 说说Redis哈希槽的概念？==</h3><p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有<strong>==16384==</strong>个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p><h3 id="38-Redis集群会有写操作丢失吗？为什么？"><a href="#38-Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="==38. Redis集群会有写操作丢失吗？为什么？=="></a>==38. Redis集群会有写操作丢失吗？为什么？==</h3><p>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p><h3 id="39-Redis集群之间是如何复制的？"><a href="#39-Redis集群之间是如何复制的？" class="headerlink" title="39. Redis集群之间是如何复制的？"></a>39. Redis集群之间是如何复制的？</h3><p>异步复制</p><h3 id="40-Redis集群最大节点个数是多少？"><a href="#40-Redis集群最大节点个数是多少？" class="headerlink" title="40. Redis集群最大节点个数是多少？"></a>40. Redis集群最大节点个数是多少？</h3><p>16384个</p><h3 id="41-Redis集群如何选择数据库？"><a href="#41-Redis集群如何选择数据库？" class="headerlink" title="41. Redis集群如何选择数据库？"></a>41. Redis集群如何选择数据库？</h3><p>Redis集群目前无法做数据库选择，默认在0数据库。</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="42-Redis是单线程的，如何提高多核CPU的利用率？"><a href="#42-Redis是单线程的，如何提高多核CPU的利用率？" class="headerlink" title="42. Redis是单线程的，如何提高多核CPU的利用率？"></a>42. Redis是单线程的，如何提高多核CPU的利用率？</h3><p>可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。</p><h3 id="43-为什么要做Redis分区？"><a href="#43-为什么要做Redis分区？" class="headerlink" title="43. 为什么要做Redis分区？"></a>43. 为什么要做Redis分区？</h3><p>分区可以让Redis<strong>管理更大的内存</strong>，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p><h3 id="44-你知道有哪些Redis分区实现方案？"><a href="#44-你知道有哪些Redis分区实现方案？" class="headerlink" title="==44. 你知道有哪些Redis分区实现方案？=="></a>==44. 你知道有哪些Redis分区实现方案？==</h3><ul><li><strong>客户端分区</strong>就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。</li><li><strong>代理分区</strong>意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy</li><li>查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</li></ul><h3 id="45-Redis分区有什么缺点？"><a href="#45-Redis分区有什么缺点？" class="headerlink" title="45. Redis分区有什么缺点？"></a>45. Redis分区有什么缺点？</h3><ul><li>涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li><li>同时操作多个key,则不能使用Redis事务.</li><li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集</li><li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。</li><li>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</li></ul><h2 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h2><h3 id="46-Redis实现分布式锁"><a href="#46-Redis实现分布式锁" class="headerlink" title="==46. Redis实现分布式锁=="></a>==46. Redis实现分布式锁==</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。</p><p>当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则 SETNX 不做任何动作</p><p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><p>返回值：设置成功，返回 1 。设置失败，返回 0 。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx66us7msnj30gh059q35.jpg" alt="img"></p><p>使用SETNX完成同步锁的流程及事项如下：</p><p>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功</p><p>为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间</p><p>释放锁，使用DEL命令将锁数据删除</p><h3 id="47-如何解决-Redis-的并发竞争-Key-问题"><a href="#47-如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="==47. 如何解决 Redis 的并发竞争 Key 问题=="></a>==47. 如何解决 Redis 的并发竞争 Key 问题==</h3><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p><p>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p><p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p><h3 id="48-分布式Redis是前期做还是后期规模上来了再做好？为什么？"><a href="#48-分布式Redis是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="48. 分布式Redis是前期做还是后期规模上来了再做好？为什么？"></a>48. 分布式Redis是前期做还是后期规模上来了再做好？为什么？</h3><p>既然Redis是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p><p>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p><p>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p><h3 id="49-什么是-RedLock"><a href="#49-什么是-RedLock" class="headerlink" title="==49. 什么是 RedLock=="></a>==49. 什么是 RedLock==</h3><p>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 Redlock，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p><ul><li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li><li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</li><li>容错性：只要大部分 Redis 节点存活就可以正常提供服务</li></ul><h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><h3 id="50-缓存雪崩"><a href="#50-缓存雪崩" class="headerlink" title="==50. 缓存雪崩=="></a>==50. 缓存雪崩==</h3><p><strong>缓存雪崩</strong>是指缓存同一时间<strong>大面积的失效</strong>，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p><strong>解决方案</strong></p><ol><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li><li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</li><li>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</li></ol><h3 id="51-缓存穿透"><a href="#51-缓存穿透" class="headerlink" title="==51. 缓存穿透=="></a>==51. 缓存穿透==</h3><p><strong>缓存穿透</strong>是指缓存和数据库中<strong>都没有</strong>的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p><strong>解决方案</strong></p><ol><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li><li><strong>==采用布隆过滤器==</strong>，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li></ol><p><strong>附加</strong></p><p>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。<br>Bitmap： 典型的就是哈希表<br>缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p><p>==<strong>布隆过滤器（推荐）</strong>==</p><p><a href="https://juejin.cn/post/6844903982209449991" target="_blank" rel="noopener">https://juejin.cn/post/6844903982209449991</a></p><p>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。<br>优点是空间效率和查询时间都远远超过一般的算法，<br>缺点是有一定的<strong>误识别率</strong>和删除困难。</p><p>Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。<br>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，<strong>如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。</strong>只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。<br><strong>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</strong>布隆过滤器对于不存在的一定能判断，对于存在的有误识别率。</p><h3 id="52-缓存击穿"><a href="#52-缓存击穿" class="headerlink" title="==52. 缓存击穿=="></a>==52. 缓存击穿==</h3><p><strong>缓存击穿</strong>是指缓存中没有但<strong>数据库中有</strong>的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><p><strong>解决方案</strong></p><ol><li>设置热点数据永远不过期。</li><li>加互斥锁。</li></ol><h3 id="53-缓存预热"><a href="#53-缓存预热" class="headerlink" title="==53. 缓存预热=="></a>==53. 缓存预热==</h3><p><strong>缓存预热</strong>就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><p><strong>解决方案</strong></p><ol><li>直接写个缓存刷新页面，上线时手工操作一下；</li><li>数据量不大，可以在项目启动的时候自动进行加载；</li><li>定时刷新缓存</li></ol><h3 id="54-缓存降级"><a href="#54-缓存降级" class="headerlink" title="==54. 缓存降级=="></a>==54. 缓存降级==</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p><p><strong>缓存降级</strong>的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><ol><li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li><li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li><li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li><li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li></ol><p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p><h3 id="55-热点数据和冷数据"><a href="#55-热点数据和冷数据" class="headerlink" title="==55. 热点数据和冷数据=="></a>==55. 热点数据和冷数据==</h3><p>热点数据，缓存才有价值</p><p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存</p><p>对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</p><p>数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p><p>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</p><h3 id="56-缓存热点key"><a href="#56-缓存热点key" class="headerlink" title="==56. 缓存热点key=="></a>==56. 缓存热点key==</h3><p>缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p><strong>解决方案</strong></p><p>对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询</p><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="57-Redis支持的Java客户端都有哪些？官方推荐用哪个？"><a href="#57-Redis支持的Java客户端都有哪些？官方推荐用哪个？" class="headerlink" title="57. Redis支持的Java客户端都有哪些？官方推荐用哪个？"></a>57. Redis支持的Java客户端都有哪些？官方推荐用哪个？</h3><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p><h3 id="58-Redis和Redisson有什么关系？"><a href="#58-Redis和Redisson有什么关系？" class="headerlink" title="58. Redis和Redisson有什么关系？"></a>58. Redis和Redisson有什么关系？</h3><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p><h3 id="59-Jedis与Redisson对比有什么优缺点？"><a href="#59-Jedis与Redisson对比有什么优缺点？" class="headerlink" title="59. Jedis与Redisson对比有什么优缺点？"></a>59. Jedis与Redisson对比有什么优缺点？</h3><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；</p><p>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="60-如何保证缓存与数据库双写时的数据一致性？"><a href="#60-如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="==60. 如何保证缓存与数据库双写时的数据一致性？=="></a>==60. 如何保证缓存与数据库双写时的数据一致性？==</h3><p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</p><p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p><p>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是先更新数据库，然后再删除缓存。</p><table><thead><tr><th align="left">问题场景</th><th>描述</th><th align="left">解决</th></tr></thead><tbody><tr><td align="left">先写缓存，再写数据库，缓存写成功，数据库写失败</td><td>缓存写成功，但写数据库失败或者响应延迟，则下次读取（并发读）缓存时，就出现脏读</td><td align="left">这个写缓存的方式，本身就是错误的，需要改为先写数据库，把旧缓存置为失效；读取数据的时候，如果缓存不存在，则读取数据库再写缓存</td></tr><tr><td align="left">先写数据库，再写缓存，数据库写成功，缓存写失败</td><td>写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据</td><td align="left">缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现</td></tr><tr><td align="left">需要缓存异步刷新</td><td>指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新（补救措施）时候</td><td align="left">确定哪些数据适合此类场景，根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔</td></tr></tbody></table><h3 id="61-Redis常见性能问题和解决方案？"><a href="#61-Redis常见性能问题和解决方案？" class="headerlink" title="==61. Redis常见性能问题和解决方案？=="></a>==61. Redis常见性能问题和解决方案？==</h3><ol><li>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。</li><li>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li><li>为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。</li><li>尽量避免在压力较大的主库上增加从库</li><li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li><li>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。</li></ol><h3 id="62-Redis官方为什么不提供Windows版本？"><a href="#62-Redis官方为什么不提供Windows版本？" class="headerlink" title="62. Redis官方为什么不提供Windows版本？"></a>62. Redis官方为什么不提供Windows版本？</h3><p>因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</p><h3 id="63-一个字符串类型的值能存储最大容量是多少？"><a href="#63-一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="63. 一个字符串类型的值能存储最大容量是多少？"></a>63. 一个字符串类型的值能存储最大容量是多少？</h3><p>512M</p><h3 id="64-Redis如何做大量数据插入？"><a href="#64-Redis如何做大量数据插入？" class="headerlink" title="64. Redis如何做大量数据插入？"></a>64. Redis如何做大量数据插入？</h3><p>Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</p><h3 id="65-假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#65-假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="65. 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>65. 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。<br>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？<br>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h3 id="66-使用Redis做过异步队列吗，是如何实现的"><a href="#66-使用Redis做过异步队列吗，是如何实现的" class="headerlink" title="66. 使用Redis做过异步队列吗，是如何实现的"></a>66. 使用Redis做过异步队列吗，是如何实现的</h3><p>使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis可以通过pub/sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，<strong>当消费者下线时，生产的消息会丢失。</strong></p><h3 id="67-Redis如何实现延时队列"><a href="#67-Redis如何实现延时队列" class="headerlink" title="67. Redis如何实现延时队列"></a>67. Redis如何实现延时队列</h3><p>使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。</p><h3 id="68-Redis回收进程如何工作的？"><a href="#68-Redis回收进程如何工作的？" class="headerlink" title="68. Redis回收进程如何工作的？"></a>68. Redis回收进程如何工作的？</h3><ol><li>一个客户端运行了新的命令，添加了新的数据。</li><li>Redis检查内存使用情况，如果大于maxmemory的限制， 则根据设定好的策略进行回收。</li><li>一个新的命令被执行，等等。</li><li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li></ol><p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p><h3 id="69-Redis回收使用的是什么算法？"><a href="#69-Redis回收使用的是什么算法？" class="headerlink" title="69. Redis回收使用的是什么算法？"></a>69. Redis回收使用的是什么算法？</h3><p>LRU算法(Least Recently Used的缩写，即最近最少使用)</p><h3 id="70-Pipeline有什么好处，为什么要用pipeline？"><a href="#70-Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="70. Pipeline有什么好处，为什么要用pipeline？"></a>70. Pipeline有什么好处，为什么要用pipeline？</h3><p>可以将多次IO往返的时间缩减为一次，前提是<strong>pipeline</strong>执行的指令之间没有因果相关性。使用<strong>redis-benchmark</strong>进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是<strong>pipeline</strong>批次指令的数目</p><h3 id="71-我可以问一下啥是上下文切换么？"><a href="#71-我可以问一下啥是上下文切换么？" class="headerlink" title="==71. 我可以问一下啥是上下文切换么？=="></a>==71. 我可以问一下啥是上下文切换么？==</h3><p>我可以打个比方么：我记得有过一个小伙伴微信问过我上下文切换是啥，为啥可能会线程不安全，我是这么说的，就好比你看一本英文书，你看到第十页发现有个单词不会读，你加了个书签，然后去查字典，过了一会你又回来继续从书签那里读，ok到目前为止没啥问题。</p><p>如果是你一个人读肯定没啥问题，但是你去查的时候，别的小伙伴好奇你在看啥他就翻了一下你的书，然后溜了，哦豁，你再看的时候就发现书不是你看的那一页了。不知道到这里为止我有没有解释清楚，以及为啥会线程不安全，就是因为你一个人怎么看都没事，但是人多了换来换去的操作一本书数据就乱了。可能我的解释很粗糙，但是道理应该是一样的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Reddis&quot;&gt;&lt;a href=&quot;#Reddis&quot; class=&quot;headerlink&quot; title=&quot;Reddis&quot;&gt;&lt;/a&gt;Reddis&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>9.1 B树,B+树插入删除图解 (copy)</title>
    <link href="http://yoursite.com/2021/12/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9.1%20B%E6%A0%91,B+%E6%A0%91%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%9B%BE%E8%A7%A3/"/>
    <id>http://yoursite.com/2021/12/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9.1%20B%E6%A0%91,B+%E6%A0%91%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%9B%BE%E8%A7%A3/</id>
    <published>2021-12-08T04:39:39.000Z</published>
    <updated>2021-12-08T04:02:40.120Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-2-B树插入"><a href="#1-2-B树插入" class="headerlink" title="1.2 B树插入"></a>1.2 B树插入</h4><p>插入的时候，我们需要记住一个规则：<strong>判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。</strong></p><p>例子：在5阶B树中，结点最多有4个key,最少有2个key（注意：下面的节点统一用一个节点表示key和value）。</p><ul><li>插入18，70，50,40</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak8eo65j309h02njra.jpg" alt="img"></p><ul><li>插入22</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nns376j309t02t3yg.jpg" alt="img"></p><p>插入22时，发现这个节点的关键字已经大于4了，所以需要进行分裂，分裂的规则在上面已经讲了，分裂之后，如下。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5np2pe3j30cj05z3yp.jpg" alt="img"></p><ul><li>接着插入23，25，39</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akfwv3cj30g605e74l.jpg" alt="img"></p><p>分裂，得到下面的。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akb91a7j30fv07m0t7.jpg" alt="img"></p><p>更过的插入的过程就不多介绍了，相信有这个例子你已经知道怎么进行插入操作了。</p><h4 id="1-3-B树的删除操作"><a href="#1-3-B树的删除操作" class="headerlink" title="1.3 B树的删除操作"></a>1.3 B树的删除操作</h4><p>B树的删除操作相对于插入操作是相对复杂一些的，但是，你知道记住几种情况，一样可以很轻松的掌握的。</p><ul><li>现在有一个初始状态是下面这样的B树，然后进行删除操作。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akffpjfj30kc09eaay.jpg" alt="img"></p><ul><li>删除15，这种情况是删除叶子节点的元素，如果删除之后，节点数还是大于<code>m/2</code>，这种情况只要直接删除即可。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak7xn76j30kc09zwfg.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak9ef0bj30kc097t9l.jpg" alt="img"></p><ul><li>接着，我们把22删除，这种情况的规则：22是非叶子节点，<strong>对于非叶子节点的删除，我们需要用后继key（元素）覆盖要删除的key，然后在后继key所在的子支中删除该后继key</strong>。对于删除22，需要将后继元素24移到被删除的22所在的节点。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akd800oj30kc0bd3zo.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak7p8itj30kc092756.jpg" alt="img"></p><p>此时发现26所在的节点只有一个元素，小于2个（m/2），这个节点不符合要求，这时候的规则（向兄弟节点借元素）：<strong>如果删除叶子节点，如果删除元素后元素个数少于（m/2），并且它的兄弟节点的元素大于（m/2），也就是说兄弟节点的元素比最少值m/2还多，将先将父节点的元素移到该节点，然后将兄弟节点的元素再移动到父节点</strong>。这样就满足要求了。</p><p>我们看看操作过程就更加明白了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akc4688j30kc092q3x.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akex9s6j30kc094dgp.jpg" alt="img"></p><ul><li>接着删除28，<strong>删除叶子节点</strong>，删除后不满足要求，所以，我们需要考虑向兄弟节点借元素，但是，兄弟节点也没有多的节点（2个），借不了，怎么办呢？如果遇到这种情况，<strong>首先，还是将先将父节点的元素移到该节点，然后，将当前节点及它的兄弟节点中的key合并，形成一个新的节点</strong>。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ake1o66j30kc0arab4.jpg" alt="img"></p><p>移动之后，跟兄弟节点合并。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akastxfj30kc09qaax.jpg" alt="img"></p><p>删除就只有上面的几种情况，根据不同的情况进行删除即可。</p><p>上面的这些介绍，相信对于B树已经有一定的了解了，接下来的一部分，我们接着讲解B+树，我相信加上B+树的对比，就更加清晰明了了。</p><h3 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2 B+树"></a>2 B+树</h3><h4 id="2-1-B-树概述"><a href="#2-1-B-树概述" class="headerlink" title="2.1 B+树概述"></a>2.1 B+树概述</h4><p>B+树其实和B树是非常相似的，我们首先看看<strong>相同点</strong>。</p><ul><li>根节点至少一个元素</li><li>非根节点元素范围：m/2 &lt;= k &lt;= m-1</li></ul><p><strong>不同点</strong>。</p><ul><li>B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。</li><li>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。</li><li>每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。</li><li>父节点存有右孩子的第一个元素的索引。</li></ul><p>下面我们看一个B+树的例子，感受感受它吧！</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak9u8sdj30hg09yjs9.jpg" alt="img"></p><h4 id="2-2-插入操作"><a href="#2-2-插入操作" class="headerlink" title="2.2 插入操作"></a>2.2 插入操作</h4><p>对于插入操作很简单，只需要记住一个技巧即可：<strong>当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的</strong>。</p><p>下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。</p><ul><li>插入5，10，15，20</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nstlpxj309s04agll.jpg" alt="img"></p><ul><li>插入25，此时元素数量大于4个了，分裂</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akckyvaj30f206q74l.jpg" alt="img"></p><ul><li>接着插入26，30，继续分裂</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akbns2mj30gq0650t2.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akegiwcj30j306xjrw.jpg" alt="img"></p><p>有了这几个例子，相信插入操作没什么问题了，下面接着看看删除操作。</p><h4 id="2-3-删除操作"><a href="#2-3-删除操作" class="headerlink" title="2.3 删除操作"></a>2.3 删除操作</h4><p>对于删除操作是比B树简单一些的，因为<strong>叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key</strong>，下面我们看看具体的实例。</p><ul><li>初始状态</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akdj5t5j30kc06rq3l.jpg" alt="img"></p><ul><li>删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak8xabpj30kc06s3z5.jpg" alt="img"></p><ul><li>删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akaazg0j30kc07w3z7.jpg" alt="img"></p><ul><li>发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nv4474j30kc080t9g.jpg" alt="img"></p><p>这样，B+树的删除操作也就完成了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-2-B树插入&quot;&gt;&lt;a href=&quot;#1-2-B树插入&quot; class=&quot;headerlink&quot; title=&quot;1.2 B树插入&quot;&gt;&lt;/a&gt;1.2 B树插入&lt;/h4&gt;&lt;p&gt;插入的时候，我们需要记住一个规则：&lt;strong&gt;判断当前结点key的个数是否小于等于m-1
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>9.0 B树,B+树,B*树</title>
    <link href="http://yoursite.com/2021/12/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9.0%20B%E6%A0%91,B+%E6%A0%91,B*%E6%A0%91/"/>
    <id>http://yoursite.com/2021/12/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9.0%20B%E6%A0%91,B+%E6%A0%91,B*%E6%A0%91/</id>
    <published>2021-12-08T04:38:39.000Z</published>
    <updated>2021-12-08T04:03:13.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><h2 id="B-树概述"><a href="#B-树概述" class="headerlink" title="B-树概述"></a>B-树概述</h2><p>B-树,这里的 B 表示 balance( 平衡的意思),B-树是一种多路自平衡的搜索树（B树是<strong>一颗多路平衡查找树</strong>）<br>它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。下图是 B-树的简化图.</p><p><img src="https:////upload-images.jianshu.io/upload_images/1446087-bc023e47bc74cfa1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p><h2 id="为什么数据库s需要用B树，而不是用AVL树，二叉树？"><a href="#为什么数据库s需要用B树，而不是用AVL树，二叉树？" class="headerlink" title="为什么数据库s需要用B树，而不是用AVL树，二叉树？"></a>为什么数据库s需要用B树，而不是用AVL树，二叉树？</h2><p>传统用来搜索的平衡二叉树有很多，如 AVL 树，红黑树等。这些树在一般情况下查询性能非常好，但当数据非常大的时候它们就无能为力了。<strong>原因当数据量非常大时，内存不够用，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。</strong>一般而言内存访问的时间约为 50 ns，而磁盘在 10 ms 左右。速度相差了近 5 个数量级，磁盘读取时间远远超过了数据在内存中比较的时间。这说明程序大部分时间会阻塞在磁盘 IO 上。</p><p><strong>B-树是专门为外部存储器设计的，如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中。</strong></p><h2 id="B树规则："><a href="#B树规则：" class="headerlink" title="B树规则："></a>B树规则：</h2><p>（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则（类似AVL）。</p><p>（2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外。（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</p><p>（3）关键字数：枝节点的<strong>关键字数量大于等于ceil(m/2)-1个且小于等于M-1个</strong>（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</p><p>（4）<strong>所有叶子节点均在同一层</strong>、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null。</p><h3 id="如：（M-3）"><a href="#如：（M-3）" class="headerlink" title="如：（M=3）"></a>如：（M=3）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6aimasktj30hc07gmxn.jpg" alt="img"></p><h2 id="B树有如下特点"><a href="#B树有如下特点" class="headerlink" title="B树有如下特点:"></a>B树有如下特点:</h2><ol><li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；</li><li>在关键字全集内做一次查找,性能逼近二分查找；</li><li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li><li>自动层次控制；</li></ol><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><h2 id="B-树的定义"><a href="#B-树的定义" class="headerlink" title="B+树的定义"></a>B+树的定义</h2><p><strong>B+树是应文件系统所需而出的一种B-树的变型树。一棵m阶的B+树和m阶的B-树的差异在于：</strong></p><p>1.有n棵子树的结点中含有n个关键字，<strong>==每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点==</strong>。</p><p>2.<strong>所有的叶子结点中包含了全部关键字的信息</strong>，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p>3.所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</p><h2 id="B-树规则："><a href="#B-树规则：" class="headerlink" title="B+树规则："></a>B+树规则：</h2><p>（1）B+跟B树不同B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</p><p>（2）B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有关键字都在叶子结点出现；所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</p><p>（3）B+树叶子节点的关键字从小到大有序排列，<strong>左边结尾数据都会保存右边节点开始数据的指针</strong>。</p><p>（4）<strong>非叶子节点的子节点数=关键字数（来源百度百科）</strong>（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</p><h3 id="如：（M-3）-1"><a href="#如：（M-3）-1" class="headerlink" title="如：（M=3）"></a>如：（M=3）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ailuqs1j30ft09lgmd.jpg" alt="img"></p><p>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在</p><p>非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p><h2 id="B-的特性："><a href="#B-的特性：" class="headerlink" title="B+的特性："></a>B+的特性：</h2><p>1、B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</p><p>2、B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p><p>3、B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</p><p>4、B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p><h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h1><p><strong>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ailnqmvj30ft09l0tk.jpg" alt="img"></p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a><strong>规则</strong></h2><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p><p>（1）首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b<em>树的初始化个数为（cei(2/3</em>m)）</p><p>（2）B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h2><p>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；</p><h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><p><strong>B-树：</strong></p><p>多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；</p><p>所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p><p><strong>B+树：</strong></p><p>在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；</p><p>B+树总是到叶子结点才命中；</p><p><strong>B*树：</strong></p><p>在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;B树&quot;&gt;&lt;a href=&quot;#B树&quot; class=&quot;headerlink&quot; title=&quot;B树&quot;&gt;&lt;/a&gt;B树&lt;/h1&gt;&lt;h2 id=&quot;B-树概述&quot;&gt;&lt;a href=&quot;#B-树概述&quot; class=&quot;headerlink&quot; title=&quot;B-树概述&quot;&gt;&lt;/a&gt;B-树概
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/Nginx/"/>
    <id>http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/Nginx/</id>
    <published>2021-11-29T09:53:31.000Z</published>
    <updated>2021-11-29T09:57:43.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p><strong>正向代理</strong>隐藏真实客户端，<strong>反向代理</strong>隐藏真实服务端，</p><p>正向代理隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，比如VPN。</p><p>反向代理客户不知道真正提供服务人的是谁，比如访问<a href="http://www.baidu.com，不知道具体哪个服务器提供服务。主要用于负载均衡。" target="_blank" rel="noopener">www.baidu.com，不知道具体哪个服务器提供服务。主要用于负载均衡。</a></p><h4 id="1-什么是Nginx？"><a href="#1-什么是Nginx？" class="headerlink" title="1. 什么是Nginx？"></a>1. 什么是Nginx？</h4><p>Nginx是一个 轻量级/高性能的反向代理Web服务器，他实现非常高效的反向代理、负载平衡，他可以处理2-3万并发连接数，官方监测能支持5万并发，现在中国使用nginx网站用户有很多，例如：新浪、网易、 腾讯等。</p><h4 id="2-为什么要用Nginx？"><a href="#2-为什么要用Nginx？" class="headerlink" title="2. 为什么要用Nginx？"></a>2. 为什么要用Nginx？</h4><ul><li><strong>跨平台、配置简单、反向代理、高并发连接</strong>：处理2-3万并发连接数，官方监测能支持5万并发，内存消耗小：开启10个nginx才占150M内存 ，nginx处理静态文件好，耗费内存少</li><li><strong>健康检查功能</strong>：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。</li></ul><h4 id="3-为什么Nginx性能这么高？"><a href="#3-为什么Nginx性能这么高？" class="headerlink" title="==3. 为什么Nginx性能这么高？=="></a>==3. 为什么Nginx性能这么高？==</h4><p>因为他的事件处理机制：异步非阻塞事件处理机制：运用了epoll模型，提供了一个队列，排队解决</p><h4 id="4-Nginx怎么处理请求的？"><a href="#4-Nginx怎么处理请求的？" class="headerlink" title="==4. Nginx怎么处理请求的？=="></a>==4. Nginx怎么处理请求的？==</h4><p>nginx接收一个请求后，首先由listen和server_name指令匹配server模块，再匹配server模块里的location，location就是实际地址</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;                <span class="hljs-comment"># 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>；              <span class="hljs-comment"># 提供服务的端口，默认80</span><br>    server_name  localhost；    <span class="hljs-comment"># 提供服务的域名主机名</span><br>    location / &#123;                     <span class="hljs-comment"># 第一个location区块开始</span><br>        <span class="hljs-attribute">root</span>   html；       <span class="hljs-comment"># 站点的根目录，相当于Nginx的安装目录</span><br>        index  index.html index.htm； <span class="hljs-comment"># 默认的首页文件，多个用空格分开</span><br>    &#125;          <span class="hljs-comment"># 第一个location区块结果</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-Nginx的优缺点？"><a href="#5-Nginx的优缺点？" class="headerlink" title="==5. Nginx的优缺点？=="></a>==5. Nginx的优缺点？==</h4><ul><li>优点：<ol><li>占内存小，可实现高并发连接，处理响应快</li><li>可实现http服务器、虚拟主机、方向代理、负载均衡</li><li>Nginx配置简单</li><li>可以不暴露正式的服务器IP地址</li></ol></li><li>缺点： 动态处理差：nginx处理静态文件好,耗费内存少，但是处理动态页面则很鸡肋，现在一般前端用nginx作为反向代理抗住压力</li></ul><h4 id="6-如何用Nginx解决前端跨域问题？"><a href="#6-如何用Nginx解决前端跨域问题？" class="headerlink" title="6. 如何用Nginx解决前端跨域问题？"></a>6. 如何用Nginx解决前端跨域问题？</h4><p>使用Nginx转发请求。把跨域的接口写成调本域的接口，然后将这些接口转发到真正的请求地址。</p><h3 id="Nginx配置文件nginx-conf有哪些属性模块"><a href="#Nginx配置文件nginx-conf有哪些属性模块" class="headerlink" title="Nginx配置文件nginx.conf有哪些属性模块?"></a>Nginx配置文件nginx.conf有哪些属性模块?</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#Master进程：读取及评估配置和维持</span><br><span class="hljs-comment">#Worker进程：处理请求</span><br><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>；                <span class="hljs-comment"># worker进程的数量</span><br>events &#123;                              <span class="hljs-comment"># 事件区块开始</span><br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>；          <span class="hljs-comment"># 每个worker进程支持的最大连接数</span><br>&#125;                               <span class="hljs-comment"># 事件区块结束</span><br>http &#123;                           <span class="hljs-comment"># HTTP区块开始</span><br>    <span class="hljs-attribute">include</span>       mime.types；         <span class="hljs-comment"># Nginx支持的媒体类型库文件</span><br>    default_type  application/octet-stream；  <span class="hljs-comment"># 默认的媒体类型</span><br>    sendfile        <span class="hljs-literal">on</span>；       <span class="hljs-comment"># 开启高效传输模式</span><br>    keepalive_timeout  <span class="hljs-number">65</span>；       <span class="hljs-comment"># 连接超时</span><br>    server &#123;                            <span class="hljs-comment"># 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>；              <span class="hljs-comment"># 提供服务的端口，默认80</span><br>        server_name  localhost；    <span class="hljs-comment"># 提供服务的域名主机名</span><br>        location / &#123;                    <span class="hljs-comment"># 第一个location区块开始</span><br>            <span class="hljs-attribute">root</span>   html；       <span class="hljs-comment"># 站点的根目录，相当于Nginx的安装目录</span><br>            index  index.html index.htm；       <span class="hljs-comment"># 默认的首页文件，多个用空格分开</span><br>        &#125;                  <span class="hljs-comment"># 第一个location区块结果</span><br>        error_page   <span class="hljs-number">500502503504</span>  /50x.html；    <span class="hljs-comment"># 出现对应的http状态码时，使用50x.html回应客户</span><br>        location = /50x.html &#123;                  <span class="hljs-comment"># location区块开始，访问50x.html</span><br>            <span class="hljs-attribute">root</span>   html；                    <span class="hljs-comment"># 指定对应的站点目录为html</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="7-Nginx虚拟主机怎么配置"><a href="#7-Nginx虚拟主机怎么配置" class="headerlink" title="7. Nginx虚拟主机怎么配置?"></a>7. Nginx虚拟主机怎么配置?</h4><ul><li><p>1、基于域名的虚拟主机，通过域名来区分虚拟主机——应用：外部网站</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#当客户端访问www.lijie.com,监听端口号为80,直接跳转到data/www目录下文件</span><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  www.lijie.com;<br>    <span class="hljs-attribute">location</span> / &#123;<br>        <span class="hljs-attribute">root</span>   data/www;<br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>2、基于端口的虚拟主机，通过端口来区分虚拟主机——应用：公司内部网站，外部网站的管理后台</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#当客户端访问www.lijie.com,监听端口号为8080,直接跳转到data/www目录下文件</span><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">8080</span>;<br>    <span class="hljs-attribute">server_name</span>  <span class="hljs-number">8080</span>.lijie.com;<br>    <span class="hljs-attribute">location</span> / &#123;<br>        <span class="hljs-attribute">root</span>   data/www;<br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>3、基于ip的虚拟主机。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#当客户端访问www.lijie.com,监听端口号为80直接跳转到真实ip服务器地址 127.0.0.1:8080</span><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  www.lijie.com;<br>    <span class="hljs-attribute">location</span> / &#123;<br><span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080;<br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-限流怎么做的？"><a href="#8-限流怎么做的？" class="headerlink" title="==8. 限流怎么做的？=="></a>==8. 限流怎么做的？==</h4><ul><li>Nginx限流就是限制用户请求速度，防止服务器受不了</li><li>限流有3种<ol><li>正常限制访问频率（正常流量）</li><li>突发限制访问频率（突发流量）</li><li>限制并发连接数</li></ol></li><li>Nginx的限流都是基于漏桶流算法</li></ul><h5 id="1、正常限制访问频率（正常流量）："><a href="#1、正常限制访问频率（正常流量）：" class="headerlink" title="1、正常限制访问频率（正常流量）："></a>1、正常限制访问频率（正常流量）：</h5><ul><li><p>限制一个用户发送的请求，我Nginx多久接收一个请求。</p></li><li><p>Nginx中使用ngx_http_limit_req_module模块来限制的访问频率，限制的原理实质是基于漏桶算法原理来实现的。在nginx.conf配置文件中可以使用limit_req_zone命令及limit_req命令限制单个IP的请求处理频率。</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nginx">#定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉<br> #1r/s代表1秒一个请求，1r/m一分钟接收一个请求， 如果Nginx这时还有别人的请求没有处理完，Nginx就会拒绝处理该用户请求。<br>limit_req_zone $binary_remote_addr zone=one:10m rate=1r/m;<br><br>#绑定限流维度<br>server&#123;<br>location/seckill.html&#123;<br>limit_req zone=zone;<br>proxy_pass http://lj_seckill;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、突发限制访问频率（突发流量）："><a href="#2、突发限制访问频率（突发流量）：" class="headerlink" title="2、突发限制访问频率（突发流量）："></a>2、突发限制访问频率（突发流量）：</h5><ul><li>上面的配置一定程度可以限制访问频率，但是也存在着一个问题：如果突发流量超出请求被拒绝处理，无法处理活动时候的突发流量，这时候应该如何进一步处理呢？Nginx提供<strong>burst</strong>参数结合<strong>nodelay</strong>参数可以解决流量突发的问题，可以设置能处理的超过设置的请求数外能额外处理的请求数。我们可以将之前的例子添加burst参数以及nodelay参数：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nginx">#定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉<br>limit_req_zone $binary_remote_addr zone=one:10m rate=1r/m;<br><br>#绑定限流维度<br>server&#123;<br>location/seckill.html&#123;<br>limit_req zone=zone burst=5 nodelay;<br> #为什么就多了一个 burst=5 nodelay; 呢，多了这个可以代表Nginx对于一个用户的请求会立即处理前五个，多余的就慢慢来落，没有其他用户的请求我就处理你的，有其他的请求的话我Nginx就漏掉不接受你的请求<br>proxy_pass http://lj_seckill;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、-限制并发连接数"><a href="#3、-限制并发连接数" class="headerlink" title="3、 限制并发连接数"></a>3、 限制并发连接数</h5><ul><li>Nginx中的ngx_http_limit_conn_module模块提供了限制并发连接数的功能，可以使用limit_conn_zone指令以及limit_conn执行进行配置。接下来我们可以通过一个简单的例子来看下：</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx">  <span class="hljs-section">http</span> &#123;<br><span class="hljs-attribute">limit_conn_zone</span> <span class="hljs-variable">$binary_remote_addr</span> zone=myip:<span class="hljs-number">10m</span>;<br><span class="hljs-attribute">limit_conn_zone</span> <span class="hljs-variable">$server_name</span> zone=myServerName:<span class="hljs-number">10m</span>;<br>  &#125;<br><span class="hljs-comment">#配置了单个IP同时并发连接数最多只能10个连接，并且设置了整个虚拟服务器同时最大并发数最多只能100个链接。当然，只有当请求的header被服务器处理后，虚拟服务器的连接数才会计数</span><br>  <span class="hljs-section">server</span> &#123;<br>      <span class="hljs-attribute">location</span> / &#123;<br>          <span class="hljs-attribute">limit_conn</span> myip <span class="hljs-number">10</span>;<br>          <span class="hljs-attribute">limit_conn</span> myServerName <span class="hljs-number">100</span>;<br>          <span class="hljs-attribute">rewrite</span> / http://www.lijie.net <span class="hljs-literal">permanent</span>;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="9-漏桶流算法和令牌桶算法知道？"><a href="#9-漏桶流算法和令牌桶算法知道？" class="headerlink" title="9. 漏桶流算法和令牌桶算法知道？"></a>9. 漏桶流算法和令牌桶算法知道？</h4><h5 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h5><ul><li><p>漏桶算法是网络世界中流量整形或速率限制时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶算法提供了一种机制，通过它，突发流量可以被整形以便为网络提供一个稳定的流量。也就是我们刚才所讲的情况。漏桶算法提供的机制实际上就是刚才的案例：</p><p><strong>突发流量会进入到一个漏桶，漏桶会按照我们定义的速率依次处理请求，如果水流过大也就是突发流量过大就会直接溢出，则多余的请求会被拒绝。所以漏桶算法能控制数据的传输速率。</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gww652vuddj305x07ma9z.jpg" alt="在这里插入图片描述"></p></li></ul><h5 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h5><ul><li>令牌桶算法是网络流量整形和速率限制中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。Google开源项目Guava中的RateLimiter使用的就是令牌桶控制算法。<strong>令牌桶算法的机制如下：存在一个大小固定的令牌桶，会以恒定的速率源源不断产生令牌。如果令牌消耗速率小于生产令牌的速度，令牌就会一直产生直至装满整个令牌桶。</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gww6529s0oj30n70b2wew.jpg" alt="在这里插入图片描述"></p><h4 id="10-为什么要做动静分离？"><a href="#10-为什么要做动静分离？" class="headerlink" title="10. 为什么要做动静分离？"></a>10. 为什么要做动静分离？</h4><ul><li>Nginx是当下最热的Web容器，网站优化的重要点在于静态化网站，网站静态化的关键点则是是动静分离，动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们则根据静态资源的特点将其做缓存操作。</li><li>让静态的资源只走静态资源服务器，动态的走动态的服务器</li><li>Nginx的静态处理能力很强，但是动态处理能力不足，因此，在企业中常用动静分离技术。</li><li>对于静态资源比如图片，js，css等文件，我们则在反向代理服务器nginx中进行缓存。这样浏览器在请求一个静态资源时，代理服务器nginx就可以直接处理，无需将请求转发给后端服务器tomcat。 若用户请求的动态文件，比如servlet,jsp则转发给Tomcat服务器处理，从而实现动静分离。这也是反向代理服务器的一个重要的作用。</li></ul><h5 id="Nginx怎么做的动静分离？"><a href="#Nginx怎么做的动静分离？" class="headerlink" title="Nginx怎么做的动静分离？"></a>Nginx怎么做的动静分离？</h5><ul><li>只需要指定路径对应的目录。location/可以使用正则表达式匹配。并指定对应的硬盘中的目录。</li></ul><h4 id="11-Nginx负载均衡的算法怎么实现的-策略有哪些"><a href="#11-Nginx负载均衡的算法怎么实现的-策略有哪些" class="headerlink" title="==11. Nginx负载均衡的算法怎么实现的?策略有哪些?=="></a>==11. Nginx负载均衡的算法怎么实现的?策略有哪些?==</h4><ul><li><p>为了避免服务器崩溃，Nginx会通过负载均衡的方式来分担服务器压力。将多台服务器组成一个集群，当用户访问时，先访问到一个转发服务器，再由转发服务器将访问分发到压力更小的服务器。</p></li><li><p>Nginx负载均衡实现的策略有以下五种：</p></li></ul><h5 id="1-轮询-默认"><a href="#1-轮询-默认" class="headerlink" title="1. 轮询(默认)"></a>1. 轮询(默认)</h5><ul><li>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某个服务器宕机，能自动剔除故障系统。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> backserver &#123; <br> <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.0.12</span>; <br> <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.0.13</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-权重-weight"><a href="#2-权重-weight" class="headerlink" title="2. 权重 weight"></a>2. 权重 weight</h5><ul><li>weight权重越高，在被访问的概率越大，如下例，分别是20%，80%。</li><li>到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。其次是为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> backserver &#123; <br> <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.0.12</span> weight=<span class="hljs-number">2</span>; <br> <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.0.13</span> weight=<span class="hljs-number">8</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-ip-hash-IP绑定"><a href="#3-ip-hash-IP绑定" class="headerlink" title="3. ip_hash( IP绑定)"></a>3. ip_hash( IP绑定)</h5><ul><li>每个请求按访问IP的哈希结果分配，使来自同一个IP的访客固定访问一台后端服务器，<strong>==并且可以有效解决动态网页存在的session共享问题==</strong></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx">upstream backserver &#123; <br> ip_hash; <br> server 192.168.0.12:88; <br> server 192.168.0.13:80; <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-fair-第三方插件-（略）"><a href="#4-fair-第三方插件-（略）" class="headerlink" title="4. fair(第三方插件) （略）"></a>4. fair(第三方插件) （略）</h5><h5 id="5-url-hash-第三方插件-（略）"><a href="#5-url-hash-第三方插件-（略）" class="headerlink" title="5. url_hash(第三方插件) （略）"></a>5. url_hash(第三方插件) （略）</h5><h4 id="12-Nginx配置高可用性怎么配置？"><a href="#12-Nginx配置高可用性怎么配置？" class="headerlink" title="==12. Nginx配置高可用性怎么配置？=="></a>==12. Nginx配置高可用性怎么配置？==</h4><ul><li>当上游服务器(真实访问服务器)，一旦出现故障或者是没有及时相应的话，应该直接轮训到下一台服务器，保证服务器的高可用</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  www.lijie.com;<br>        <span class="hljs-attribute">location</span> / &#123;<br>    <span class="hljs-comment">### 指定上游服务器负载均衡服务器</span><br>    <span class="hljs-attribute">proxy_pass</span> http://backServer;<br><span class="hljs-comment">###nginx与上游服务器(真实访问的服务器)超时时间 后端服务器连接的超时时间_发起握手等候响应超时时间</span><br><span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">1s</span>;<br><span class="hljs-comment">###nginx发送给上游服务器(真实访问的服务器)超时时间</span><br>            <span class="hljs-attribute">proxy_send_timeout</span> <span class="hljs-number">1s</span>;<br><span class="hljs-comment">### nginx接受上游服务器(真实访问的服务器)超时时间</span><br>            <span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">1s</span>;<br>            <span class="hljs-attribute">index</span>  index.html index.htm;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="13-Nginx怎么判断别IP不可访问？"><a href="#13-Nginx怎么判断别IP不可访问？" class="headerlink" title="13. Nginx怎么判断别IP不可访问？"></a>13. Nginx怎么判断别IP不可访问？</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 如果访问的ip地址为192.168.9.115,则返回403</span><br><span class="hljs-attribute">if</span>  (<span class="hljs-variable">$remote_addr</span> = <span class="hljs-number">192.168.9.115</span>) &#123;  <br>     <span class="hljs-attribute">return</span> <span class="hljs-number">403</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="14-怎么限制浏览器访问？"><a href="#14-怎么限制浏览器访问？" class="headerlink" title="14. 怎么限制浏览器访问？"></a>14. 怎么限制浏览器访问？</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">## 不允许谷歌浏览器访问 如果是谷歌浏览器返回500</span><br><span class="hljs-attribute">if</span> (<span class="hljs-variable">$http_user_agent</span> <span class="hljs-regexp">~ Chrome)</span> &#123;   <br>    <span class="hljs-attribute">return</span> <span class="hljs-number">500</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="15-Nginx-和-Apache、Tomcat-之间的不同点"><a href="#15-Nginx-和-Apache、Tomcat-之间的不同点" class="headerlink" title="==15. Nginx 和 Apache、Tomcat 之间的不同点=="></a>==15. <strong>Nginx 和 Apache、Tomcat 之间的不同点</strong>==</h4><p>1、Nginx/Apache 是Web Server,而Apache Tomact是一个servlet container </p><p>2、tomcat可以对jsp进行解析，nginx和apache只是web服务器，可以简单理解为只能提供html静态文件服务。</p><p><strong>Nginx和Apache区别：</strong></p><p>最核心的区别在于apache是同步多进程模型，一个连接对应一个进程，nginx是异步的，多个连接可以对应一个进程。</p><p>1）Nginx轻量级，同样起web 服务，比apache占用更少的内存及资源 。</p><p>2）Nginx 抗并发，nginx 处理请求是异步非阻塞的，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能 。</p><p>3）Nginx提供负载均衡，可以做做反向代理，前端服务器。</p><p>4）Nginx多进程单线程，异步非阻塞；Apache多进程同步，阻塞。</p><h4 id="16-请解释什么是C10K问题"><a href="#16-请解释什么是C10K问题" class="headerlink" title="16. 请解释什么是C10K问题?"></a>16. 请解释什么是<code>C10K</code>问题?</h4><p><code>C10K</code>问题是指无法同时处理大量客户端(10,000)的网络套接字。</p><h4 id="17-nginx中500、502、503、504-有什么区别？"><a href="#17-nginx中500、502、503、504-有什么区别？" class="headerlink" title="17. nginx中500、502、503、504 有什么区别？"></a>17. <strong>nginx中500、502、503、504 有什么区别？</strong></h4><p><strong>500</strong>：Internal Server Error 内部服务错误，比如脚本错误，编程语言语法错误。</p><p><strong>502</strong>：Bad Gateway错误，网关错误。比如服务器当前连接太多，响应太慢，页面素材太多、带宽慢。</p><p><strong>503</strong>：Service Temporarily Unavailable，服务不可用，web服务器不能处理HTTP请求，可能是临时超载或者是服务器进行停机维护。</p><p><strong>504</strong>：Gateway timeout 网关超时，程序执行时间过长导致响应超时，例如程序需要执行20秒，而nginx最大响应等待时间为10秒，这样就会出现超时。</p><h4 id="18-Nginx-压缩了解吗，如何开启压缩？"><a href="#18-Nginx-压缩了解吗，如何开启压缩？" class="headerlink" title="18. Nginx 压缩了解吗，如何开启压缩？"></a>18. <strong>Nginx 压缩了解吗，如何开启压缩？</strong></h4><p>开启nginx gzip压缩后，图片、css、js等静态资源的大小会减小，可节省带宽，提高传输效率，但是会消耗CPU资源。</p><h4 id="19-用Nginx服务器解释-s的目的是什么"><a href="#19-用Nginx服务器解释-s的目的是什么" class="headerlink" title="19. 用Nginx服务器解释-s的目的是什么?"></a>19. 用Nginx服务器解释-s的目的是什么?</h4><p>用于运行nginx -s参数的可执行文件</p><h4 id="20-请解释ngx-http-upstream-module的作用是什么"><a href="#20-请解释ngx-http-upstream-module的作用是什么" class="headerlink" title="20. 请解释ngx_http_upstream_module的作用是什么?"></a>20. 请解释<code>ngx_http_upstream_module</code>的作用是什么?</h4><p><code>ngx_http_upstream_module</code>用于定义可通过<code>fastcgi</code>传递、<code>proxy</code>传递、<code>uwsgi</code>传递、<code>memcached</code>传递和scgi传递指令来引用的服务器组。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;正向代理&lt;/strong&gt;隐藏真实客户端，&lt;strong&gt;反向代理&lt;/strong&gt;隐藏真实服务端，
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper</title>
    <link href="http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/Zookeeper/"/>
    <id>http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/Zookeeper/</id>
    <published>2021-11-29T07:48:19.000Z</published>
    <updated>2021-11-29T07:51:30.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h4 id="1-谈下你对-Zookeeper-的认识"><a href="#1-谈下你对-Zookeeper-的认识" class="headerlink" title="1. 谈下你对 Zookeeper 的认识?"></a>1. 谈下你对 Zookeeper 的认识?</h4><p>ZooKeeper 是一个分布式的，开放源码的<strong>分布式应⽤程序协调服务</strong>。它是一个<strong>为分布式应用提供一致性服务</strong>的软件，提供的功能包括: <strong>配置维护、域名服务、分布式同步、组服务</strong>等。<br>ZooKeeper 的目标就是封装好复杂易出错的关键服务，将简单易用的接⼝和性能高效、功能稳定的系统提供给⽤户。</p><h4 id="1-1-Zookeeper的角色？"><a href="#1-1-Zookeeper的角色？" class="headerlink" title="1.1 Zookeeper的角色？"></a>1.1 Zookeeper的角色？</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gww2ivg4cuj30ji09674i.jpg" alt="史上最全Zookeeper面试题及答案总结！-mikechen的互联网架构"></p><p><strong>1.leader</strong>: 处理所有的事务请求（写请求），可以处理读请求，集群中只能有一个Leader</p><p><strong>2. Follower</strong>: 只能处理读请求，同时作为 Leader的候选节点，即如果Leader宕机，Follower节点要参与到新的Leader选举中，有可能成为新的Leader节点。</p><p><strong>3. Observer</strong>：只能处理读请求,不能参与选举。</p><h4 id="2-Zookeeper-都有哪些功能"><a href="#2-Zookeeper-都有哪些功能" class="headerlink" title="==2. Zookeeper 都有哪些功能?=="></a>==2. Zookeeper 都有哪些功能?==</h4><ol><li><strong>配置管理</strong>:  程序分布式的部署在不同的机器上，将程序的配置信息放在 zk 的 znode 下，当有配置发生改变时，也就是 znode 发生变化时，可以通过改变 zk 中某个目录节点的内容，利用 watcher 通知给各个客户端，从而更改配置.</li><li><strong>主节点选举</strong>: 主节点挂掉了之后可以从备⽤的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 Zookeeper 可以协助完成这个过程;</li><li><strong>分布式锁</strong>: Zookeeper 提供两种锁:独占锁、共享锁。独占锁即⼀次只能有一个线程使⽤资源，共享锁是读锁共享，读写互斥，即可以有多线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。Zookeeper 可以对分布式锁进行控制。</li><li><strong>命名服务</strong>(文件系统): 在分布式系统中，客户端应⽤能够根据指定名字来获取资源或服务的地址，利用 zk 创建一个全局的路径，即是唯一的路径，这 个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。</li><li><strong>集群管理</strong>:是否有机器退出和加入、选举 master。</li></ol><h4 id="2-0-说下-Znode"><a href="#2-0-说下-Znode" class="headerlink" title="==2.0 说下 Znode=="></a>==2.0 说下 Znode==</h4><p>Zookeeper 提供一个多层级的<strong>节点</strong>命名空间(节点称为 znode), 并以 key/value 形式存储数据。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为 1M。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gww2itfy29j30ek09odg0.jpg" alt="史上最全Zookeeper面试题及答案总结！-mikechen的互联网架构"></p><h4 id="2-1-说下四种类型的数据节点-Znode"><a href="#2-1-说下四种类型的数据节点-Znode" class="headerlink" title="==2.1 说下四种类型的数据节点 Znode?=="></a>==2.1 说下四种类型的数据节点 Znode?==</h4><ol><li>PERSISTENT: <strong>持久节点</strong>，除⾮手动删除，否则节点一直存在于 Zookeeper 上。</li><li>EPHEMERAL: <strong>临时节点</strong>，临时节点的生命周期与客户端会话绑定，一旦客户端会话失效(客户端与Zookeeper连接断开不一定会话失效)，那么这个客户端创建的所有临时节点都会被移除。</li><li>PERSISTENT_SEQUENTIAL: <strong>持久顺序节点</strong>，基本特性同持久节点，增加了顺序属性，节点名后边会追加一个由父节点维护的⾃增整型数字。</li><li>EPHEMERAL_SEQUENTIAL: <strong>临时顺序节点</strong>，基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的⾃增整型数字。</li></ol><h4 id="3-谈下你对-ZAB-协议的了解-（Zookeeper-怎么保证主从节点的状态同步-）"><a href="#3-谈下你对-ZAB-协议的了解-（Zookeeper-怎么保证主从节点的状态同步-）" class="headerlink" title="==3. 谈下你对 ZAB 协议的了解?==（Zookeeper 怎么保证主从节点的状态同步?）"></a>==3. 谈下你对 ZAB 协议的了解?==（Zookeeper 怎么保证主从节点的状态同步?）</h4><p>ZAB 协议是为分布式协调服务 Zookeeper 专⻔设计的一种⽀持崩溃恢复的<strong>==原子广播协议==</strong>。ZAB协议包括两种基本的模式:<br><strong>崩溃恢复：</strong><br>当整个 Zookeeper 集群刚刚启动或者Leader服务器宕机、重启或者⽹络故障导致不存在过半的服务器与 Leader 服务器保持正常通信时，所有服务器进入崩溃恢复模式，⾸先选举产⽣新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步。</p><blockquote><p>Zk 的选举算法有两种:一种是基于 basic paxos 实现 的，另外一种是基于 fast paxos 算法实现的。系统默认的选举算法为 <strong>fast paxos</strong>。</p></blockquote><p><strong>消息广播：</strong><br>当集群中超过半数机器与该 Leader 服务器完成数据同步之后， 退出恢复模式进入消息⼴播模式，Leader 服务器开始接收客户端的事务请求⽣成事物提案来进行事务请求处理。</p><blockquote><p>Zab 协议的原理可细分为四个阶段：选举（Leader Election）、发现（Discovery）、同步（Synchronization）和广播（Broadcast）。</p></blockquote><h4 id="3-0-Zookeeper-数据同步-流程"><a href="#3-0-Zookeeper-数据同步-流程" class="headerlink" title="3.0 Zookeeper ==数据同步==流程"></a>3.0 Zookeeper ==数据同步==流程</h4><p>选完 Leader 以后，zk 就进入状态同步过程。<br>1、Leader 等待 server 连接;<br>2、Follower 连接 leader，将最大的 zxid 发送给 leader;<br>3、Leader 根据 follower 的 zxid 确定同步点;<br>4、完成同步后通知 follower 已经成为 uptodate 状态;<br>5、Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gww2iu25rxj30qq09u3z4.jpg" alt="image-20211129152345700"></p><h4 id="3-1-Zookeeper-是如何保证事务的-数据一致性-的"><a href="#3-1-Zookeeper-是如何保证事务的-数据一致性-的" class="headerlink" title="3.1 Zookeeper 是如何保证事务的==数据一致性==的?"></a>3.1 Zookeeper 是如何保证事务的==数据一致性==的?</h4><p>zookeeper 采用了递增的事务 Id 来标识，所有的 proposal(提议)都在被提出的时候加上了 zxid，</p><p>zxid 实际上是一个 64 位的数字，高 32 位是用来标识 leader 是否发生改变，如果有 新的 leader 产生出来，epoch 会自增.低 32 位用来递增计数。</p><ol><li>Leader收到请求之后，将它转换为一个proposal提议，并且为每个提议分配一个全局唯一递增的事务ID：zxid，然后把提议放入到一个FIFO的队列中，按照FIFO的策略发送给所有的Follower</li><li>Follower收到提议之后，以事务日志的形式写入到本地磁盘中，写入成功后返回ACK给Leader</li><li>Leader在收到超过半数的Follower的ACK之后，即可认为数据写入成功，就会发送commit命令给Follower告诉他们可以提交proposal了</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gww2iuj4e2j30tr07t3yv.jpg" alt="img"></p><h4 id="4-Zookeeper-有⼏种部署模式"><a href="#4-Zookeeper-有⼏种部署模式" class="headerlink" title="4. Zookeeper 有⼏种部署模式?"></a>4. Zookeeper 有⼏种部署模式?</h4><ol><li>单机部署: 一台集群上运行;</li><li>集群部署: 多台集群运行;</li><li>伪集群部署: 一台集群启动多个 Zookeeper 实例运行。</li></ol><h4 id="5-说一下-Zookeeper-的通知机制"><a href="#5-说一下-Zookeeper-的通知机制" class="headerlink" title="5. ==说一下 Zookeeper 的通知机制?=="></a>5. ==说一下 Zookeeper 的通知机制?==</h4><p>client 端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些 client 会收到 zk 的通知，然后client 可以根据 znode 变化来做出业务上的改变等。</p><h4 id="6-集群中为什么要有主节点"><a href="#6-集群中为什么要有主节点" class="headerlink" title="6. 集群中为什么要有主节点?"></a>6. 集群中为什么要有主节点?</h4><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执⾏，其他的机器可以共享这个结果，这样可以⼤大减少重复计算，提⾼高性能，于是就需要进⾏ leader 选举。</p><h4 id="7-集群有-3-台服务器，其中⼀个节点宕机，这个时候-Zookeeper-还可以使用吗"><a href="#7-集群有-3-台服务器，其中⼀个节点宕机，这个时候-Zookeeper-还可以使用吗" class="headerlink" title="7. 集群有 3 台服务器，其中⼀个节点宕机，这个时候 Zookeeper 还可以使用吗?"></a>7. 集群有 3 台服务器，其中⼀个节点宕机，这个时候 Zookeeper 还可以使用吗?</h4><p>可以继续使⽤，单数服务器只要没超过一半的服务器宕机就可以继续使⽤。 集群规则为 2N+1 台，N &gt;0，即最少需要 3 台。</p><h4 id="8-说一下两阶段提交和三阶段提交的过程-分别有什么问题"><a href="#8-说一下两阶段提交和三阶段提交的过程-分别有什么问题" class="headerlink" title="8. 说一下两阶段提交和三阶段提交的过程?分别有什么问题?"></a>8. 说一下两阶段提交和三阶段提交的过程?分别有什么问题?</h4><ul><li><strong>两阶段提交协议 2PC</strong></li></ul><ol><li><p><strong>第一阶段(投票阶段):</strong><br>(1)协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应;<br>(2)参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写⼊日志。<br>(3)各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息;如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</p></li><li><p><strong>第二阶段(提交执⾏阶段):</strong> </p><p>当协调者节点从所有参与者节点获得的相应消息都为”同意”时:</p><p>(1)协调者节点向所有参与者节点发出”正式提交(commit)”的请求; </p><p>(2)参与者节点正式完成操作，并释放在整个事务期间内占⽤的资源; </p><p>(3)参与者节点向协调者节点发送”完成”消息;</p><p>(4)协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。 </p></li></ol><p>​       <strong>两阶段提交存在的问题:</strong></p><ol><li><p>执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三⽅节点访问公共资源不得不处于阻塞状态;</p></li><li><p>参与者发生故障: 协调者需要给每个参与者额外指定超时机制，超时后整个事务失败;</p></li><li><p>协调者发生故障: 参与者会一直阻塞下去。需要额外的备机进行容错;</p></li><li><p>二阶段⽆法解决的问题: 协调者再发出 commit 消息之后宕机，⽽唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产⽣了新的协调者，这条事务的状态也是不确定的，没⼈知道事务是否被已经提交。</p></li></ol><ul><li><strong>三阶段提交协议 3PC</strong></li></ul><p>与两阶段提交不不同的是，三阶段提交有两个改动点:</p><pre><code>1. 引⼊超时机制。2. 同时在协调者和参与者中都引入超时机制; 在第⼀阶段和第⼆阶段中插⼊一个准备阶段。保证了了在最后提交阶段之前各参与节点的状态是一致的。 </code></pre><p>也就是说，除了引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。</p><ol><li><p><strong>CanCommit 阶段</strong></p><pre><code>3PC 的 CanCommit 阶段其实和 2PC 的准备阶段很像。协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。(1)事务询问:协调者向参与者发送 CanCommit 请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。(2)响应反馈:参与者接到 CanCommit 请求之后，正常情况下，如果其⾃身认为可以顺利执行事务，则返回 Yes 响应，并进入预备状态。否则反馈 No。</code></pre></li><li><p><strong>PreCommit 阶段</strong><br>协调者根据参与者的反应情况来决定是否可以继续事务的 PreCommit 操作。根据响应情况，有以下两种可能:<br>假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执⾏事务的预执⾏。<br>(1)发送预提交请求:协调者向参与者发送 PreCommit 请求，并进入 Prepared 阶段。<br>(2)事务预提交:参与者接收到 PreCommit 请求后，会执行事务操作，并将 undo 和 redo 信息记录到事务⽇志中。<br>(3)响应反馈:如果参与者成功的执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。 假如有任何一个参与者向协调者发送了了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p><p>(1)发送中断请求: 协调者向所有参与者发送 abort 请求。<br>(2)中断事务: 参与者收到来⾃协调者的 abort 请求之后(或超时之后，仍未收到协调者的请求)，执⾏事务的中断。</p></li><li><p><strong>doCommit 阶段</strong><br>该阶段进⾏真正的事务提交，也可以分为以下两种情况。<br><strong>3.1 执⾏提交</strong><br>(1)发送提交请求:协调接收到参与者发送的 ACK 响应，那么他将从预提交状态进入到提交状态,并向所有参与者发送 doCommit请求。<br>(2)事务提交:参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。<br>(3)响应反馈:事务提交完之后，向协调者发送 ACK 响应。<br>(4)完成事务:协调者接收到所有参与者的 ACK 响应之后，完成事务。 </p><p><strong>3.2 中断事务</strong><br>协调者没有接收到参与者发送的 ACK 响应(可能是接受者发送的不是 ACK 响应，也可能响应超时)，那么就会执行中断事务。<br>(1)发送中断请求:协调者向所有参与者发送 abort 请求。<br>(2)事务回滚:参与者接收到 abort 请求之后，利用其在阶段⼆记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。<br>(3)反馈结果:参与者完成事务回滚之后，向协调者发送 ACK 消息。<br>(4)中断事务:协调者接收到参与者反馈的 ACK 消息之后，执⾏事务的中断。</p><p><strong>三阶段提交的问题:</strong> </p><p>⽹络分区可能会带来问题。需要四阶段解决: 四阶段直接调⽤远程服务的数据状态，确定当前数据⼀致性的情况。</p></li></ol><h4 id="9-Zookeeper-宕机如何处理"><a href="#9-Zookeeper-宕机如何处理" class="headerlink" title="9. Zookeeper 宕机如何处理?"></a>9. Zookeeper 宕机如何处理?</h4><p>Zookeeper 本身也是集群，推荐配置不少于 3 个服务器器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失;如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。</p><p>Zookeeper 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 Zookeeper 节点挂得太多， 只剩一半或不到一半节点能工作，集群才失效。</p><h4 id="10-Zookeeper-和-Dubbo-的关系"><a href="#10-Zookeeper-和-Dubbo-的关系" class="headerlink" title="10. Zookeeper 和 Dubbo 的关系?"></a>10. Zookeeper 和 Dubbo 的关系?</h4><p>Dubbo将注册中⼼进行抽象，是得它可以外接不同的存储媒介给注册中⼼提供服务，有ZooKeeper，Memcached，Redis 等。引⼊了 ZooKeeper 作为存储媒介，也就把 ZooKeeper 的特性引进来。</p><ol><li><p>⾸先是负载均衡，单注册中心的承载能⼒是有限的，在流量达到⼀定程度的时候就需要分流，负载均衡就是为了分流⽽存在的，一个 ZooKeeper 群配合相应 的 Web 应⽤就可以很容易达到负载均衡。</p></li><li><p>资源同步，单有负载均衡还不够，节点之间的数据和资源需要同步， ZooKeeper 集群就天然具备有这样的功能;</p></li><li><p>命名服务，将树状结构⽤于维护全局的服务地址列表，服务提供者在启动的时候，向 ZooKeeper 上的指定节点 /dubbo/${serviceName}/providers ⽬录下写⼊自⼰的 URL 地址，这个操作就完成了服务的发布。 </p></li><li><p>其他特性还有 Mast 选举，分布式锁等。</p></li></ol><h4 id="11-Zookeeper-下-Server-工作状态"><a href="#11-Zookeeper-下-Server-工作状态" class="headerlink" title="11. Zookeeper 下 Server 工作状态"></a>11. Zookeeper 下 Server 工作状态</h4><p>每个 Server 在工作过程中有三种状态:<br>LOOKING:当前 Server 不知道 leader 是谁，正在搜寻<br>LEADING:当前 Server 即为选举出来的 leader<br>FOLLOWING:leader 已经选举出来，当前 Server 与之同步</p><h4 id="12-Zookeeper-负载均衡和-nginx-负载均衡区别"><a href="#12-Zookeeper-负载均衡和-nginx-负载均衡区别" class="headerlink" title="12. Zookeeper 负载均衡和 nginx 负载均衡区别"></a>12. Zookeeper 负载均衡和 nginx 负载均衡区别</h4><p>zk 的负载均衡是可以调控，nginx 只是能调权重，其他需要可控的都需要自己写插件;但是 nginx 的吞吐量比 zk 大很多，按需选用。</p><h4 id="13-Zookeeper通知机制，Watch实现-简单版"><a href="#13-Zookeeper通知机制，Watch实现-简单版" class="headerlink" title="==13. Zookeeper通知机制，Watch实现?(简单版)=="></a>==13. Zookeeper通知机制，Watch实现?(简单版)==</h4><p>客户端注册监听他关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，Zookeeper会通知客户端。</p><p>client端会对某个znode建立一个watcher事件，当该znode发生变化时，zk会主动通知watch这个znode的client，然后client根据znode的变化来做出业务上的改变等。</p><p>watch的整体流程如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gww2iv0j7uj30hq09iaai.jpg" alt="史上最全Zookeeper面试题及答案总结！-mikechen的互联网架构"></p><p><strong>主要流程如下：</strong></p><p>1.客户端先向Zookeeper服务端成功注册想要监听的节点状态。</p><p>2.同时客户端本地会存储该监听器相关的信息在WatchManager中。</p><p>3.当Zookeeper服务端监听的数据状态发生变化时，Zookeeper就会主动通知发送相应事件信息给相关会话客户端，从WatherManager中取出对应Wather对象执行回调逻辑。</p><h4 id="13-Zookeeper-watch-机制-（复杂版）"><a href="#13-Zookeeper-watch-机制-（复杂版）" class="headerlink" title="==13. Zookeeper watch 机制==（复杂版）"></a>==13. Zookeeper watch 机制==（复杂版）</h4><p>Watch 机制官方声明:一个 Watch 事件是一个一次性的触发器，当被设置了 Watch 的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，以便通知它们。<br>Zookeeper 机制的特点:</p><ol><li><p>一次性触发数据发生改变时，一个 watcher event 会被发送到 client，但是 client <strong>只会收到一次这样的信息</strong>。</p></li><li><p>watcher event 异步发送 watcher 的通知事件从 server 发送到 client 是<strong>异步</strong>的，这就存在一个问题，不同的客户端和服务器之间通过 socket 进行通信，<strong>由于网络延迟或其他因素导致客户端在不通的时刻监听到事件</strong>， 由于 Zookeeper 本身提供了 <strong>ordering guarantee</strong>，即客户端监听事件后，才会感知它所监视 znode 发生了 变化。所以我们使用 Zookeeper 不能期望能够监控到节点每次的变化。Zookeeper <strong>只能保证最终的一致性， 而无法保证强一致性</strong>。</p></li><li><p>数据监视 Zookeeper 有数据监视和子数据监视 getdata() and exists()设置数据监视，getchildren()设置了子节点监视。</p></li><li><p>注册 watcher <strong>getData、exists、getChildren</strong></p></li><li><p>触发 watcher <strong>create、delete、setData</strong></p></li><li><p><strong>setData()</strong>会触发 znode 上设置的 data watch(如果 set 成功的话)。</p><p><strong>create()</strong> 操作会触发被创建的 znode 上的数据 watch，以及其父节点上的 child watch。</p><p><strong>delete()</strong>操作将会同时触发一 个 znode 的 data watch 和 child watch(因为这样就没有子节点了)，同时也会触发其父节点的 child watch。</p></li><li><p>当一个客户端<strong>连接到一个新的服务器</strong>上时，watch 将会被以任意会话事件触发。当<strong>与一个服务器失去连接</strong>的时候，是无法接收到 watch 的。而当 client <strong>重新连接</strong>时，如果需要的话，所有先前注册过的 watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，<strong>watch 可能会丢失:</strong> 对于一个未创建的 znode 的 exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这 个 watch 事件可能会被丢失。</p></li><li><p>Watch 是轻量级的，其实就是本地 JVM 的 <strong>Callback</strong>，服务器端只是存了是否有设置了 Watcher 的布尔类型</p></li></ol><h4 id="14-CAP-理论？"><a href="#14-CAP-理论？" class="headerlink" title="14. CAP 理论？"></a>14. CAP 理论？</h4><ul><li>C : Consistency <strong>一致性</strong>，数据在多个副本之间似否能够保持一致的特性。</li><li>A: Availability <strong>可用性</strong>，系统服务必须一直处于可用状态，对每个请求总是在指定的时间返回结果。</li><li>P:Partition tolerance <strong>分区容错性</strong>，遇到分区网络故障时，仍能对外提供一致性和可用性的服务。</li></ul><p>不能同时满足 3 个要求，只能满足其中的两个。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Zookeeper&quot;&gt;&lt;a href=&quot;#Zookeeper&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper&quot;&gt;&lt;/a&gt;Zookeeper&lt;/h1&gt;&lt;h4 id=&quot;1-谈下你对-Zookeeper-的认识&quot;&gt;&lt;a href=&quot;#1-谈下你
      
    
    </summary>
    
    
      <category term="Zookeeper" scheme="http://yoursite.com/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="http://yoursite.com/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/RabbitMQ/"/>
    <id>http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/RabbitMQ/</id>
    <published>2021-11-29T02:41:39.000Z</published>
    <updated>2021-11-29T02:45:34.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h4 id="1-消息队列的基本作⽤"><a href="#1-消息队列的基本作⽤" class="headerlink" title="1. 消息队列的基本作⽤?"></a>1. 消息队列的基本作⽤?</h4><p>消息队列列的主要作⽤用是:<strong>==解耦、异步、削峰==</strong>。</p><p>解耦：A 系统通过接⼝调⽤用发送数据到 B、C、D 三个系统, A 系统只负责⽣产数据,不需要考虑消息被哪个系统来消费。</p><p>异步：A 系统需要发送个请求给 B 系统处理，由于 B 系统需要查询数据库花费时间较⻓，以⾄至于 A 系统要等待 B 系统处理完毕后再发送下个请求，造成 A 系统资源浪费。使⽤用消息队列后，A 系统生产完消息后直接丢进消息队列，不⽤等待B系统的结果,直接继续去干⾃己的事情了。</p><p>削峰：把请求数据先存入消息队列中，消费系统再根据⾃己的消费能⼒拉取消费。</p><h4 id="2-消息队列的优缺点有哪些"><a href="#2-消息队列的优缺点有哪些" class="headerlink" title="2. 消息队列的优缺点有哪些?"></a>2. 消息队列的优缺点有哪些?</h4><p>优点：解耦，异步，削峰。</p><p>缺点：1.降低系统可用性。2.复杂性提高。(消息重复消费，丢失，传递顺序) 3. 一致性问题。</p><h4 id="2-1、Kafka、ActiveMQ、RabbitMQ、RocketMQ-消息队列的选型："><a href="#2-1、Kafka、ActiveMQ、RabbitMQ、RocketMQ-消息队列的选型：" class="headerlink" title="2.1、Kafka、ActiveMQ、RabbitMQ、RocketMQ 消息队列的选型："></a>2.1、Kafka、ActiveMQ、RabbitMQ、RocketMQ 消息队列的选型：</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwtkxype30j31fr0f7n2r.jpg" alt="img"></p><p>每种MQ没有绝对的好坏，主要依据使用场景，扬长避短，利用其优势，规避其劣势。</p><p>（1）中小型软件公司，技术实力较为一般，建议选RabbitMQ：一方面，erlang语言天生具备高并发的特性，而且管理界面用起来十分方便。代码是开源的，而且社区十分活跃，可以解决开发过程中遇到的bug，这点对于中小型公司来说十分重要。</p><blockquote><p>不考虑 rocketmq 的原因是，rocketmq是阿里出品，如果阿里放弃维护rocketmq，中小型公司一般抽不出人来进行rocketmq的定制化开发，因此不推荐。</p><p>不考虑 kafka 的原因是：中小型软件公司不如互联网公司，数据量没那么大，选消息中间件应首选功能比较完备的，所以kafka排除</p></blockquote><p>（2）大型软件公司：根据具体使用场景在rocketMq和kafka之间二选一。</p><blockquote><p>一方面，大型软件公司，具备足够的资金搭建分布式环境，也具备足够大的数据量。针对rocketMQ，大型软件公司有能力对rocketMQ进行定制化开发。至于kafka，如果是大数据领域的实时计算、日志采集功能，肯定是首选kafka了。</p></blockquote><h4 id="2-2、RabbitMQ的构造："><a href="#2-2、RabbitMQ的构造：" class="headerlink" title="2.2、RabbitMQ的构造："></a>2.2、RabbitMQ的构造：</h4><p>RabbitMQ 是 AMQP 协议的一个开源实现，所以其内部实际上也是 AMQP 中的基本概念：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwtl0j9s0pj30fe04e74h.jpg" alt="RabbitMQ 内部结构"></p><p>（1）生产者Publisher：生产消息，就是投递消息的一方。消息一般包含两个部分：消息体（payload）和标签（Label）<br>（2）消费者Consumer：消费消息，也就是接收消息的一方。消费者连接到RabbitMQ服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签。<br>（3）Broker服务节点：表示消息队列服务器实体。一般情况下一个Broker可以看做一个RabbitMQ服务器。<br>（4）Queue：消息队列，用来存放消息。一个消息可投入一个或多个队列，多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。<br>（5）Exchange：交换器，接受生产者发送的消息，根据路由键将消息路由到绑定的队列上。<br>（6）Routing Key： 路由关键字，用于指定这个消息的路由规则，需要与交换器类型和绑定键(Binding Key)联合使用才能最终生效。<br>（7）Binding：绑定，通过绑定将交换器和队列关联起来，一般会指定一个BindingKey，通过BindingKey，交换器就知道将消息路由给哪个队列了。<br>（8）Connection ：网络连接，比如一个TCP连接，用于连接到具体broker<br>（9）Channel： 信道，AMQP 命令都是在信道中进行的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。<strong>因为建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接，一个TCP连接可以用多个信道。</strong>客户端可以建立多个channel，每个channel表示一个会话任务。</p><h4 id="3-Exchange交换器的类型："><a href="#3-Exchange交换器的类型：" class="headerlink" title="3. Exchange交换器的类型："></a>3. Exchange交换器的类型：</h4><p>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：<strong>==direct、fanout、topic、headers==</strong></p><p>（1）direct：消息中的路由键（RoutingKey）如果和 Binding 中的 bindingKey 完全匹配，交换器就将消息发到对应的队列中。是基于<strong>完全匹配、单播的模式</strong>。</p><blockquote><p>匹配规则：<br>① RoutingKey 和 BindingKey 为一个 点号 ‘.’ 分隔的字符串。 比如: java.xiaoka.show<br>② BindingKey可使用 * 和 # 用于做模糊匹配：*匹配一个单词，#匹配多个或者0个单词</p></blockquote><p>（2）fanout：把所有发送到fanout交换器的消息路由到所有绑定该交换器的队列中，<strong>fanout 类型转发消息是最快的</strong>。<br>（3）topic：通过<strong>模式匹配</strong>的方式对消息进行路由，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。<br>（4）headers：不依赖于路由键进行匹配，是根据发送消息内容中的headers属性进行匹配，除此之外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了</p><h4 id="4-生产者生产消息的过程："><a href="#4-生产者生产消息的过程：" class="headerlink" title="4. 生产者生产消息的过程："></a>4. 生产者生产消息的过程：</h4><p>（1）Producer 先连接到 Broker，建立连接 Connection，开启一个信道 channel<br>（2）Producer 声明一个交换器并设置好相关属性<br>（3）Producer 声明一个队列并设置好相关属性<br>（4）Producer 通过绑定键将交换器和队列绑定起来<br>（5）Producer 发送消息到 Broker，其中包含路由键、交换器等信息<br>（6）交换器根据接收到的路由键查找匹配的队列<br>（7）如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者。<br>（8）关闭信道</p><h4 id="5-消费者接收消息过程："><a href="#5-消费者接收消息过程：" class="headerlink" title="5. 消费者接收消息过程："></a>5. 消费者接收消息过程：</h4><p>（1）Consumer 先连接到 Broker，建立连接 Connection，开启一个信道 channel<br>（2）向 Broker 请求消费相应队列中消息，可能会设置响应的回调函数。<br>（3）等待 Broker 回应并投递相应队列中的消息，接收消息。<br>（4）消费者确认收到的消息，ack。<br>（5）RabbitMQ从队列中删除已经确定的消息。<br>（6）关闭信道</p><h4 id="6-如何保证消息不被重复消费"><a href="#6-如何保证消息不被重复消费" class="headerlink" title="==6. 如何保证消息不被重复消费=="></a>==6. 如何保证消息不被重复消费==</h4><p><strong>重复消费原因</strong>：RabbitMQ是通过发送一个ACK确认消息。但是因为网络故障，消费者发出的确认并没有传到消息队列，导致消息队列不知道该消息已经被消费，然后就再次消息发送给了其他消费者，从而造成重复消费的情况。</p><p><strong>重复消费问题的解决思路是：</strong></p><p>保证消息的唯一性，具体解决方案如下：</p><p>（1）改造业务逻辑，使得在重复消费时也不影响最终的结果。例如对SQL语句： update t1 set money = 150 where id = 1 and money = 100; 做了个前置条件判断，即 money = 100 的情况下才会做更新，更通用的是<strong>做个 version 即版本号控制，对比消息中的版本号和数据库中的版本号</strong>。</p><p>（2）<strong>基于数据库的的唯一主键进行约束。</strong>消费完消息之后，到数据库中做一个 insert 操作，如果出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。</p><p>（3）<strong>通过记录关键的key，</strong>当重复消息过来时，先判断下这个key是否已经被处理过了，如果没处理再进行下一步。</p><h4 id="7-如何保证消息不丢失，进行可靠性传输？"><a href="#7-如何保证消息不丢失，进行可靠性传输？" class="headerlink" title="==7. 如何保证消息不丢失，进行可靠性传输？=="></a>==7. <strong>如何保证消息不丢失，进行可靠性传输？</strong>==</h4><p>对于消息的可靠性传输，每种MQ都要从三个角度来分析：<strong>生产者丢数据、消息队列丢数据、消费者丢数据</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwtpqrj5sjj31f40gc0uy.jpg" alt="image-20211127145521744"></p><h5 id="7-1、生产者丢数据："><a href="#7-1、生产者丢数据：" class="headerlink" title="7.1、生产者丢数据："></a><strong>7.1、生产者丢数据：</strong></h5><p>RabbitMQ提供事务机制（transaction）和确认机制（confirm）两种模式来确保生产者不丢消息.<br><strong>(1)事务机制：</strong></p><p>发送消息前，开启事务（channel.txSelect()），然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()），如果发送成功则提交事务（channel.txCommit().</p><p>缺点：生产者发送消息会同步阻塞等待发送结果是成功还是失败，导致吞吐量下降。</p><p><strong>(2)确认机制：</strong></p><p>生产环境常用的是confirm模式。生产者将信道 channel 设置成 confirm 模式，一旦 channel 进入 confirm 模式，所有在该信道上发布的消息都将会被指派一个唯一的ID，一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个确认给生产者（包含消息的唯一ID），这样生产者就知道消息已经正确到达目的队列了。如果rabbitMQ没能处理该消息，也会发送一个Nack消息给你，这时就可以进行重试操作。</p><p>优点：异步的，一旦发布消息，生产者就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者便可以通过回调方法来处理该确认消息</p><h5 id="7-2、消息队列丢数据："><a href="#7-2、消息队列丢数据：" class="headerlink" title="7.2、消息队列丢数据："></a><strong>7.2、消息队列丢数据：</strong></h5><p>处理消息队列丢数据的情况，一般是开启持久化磁盘。</p><h5 id="7-3、消费者丢数据："><a href="#7-3、消费者丢数据：" class="headerlink" title="7.3、消费者丢数据："></a><strong>7.3、消费者丢数据：</strong></h5><p>原因： 消费者丢数据一般是因为采用了自动确认消息模式。该模式下，虽然消息还在处理中，但是消费中者会自动发送一个确认，通知 RabbitMQ 已经收到消息了，这时 RabbitMQ 就会立即将消息删除。这种情况下，如果消费者出现异常而未能处理消息，那就会丢失该消息。</p><p>解决方案：就是采用手动确认消息，设置 autoAck = False，等到消息被真正消费之后，再手动发送一个确认信号，即使中途消息没处理完，但是服务器宕机了，那 RabbitMQ 就收不到发的ack，然后 RabbitMQ 就会将这条消息重新分配给其他的消费者去处理。</p><p>采用手动确认消息的方式，我们也需要考虑一下几种特殊情况：</p><blockquote><ol><li>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被消费，然后重新分发给下一个订阅的消费者，所以存在消息重复消费的隐患</li><li>如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息</li></ol></blockquote><h4 id="8、如何保证消息的有序性？"><a href="#8、如何保证消息的有序性？" class="headerlink" title="==8、如何保证消息的有序性？=="></a>==8、如何保证消息的有序性？==</h4><p>解决方法就是保证生产者入队的顺序是有序的，出队后的顺序消费则交给消费者去保证。</p><p>（1）方法一：<strong>拆分queue，使得一个queue只对应一个消费者。</strong>由于MQ一般都能保证内部队列是先进先出的，所以把需要保持先后顺序的一组消息使用某种算法都分配到同一个消息队列中。然后只用一个消费者单线程去消费该队列，这样就能保证消费者是按照顺序进行消费的了。但是消费者的吞吐量会出现瓶颈。如果多个消费者同时消费一个队列，还是可能会出现顺序错乱的情况，这就相当于是多线程消费了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwtpcxq55wj30x508tt9w.jpg" alt="img"></p><p>（2）方法二：对于多线程的消费同一个队列的情况，可以使用<strong>重试机制</strong>：比如有一个微博业务场景的操作，发微博、写评论、删除微博，这三个异步操作。如果一个消费者先执行了写评论的操作，但是这时微博都还没发，写评论一定是失败的，等一段时间。等另一个消费者，先执行发微博的操作后，再执行，就可以成功。</p><h4 id="9、如何处理消息堆积情况"><a href="#9、如何处理消息堆积情况" class="headerlink" title="==9、如何处理消息堆积情况?=="></a>==9、如何处理消息堆积情况?==</h4><p><strong>9.1、出现该问题的原因</strong></p><p>生产者的生产速度与消费者的消费速度不匹配导致的。有可能就是消费者消费能力弱，渐渐地消息就积压了，也有可能是因为消息消费失败反复复重试造成的，也有可能是消费端出了问题，导致不消费了或者消费极其慢。</p><p><strong>9.2、临时扩容，快速处理积压的消息：</strong></p><p>（1）先修复 consumer 的问题，确保其恢复消费速度，然后将现有的 consumer 都停掉；<br>（2）临时创建原先 N 倍数量的 queue ，然后写一个临时分发数据的消费者程序，将该程序部署上去消费队列中积压的数据，消费之后不做任何耗时处理，直接均匀轮询写入临时建立好的 N 倍数量的 queue 中；<br>（3）接着，临时征用 N 倍的机器来部署 consumer，每个 consumer 消费一个临时 queue 的数据<br>（4）等快速消费完积压数据之后，恢复原先部署架构 ，重新用原先的 consumer 机器消费消息。</p><p><strong>9.3、恢复队列中丢失的数据：</strong></p><p>如果使用的是 rabbitMQ，并且设置了过期时间，消息在 queue 里积压超过一定的时间会被 rabbitmq 清理掉，导致数据丢失。这种情况可以采取 “<strong>批量重导</strong>” 的方案来进行解决。在流量低峰期，写一个程序，手动去查询丢失的那部分数据，然后将消息重新发送到mq里面，把丢失的数据重新补回来。</p><h4 id="10-如何保证消息队列的高可用？"><a href="#10-如何保证消息队列的高可用？" class="headerlink" title="==10. 如何保证消息队列的高可用？=="></a>==10. 如何保证消息队列的高可用？==</h4><p>RabbitMQ 是基于主从（非分布式）做高可用性的，RabbitMQ 有三种模式：<strong>单机模式、普通集群模式、镜像集群模式</strong></p><p><strong>10.1、单机模式：</strong>一般没人生产用单机模式</p><p><strong>10.2、普通集群模式：</strong>就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。只同步元数据。</p><p>（1）优点：普通集群模式主要用于提高系统的吞吐量，可以通过添加更加的节点来线性的扩展消息队列的吞吐量，就是说让集群中多个节点来服务某个 queue 的读写操作<br>（2）缺点：无高可用性，queue所在的节点宕机了，其他实例就无法从那个实例拉取数据；RabbitMQ 内部也会产生大量的数据传输。</p><p><strong>10.3、==镜像集群模式==：</strong>RabbitMQ 真正的高可用模式。创建的 Queue，⽆无论元数据还是Queue ⾥的消息都会存在于多个实例例 上，然后每次你写消息到 Queue 的时候，都会⾃动和多个实例的 Queue 进⾏消息同步。</p><p>缺点：</p><p>1.性能开销大，消息需要同步到所有机器上，导致网络带宽压力和消耗很重</p><p>2.非分布式，没有扩展性，如果 queue 的数据量大到这个机器上的容量无法容纳了，此时该方案就会出现问题了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RabbitMQ&quot;&gt;&lt;a href=&quot;#RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ&quot;&gt;&lt;/a&gt;RabbitMQ&lt;/h1&gt;&lt;h4 id=&quot;1-消息队列的基本作⽤&quot;&gt;&lt;a href=&quot;#1-消息队列的基本作⽤&quot; class
      
    
    </summary>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/MySQL/"/>
    <id>http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/MySQL/</id>
    <published>2021-11-29T02:40:39.000Z</published>
    <updated>2021-11-29T02:44:21.551Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Q1-MySQL-的逻辑架构了解吗"><a href="#Q1-MySQL-的逻辑架构了解吗" class="headerlink" title="==Q1:MySQL 的逻辑架构了解吗?=="></a>==Q1:MySQL 的逻辑架构了解吗?==</h4><p>第一层是服务器层，负责链接，授权，安全</p><p>第二层是核心服务层，负责查询解析，储存过程，触发器，视图。分析器，优化器，执行器。</p><p>第三层是存储引擎层，只负责数据提取。同层不通信，与上层通过API交流，不解析SQL</p><h4 id="Q2-谈一谈-MySQL-的读写锁"><a href="#Q2-谈一谈-MySQL-的读写锁" class="headerlink" title="Q2:谈一谈 MySQL 的读写锁"></a>Q2:谈一谈 MySQL 的读写锁</h4><p>读锁：共享锁。互不阻塞。</p><p>写锁：排它锁。阻塞其他读写锁。</p><p>写锁优先级比读锁高，可被插入在读锁队列前。读锁不能插入写锁队列前。</p><h4 id="Q3-MySQL-的锁策略有什么"><a href="#Q3-MySQL-的锁策略有什么" class="headerlink" title="==Q3:MySQL 的锁策略有什么?=="></a>==Q3:MySQL 的锁策略有什么?==</h4><p><strong>表级锁</strong>：最大粒度的锁级别，发生锁冲突的概率最高，并发度最低，但开销小，加锁快，不会出现死锁；<br><strong>行级锁</strong>：最小粒度的所级别，发生锁冲突的概率最小，并发度最高，但开销大，加锁慢，会发生死锁；<br><strong>页级锁</strong>：锁粒度界于表级锁和行级锁之间，对表级锁和行级锁的折中，并发度一般。开销和加锁时间也界于表锁和行锁之间，会出现死锁；</p><p><strong>意向锁</strong>：当你要加表锁时，势必要先遍历该表的所有记录，判断是否有排他锁。这种遍历检查的方式显然是一种低效的方式，MySQL引入了意向锁，来检测表锁和行锁的冲突。，分为读意向锁（IS锁）和写意向锁（IX锁）。当事务要在记录上加上行锁时，则先在表上加上对应的意向锁。之后事务如果想进行锁表，只要先判断是否有意向锁存在，存在时则可快速返回该表不能启用表锁，否则就需要等待，提高效率。</p><h4 id="Q4-数据库死锁如何解决"><a href="#Q4-数据库死锁如何解决" class="headerlink" title="Q4:数据库死锁如何解决?"></a>Q4:数据库死锁如何解决?</h4><p>死锁：多个事务不同顺序锁定资源；多个事务锁定同个资源。</p><p>InnoDB自动检测死锁，并返回错误。</p><p>解决方法：InnoDB回滚最少行级排它锁事务 -&gt; 重新执行此事务</p><h4 id="Q5-事务是什么"><a href="#Q5-事务是什么" class="headerlink" title="Q5:事务是什么?"></a>Q5:事务是什么?</h4><p>一组原子性SQL语句。任何一条语句崩溃则全崩溃。事务执行要么全成功，要么全失败。</p><h4 id="Q6-事务有什么特性"><a href="#Q6-事务有什么特性" class="headerlink" title="==Q6:事务有什么特性?=="></a>==Q6:事务有什么特性?==</h4><p>原子性，一致性， 隔离性，持久性。</p><h4 id="Q7-MySQL-的隔离级别有哪些"><a href="#Q7-MySQL-的隔离级别有哪些" class="headerlink" title="==Q7:MySQL 的隔离级别有哪些?=="></a>==Q7:MySQL 的隔离级别有哪些?==</h4><p>未提交读 Read Uncommit：事务中的修改即使没有被提交，对其他事务也是可⻅的。被叫做脏读。还会导致不可重复度和幻读。</p><p>提交读 Read committed: 事务开始时只能看到已提交事务的修改。也叫不可重复读。</p><p>可重复度 Repeatable Read: MySQL默认隔离级别。保证一个事物中多次读取记录一致，解决了不可重复读。但无法解决幻读。用MVCC解决幻读。</p><p>可串行化 Serializable: 通过强制事物串行执行，解决幻读。但是给读取的每一行数据都加锁，导致超时和锁征用，现实很少用到。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwqiqd6hkyj30r0070jru.jpg" alt="img"></p><h4 id="Q8-MVCC-是什么"><a href="#Q8-MVCC-是什么" class="headerlink" title="==Q8:MVCC 是什么?=="></a>==Q8:MVCC 是什么?==</h4><p>多版本并发控制。大多情况下避免加锁，实现非阻塞读操作，写操作只锁必须行。</p><p>原理：每行记录保存两个列，储存系统版本号。每开始一个事务就递增版本号。事务开始时版本号作为事务版本号，与记录的版本号比较。</p><h4 id="Q-9-谈一谈-InnoDB"><a href="#Q-9-谈一谈-InnoDB" class="headerlink" title="Q==9:谈一谈 InnoDB=="></a>Q==9:谈一谈 InnoDB==</h4><p>InnoDB是MySQL默认事务引擎，用来处理大量短期事务，性能和崩溃自动回复较好</p><p>InnoDB数据结构存在表空间中，所有的表都保存在同一个数据文件中。不保存表的总行数。<strong>==InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。==</strong></p><p>InnoDB采用MVCC支持高并发，实现四个隔离级别。通过间隙锁解决幻读问题。</p><p>InnoDB使用聚簇索引，对主键查询性能高。但是二级索引必须包含主键列，导致主键过大时，整个索引也很大。所以表上索引很多的话，主键应该尽可能小。</p><p>InnoDB储存格式是平台独立的，可以跨平台迁移。</p><p>InnoDB内部做了优化，读磁盘的可预测性预读，自动创建读操作自适应哈希索引，加速插入操作的插入缓冲区。</p><p>5.6版本之后InnoDB存储引擎开始支持全文索引，5.7版本之后通过使用ngram插件开始支持中文。之前仅支持英文，因为是通过空格作为分词的分隔符，对于中文来说是不合适的。MySQL允许在char、varchar、text类型上建立全文索引。</p><h4 id="Q10-谈一谈-MyISAM"><a href="#Q10-谈一谈-MyISAM" class="headerlink" title="Q10:谈一谈 MyISAM"></a>Q10:谈一谈 MyISAM</h4><p>MySQL5.1之前的默认引擎，支持全文索引，压缩，空间函数。但是没有事务和行锁。最大缺陷是崩溃后无法完全恢复。</p><p>MyISAM 允许没有任何索引和主键的表存在，不支持外键。保存表的总行数。</p><p>MyISAM将表存在数据文件和索引文件，.myd,.myi。</p><p>MyISAM对整张表加锁，影响写入性能。</p><p>MyISAM表检查和修复操作会丢失数据。</p><p>设计简单，数据以紧密格式储存，但是表锁影响性能。</p><h4 id="Q11-谈一谈-Memory"><a href="#Q11-谈一谈-Memory" class="headerlink" title="Q11:谈一谈 Memory"></a>Q11:谈一谈 Memory</h4><p>Memory表：需要快速读取数据，不进行修改。重启后数据丢失也没关系。适合查找或映射表，中间数据。</p><p>所有数据储存在内存中，重启后只有表结构保留，数据丢失。</p><p>支持哈希索引，查询速度极快，使用表锁，因此并发写入效率低。不支持BLOB,TEXT类型。每行长度固定，Varchar变成char，造成内存空间的浪费。</p><h4 id="Q12-查询执行流程是什么"><a href="#Q12-查询执行流程是什么" class="headerlink" title="Q12:查询执行流程是什么?"></a>Q12:查询执行流程是什么?</h4><p>1.客户端发送一条查询给服务器。</p><p>2.服务器先检查查询缓存，命中缓存后返回查询结果，否则下一步</p><p>3.服务器解析SQL,预处理，由优化器生成执行计划。</p><p>4.根据执行计划，通过API调用存储引擎查询。</p><p>5.返回查询结果。</p><h4 id="Q13-VARCHAR-和-CHAR-的区别"><a href="#Q13-VARCHAR-和-CHAR-的区别" class="headerlink" title="Q13:VARCHAR 和 CHAR 的区别?"></a>Q13:VARCHAR 和 CHAR 的区别?</h4><p>Varchar 可变长度字符串，比char省空间，不会删除末尾空格，需要1，2个额外字节记录字符串长度。适合长字符串，列更新少，UTF-8复杂字符集的字符串。</p><p>Char固定长度，会删除末尾空格。适合短的列。适合经常更新的数据，因为不会产生碎片，如MD5。</p><h4 id="Q14-DATETIME-和-TIMESTAMP-的区别"><a href="#Q14-DATETIME-和-TIMESTAMP-的区别" class="headerlink" title="Q14:DATETIME 和 TIMESTAMP 的区别?"></a>Q14:DATETIME 和 TIMESTAMP 的区别?</h4><p>datetime储存范围广，1001~9999，精度为秒，不依赖时区，8字节储存空间。</p><p>timestamp和Unix时间戳相似，范围小，1970~2038，依赖时区，4字节储存空间。</p><h4 id="Q15-数据类型有哪些优化策略"><a href="#Q15-数据类型有哪些优化策略" class="headerlink" title="Q15:数据类型有哪些优化策略?"></a>Q15:数据类型有哪些优化策略?</h4><p>更小的通常更好</p><p>尽可能简单</p><p>尽量避免使用Null，索引列最好非空。</p><h4 id="Q16-索引有什么作用"><a href="#Q16-索引有什么作用" class="headerlink" title="==Q16:索引有什么作用?=="></a>==Q16:索引有什么作用?==</h4><p>索引也叫键，帮助存储引擎快速找到记录的数据结构。MySQL先在索引中找到对应的值，再根据匹配的索引记录找到对应的行。索引可以是一个或者多个列的值，当多个列时，列的顺序非常重要，因为MySQL只能使用索引的最左前缀。</p><p>索引大大减少了服务器要扫描的数据量。1.帮助服务器避免排序和临时表。2.将随机IO变成顺序IO。</p><p>小型表，适合全表搜索。中大型表，适合索引。特大型表索引代价增长，适合分区技术。</p><p>索引的缺点：</p><ul><li>当对表中的数据进行增加、删除和修改时，索引也要进行更新，维护的耗时随着数据量的增加而增加。</li><li>索引需要占用物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li></ul><h4 id="Q16-1索引的分类"><a href="#Q16-1索引的分类" class="headerlink" title="Q16.1索引的分类?"></a>Q16.1索引的分类?</h4><p>从数据结构⻆角度</p><ol><li>树索引 (O(log(n)))</li><li>Hash 索引</li></ol><p>从物理理存储⻆角度</p><ol><li>聚集索引(clustered index)</li><li>⾮非聚集索引(non-clustered index)</li></ol><p>从逻辑⻆角度</p><ol><li>普通索引 2. 唯⼀一索引 3. 主键索引 4. 联合索引 5. 全⽂文索引</li></ol><h4 id="Q17-谈一谈-MySQL-的-B-Tree-索引"><a href="#Q17-谈一谈-MySQL-的-B-Tree-索引" class="headerlink" title="==Q17:谈一谈 MySQL 的 B-Tree 索引=="></a>==Q17:谈一谈 MySQL 的 B-Tree 索引==</h4><p>InnoDB使用B+树。</p><p>B树所有值按照顺序储存，每个叶子节点到根的距离相同。</p><p>B树加快访问数据速度，因为不需要做全表扫描。是从根结点的索引开始进行搜索。</p><p>B-Tree索引的限制:<br>如果不是按照索引的最左列开始查找，则无法使用索引。<br>不能跳过索引中的列，例如索引为 (id,name,sex)，不能只使用 id 和 sex 而跳过 name。<br>如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引。</p><p>什么时候使用索引：</p><ol><li>经常出现在group by,order by和distinc关键字后面的字段</li><li>经常与其他表进行连接的表，在连接字段上应该建立索引</li><li>经常出现在Where子句中的字段</li><li>经常出现用作查询选择的字段</li></ol><h4 id="Q18-了解-Hash-索引吗"><a href="#Q18-了解-Hash-索引吗" class="headerlink" title="Q18:了解 Hash 索引吗?"></a>Q18:了解 Hash 索引吗?</h4><p>基于哈希表实现，只有精确匹配到所有的列才有效。对于每一行数据，存储引擎都会计算一个索引的hash码储存在索引中，同时在hash表中保存指向所有行的指针。所以hash索引查询非常快。</p><p>只有Memory引擎显示支持哈希索引，这也是Memory的默认搜索引擎。</p><p>缺点：1.数据不是按照索引值顺序排列的，无法支持排序。2.不支持部分索引匹配查找。3.只支持等值比较查询，不支持范围查找。</p><h4 id="Q19-什么是自适应哈希索引"><a href="#Q19-什么是自适应哈希索引" class="headerlink" title="==Q19:什么是自适应哈希索引?=="></a>==Q19:什么是自适应哈希索引?==</h4><p>是InnoDB的特殊功能，当某些索引值被引用十分频繁时，会在基于B+树索引之上创建一个hash索引，用来加快查询。这是一个完全的内部行为，用户无法控制和配置，有必要时可以关闭该功能。</p><h4 id="Q20-什么是空间索引"><a href="#Q20-什么是空间索引" class="headerlink" title="Q20 :什么是空间索引?"></a>Q20 :什么是空间索引?</h4><p>MyISAM表支持空间索引，储存地理数据。这类索引无需前缀查询。但是必须使用MySQL的GIS函数维护数据，MySQL对GIS支持并不完善，所以大部分人不会使用这个特性。</p><h4 id="Q21-什么是全文索引"><a href="#Q21-什么是全文索引" class="headerlink" title="==Q21:什么是全文索引?=="></a>==Q21:什么是全文索引?==</h4><p>如果希望通过关键字匹配进行查询，就需要基于相似度的查询，而不是精确的数值比较，全文索引就是为这种场景设计的。</p><p>MyISAM 的全文索引是一种特殊的 B-Tree 索引，一共有两层。第一层是所有关键字，然后对于每一个 关键字的第二层，包含的是一组相关的”文档指针”。</p><p>全文索引不会索引文档对象中的所有词语，它会根 据规则过滤掉一些词语，例如停用词列表中的词都不会被索引。</p><h4 id="Q22-什么是聚簇索引"><a href="#Q22-什么是聚簇索引" class="headerlink" title="Q22:什么是聚簇索引?"></a>Q22:什么是聚簇索引?</h4><p>InnoDB 的聚簇索引实际上在同一个结构中保存 了 B-Tree 索引和数据行。</p><p>当表有聚餐索引时，它的行数据实际上存放在索引的叶子⻚中，因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p>优点：1.相关数据存放在一起。2.数据访问快。3.使用覆盖扫描的查询可以直接使用叶子节点主键值。</p><p>缺点：1.IO密集。2.更新列代价高。3.表插入新行或主键更新导致页分裂，占用更多磁盘空间。4.数据不连续时，全表扫描可能很慢。</p><h4 id="Q23-什么是覆盖索引"><a href="#Q23-什么是覆盖索引" class="headerlink" title="Q23:什么是覆盖索引?"></a>Q23:什么是覆盖索引?</h4><p>覆盖索引指一个索引包含或覆盖了所有需要查询的字段的值，不再需要根据索引回表查询数据。覆盖索引必须要存储索引列的值，因此 MySQL 只能使用 B-Tree 索引做覆盖索引。</p><p>优点：1.索引条目远小于数据行大小，减少数据访问量。2.索引值顺序储存，较少IO. 3.InnoDB使用聚簇索引，在节点保存了行的主键值，如果二级主键能覆盖查询，避免了对主键索引的二次查询。</p><h4 id="Q24-你知道哪些索引使用原则-（索引调优）"><a href="#Q24-你知道哪些索引使用原则-（索引调优）" class="headerlink" title="Q24:你知道哪些索引使用原则?（索引调优）"></a>Q24:你知道哪些索引使用原则?（索引调优）</h4><p><strong>建立索引</strong>：对查询频次较高且数据量比较大的表建立索引。</p><p><strong>使用前缀索引</strong>： 对于 BLOB、TEXT 或很⻓的 VARCHAR 列必须使用前缀索引，MySQL 不允许索引这些列的完整⻓度。点是 MySQL 无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。</p><p><strong>选择合适的索引顺序</strong>：当不需要考虑排序和分组时，将选择性最高的列放在前面。索引的选择性是指不重复的索引值和数据表的记录总数之比，索引的选择性越高则查询效率越高，唯一索引的选择性是 1，因此也可以使用唯一索 引提升查询效率。</p><p><strong>删除无用索引</strong>：MySQL 允许在相同列上创建多个索引，了重复索 引和冗余索引，可能还会有一些服务器永远不用的索引，也应该考虑删除。</p><h4 id="Q25-索引失效的情况有哪些"><a href="#Q25-索引失效的情况有哪些" class="headerlink" title="==Q25:索引失效的情况有哪些?=="></a>==Q25:索引失效的情况有哪些?==</h4><p>1.<strong>如果索引列出现了隐式类型转换，则 MySQL 不会使用索引</strong>：WHERE 条件中字段类型为字符串，其值为数值，如果没有加引号那么 MySQL 不会使用索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">'a'</span> (<span class="hljs-string">'a'</span> <span class="hljs-built_in">char</span>(<span class="hljs-number">10</span>));<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-string">'a'</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">'a'</span>=<span class="hljs-string">"1"</span> <span class="hljs-comment">-- ⾛走索引</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-string">'a'</span><span class="hljs-keyword">WHERE</span> <span class="hljs-string">'a'</span>=<span class="hljs-number">1</span> <span class="hljs-comment">-- 不不⾛走索引，同样也是使⽤用了了函数运算</span><br></code></pre></td></tr></table></figure><p>2.<strong>如果 WHERE 条件中含有 OR，除非 OR 前使用了索引列而 OR 之后是非索引列，索引会失效。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> dname=<span class="hljs-string">'xxx'</span> <span class="hljs-keyword">or</span> loc=<span class="hljs-string">'xx'</span> <span class="hljs-keyword">or</span> deptno = <span class="hljs-number">45</span>;<br></code></pre></td></tr></table></figure><p>3.<strong>MySQL 不能在索引中执行 LIKE 操作。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-string">'manong'</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">`uname`</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%码农%'</span> <span class="hljs-comment">-- ⾛走索引 </span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-string">'manong'</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">`uname`</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">"%码农%"</span> <span class="hljs-comment">-- 不不⾛走索引</span><br></code></pre></td></tr></table></figure><p>4.<strong>如果查询中的列不是独立的，则 MySQL 不会使用索引。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">索引列列参与表达式计算:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-string">'sname'</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">'stu'</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">'age'</span> + <span class="hljs-number">10</span> = <span class="hljs-number">30</span>;<br>函数运算:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-string">'sname'</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">'stu'</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">LEFT</span>(<span class="hljs-string">'date'</span>,<span class="hljs-number">4</span>) &lt; <span class="hljs-number">1990</span>;<br></code></pre></td></tr></table></figure><p>5.<strong>对于多个范围条件查询，MySQL 无法使用第一个范围列后面的其他索引列.</strong></p><p>6.如果 MySQL 判断全表扫描比使用索引查询更快，则不会使用索引。</p><p>7.索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p><h4 id="Q26-如何定位低效-SQL"><a href="#Q26-如何定位低效-SQL" class="headerlink" title="Q26:如何定位低效 SQL?"></a>Q26:如何定位低效 SQL?</h4><p>方式一：一种是通过慢查询日志定位，可以通过慢查询日志定位那些已经执行完毕的 SQL 语句。</p><p>方式二：使用 SHOW PROCESSLIST 查询。查看当前 MySQL 正在进行的线程，包括线程的状态、是否锁表等，可以实 时查看 SQL 的执行情况，</p><h4 id="Q26-1-MySQL-问题排查都有哪些⼿手段"><a href="#Q26-1-MySQL-问题排查都有哪些⼿手段" class="headerlink" title="==Q26.1:MySQL 问题排查都有哪些⼿手段?=="></a>==Q26.1:MySQL 问题排查都有哪些⼿手段?==</h4><ol><li>使⽤用 show processlist 命令查看当前所有连接信息; </li><li>使⽤用 Explain 命令查询 SQL 语句句执⾏行行计划;</li><li>开启慢查询⽇日志，查看慢查询的 SQL。</li></ol><h4 id="Q27-SHOW-PROFILE-的作用"><a href="#Q27-SHOW-PROFILE-的作用" class="headerlink" title="Q27:SHOW PROFILE 的作用?"></a>Q27:SHOW PROFILE 的作用?</h4><p>可以分析 SQL 语句性能消耗，例如查询到 SQL 会执行多少时间，并显示 CPU、 内存使用量，执行过程中系统锁及表锁的花费时间等信息。</p><h4 id="Q28-Trace-是干什么的"><a href="#Q28-Trace-是干什么的" class="headerlink" title="Q28:Trace 是干什么的?"></a>Q28:Trace 是干什么的?</h4><p>从 MySQL5.6 开始，可以通过 trace 文件进一步获取优化器是是如何选择执行计划的，</p><h4 id="Q29-EXPLAIN-的字段有哪些，具有什么含义"><a href="#Q29-EXPLAIN-的字段有哪些，具有什么含义" class="headerlink" title="Q29:EXPLAIN 的字段有哪些，具有什么含义?"></a>Q29:EXPLAIN 的字段有哪些，具有什么含义?</h4><p>执行计划是 SQL 调优的一个重要依据，可以通过 EXPLAIN 命令查看 SQL 语句的执行计划，如果作用在 表上，那么该命令相当于 DESC。</p><p>重要的有id、type、key、key_len、rows、extra：</p><p>（1）id：id列可以理解为SQL执行顺序的标识，有几个select 就有几个id。</p><p>（2）select_type：查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询；</p><p>（4）type：访问类型，即MySQL决定如何查找表中的行。</p><p>（6）key：实际使用哪个索引来优化对该表的访问</p><p>（7）key_len：实际上用于优化查询的索引长度，即索引中使用的字节数。</p><p>（9）rows：根据表统计信息及索引选用情况，大致估算此处查询需要读取的行数，不是精确值。</p><h4 id="Q30-有哪些优化-SQL-的策略"><a href="#Q30-有哪些优化-SQL-的策略" class="headerlink" title="==Q30:有哪些优化 SQL 的策略?=="></a>==Q30:有哪些优化 SQL 的策略?==</h4><ol><li><p>优化 COUNT 查询：如果在 COUNT 中指定了列或列的表达式，则统计的就是这个表达式有值的结果数，而不是 NULL。不要使用count(*)</p></li><li><p>优化关联查询：确保 ON 或 USING 子句中的列上有索引，在创建索引时就要考虑到关联的顺序。</p></li><li><p>优化 GROUP BY</p></li><li><p>优化 LIMIT 分⻚ ：尽可能地使用覆盖索引扫描，而不是查询所有的列，然后根据需要做一次关联操作再返回所需的列。</p></li><li><p>优化 UNION 查询：MySQL 通过创建并填充临时表的方式来执行 UNION 查询，除非确实需要服务器消除重复的行，否则一 定要使用 UNION ALL，如果没有 ALL 关键字，MySQL 会给临时表加上 DISTINCT 选项，这会导致对整 个临时表的数据做唯一性检查，这样做的代价非常高。</p></li><li><p>优化 INSERT：需要对一张表插入很多行数据时，应该尽量使用一次性插入多个值的 INSERT 语句。</p></li></ol><h4 id="Q31-MySQL-主从复制的作用"><a href="#Q31-MySQL-主从复制的作用" class="headerlink" title="==Q31:MySQL 主从复制的作用?=="></a>==Q31:MySQL 主从复制的作用?==</h4><p>复制解决的基本问题是让一台服务器的数据与其他服务器保持同步，一台主库的数据可以同步到多台备库上，备库本身也可以被配置成另外一台服务器的主库。</p><p>MySQL 支持两种复制方式:基于行的复制和基于语句的复制，这两种方式都是通过在主库上记录二进制日志、在备库重放日志的方式来实现异步的数据复制。因此同一时刻备库的数据可能与主库存在不一致，并且无法包装主备之间的延迟。</p><p>主从复制的好处：</p><p>（1）读写分离，通过动态增加从服务器来提高数据库的性能，在主服务器上执行写入和更新，在从服务器上执行读功能。<br>（2）提高数据安全，因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份而不破坏主服务器相应数据。<br>（3）在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能</p><p>复制解决的问题:数据分布、负载均衡、备份、高可用性和故障切换、MySQL 升级测试</p><h4 id="Q32-MySQL-主从复制的步骤"><a href="#Q32-MySQL-主从复制的步骤" class="headerlink" title="==Q32:MySQL 主从复制的步骤?=="></a>==Q32:MySQL 主从复制的步骤?==</h4><p>1 在主库上把数据更改记录到二进制日志(binlog)中。</p><p>2 备库将主库的日志复制到自己的中继日志(relaylog)中。 </p><p>3 备库读取中继日志中的事件，将其重放到备库数据之上。</p><h4 id="Q32-1主从复制中涉及到哪三个线程"><a href="#Q32-1主从复制中涉及到哪三个线程" class="headerlink" title="==Q32.1主从复制中涉及到哪三个线程?=="></a>==Q32.1主从复制中涉及到哪三个线程?==</h4><p>主要涉及三个线程:binlog 线程、I/O 线程和 SQL 线程。</p><ol><li>binlog 线程 :负责将主服务器器上的数据更更改写⼊入⼆二进制⽇日志(Binary log)中。</li><li>I/O 线程 :负责从主服务器器上读取⼆二进制⽇日志，并写⼊入从服务器器的􏰀放⽇日志(Relay log)中。 </li><li>SQL 线程 :负责读取重放⽇日志并重放其中的 SQL 语句句</li></ol><h4 id="Q33-数据库的常用范式："><a href="#Q33-数据库的常用范式：" class="headerlink" title="Q33:数据库的常用范式："></a>Q33:<strong>数据库的常用范式：</strong></h4><p>第一范式的目标是确保每列的原子性:列都是不可再分.</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr8zklmvnj31aw0akdhw.jpg" alt="image-20211125114430603"></p><p>第二范式要求每个表只描述一 件事情。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr8ztcp15j30zu0ds76c.jpg" alt="image-20211125114444882"></p><p>第三范式定义是表中的列不存在对非主键列的传递依赖。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr903prb8j31as0jqgon.jpg" alt="image-20211125114501217"></p><h4 id="Q34-Innodb存储引擎的执行过程："><a href="#Q34-Innodb存储引擎的执行过程：" class="headerlink" title="Q34.Innodb存储引擎的执行过程："></a>Q34.Innodb存储引擎的执行过程：</h4><p>（1）首先MySQL执行器根据 执行计划 调用存储引擎的API查询数据<br>（2）存储引擎先从缓存池buffer pool中查询数据，如果没有就会去磁盘中查询，如果查询到了就将其放到缓存池中<br>（3）在数据加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中<br>（4）innodb 会在 Buffer Pool 中执行更新操作<br>（5）更新后的数据会记录在 redo log buffer 中<br>（6）提交事务在提交的同时会做以下三件事<br>（7）（第一件事）将redo log buffer中的数据刷入到redo log文件中<br>（8）（第二件事）将本次操作记录写入到 bin log文件中<br>（9）（第三件事）将bin log文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记<br>（10）使用一个后台线程，它会在某个时机将我们Buffer Pool中的更新后的数据刷到 MySQL 数据库中，这样就将内存和数据库的数据保持统一了</p><h4 id="Q35-读写分离"><a href="#Q35-读写分离" class="headerlink" title="==Q35.读写分离=="></a>==Q35.读写分离==</h4><p>读写分离解决的是，数据库的写操作，影响了查询的效率，适用于读远大于写的场景。读写分离的实现基础是主从复制，主数据库负责处理写操作（当然也可以执行读操作），从数据库负责处理读操作，不能执行写操作。</p><h4 id="Q36-主键一般用自增ID还是UUID？"><a href="#Q36-主键一般用自增ID还是UUID？" class="headerlink" title="Q36.主键一般用自增ID还是UUID？"></a>Q36.<strong>主键一般用自增ID还是UUID？</strong></h4><p>使用自增ID的好处：</p><blockquote><p>字段长度较 UUID 会小很多。<br>数据库自动编号，按顺序存放，利于检索<br>无需担心主键重复问题</p></blockquote><p>使用自增ID的缺点：</p><blockquote><p>因为是自增，在某些业务场景下，容易被其他人查到业务量。<br>发生数据迁移时，或者表合并时会非常麻烦<br>在高并发的场景下，竞争自增锁会降低数据库的吞吐能力</p></blockquote><p>使用UUID的优点：</p><blockquote><p>唯一标识，不用考虑重复问题，在数据拆分、合并时也能达到全局的唯一性。<br>可以在应用层生成，提高数据库的吞吐能力。<br>无需担心业务量泄露的问题。</p></blockquote><p>使用UUID的缺点：</p><blockquote><p>因为UUID是随机生成的，所以会发生随机IO，影响插入速度，并且会造成硬盘的使用率较低。<br>UUID占用空间较大，建立的索引越多，造成的影响越大。<br>UUID之间比较大小较自增ID慢不少，影响查询速度。</p></blockquote><h4 id="Q37-视图View："><a href="#Q37-视图View：" class="headerlink" title="Q37.视图View："></a>Q37.视图View：</h4><p>视图是从一个或者多个表（或视图）导出的表，其内容由查询定义。视图是一个虚拟表，数据库中只存储视图的定义，不存储视图对应的数据，在对视图的数据进行操作时，系统根据视图的定义去操作相应的基本表。</p><p>（1）视图的优点：<br>简化了操作，把经常使用的数据定义为视图<br>安全性，用户只能查询和修改能看到的数据<br>逻辑上的独立性，屏蔽了真实表的结构带来的影响</p><p>（2）视图的缺点：<br>性能差，数据库必须把对视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也要把它变成一个复杂的结合体，需要花费一定的时间。</p><h4 id="Q38-触发器Trigger"><a href="#Q38-触发器Trigger" class="headerlink" title="Q38.触发器Trigger"></a>Q38.触发器Trigger</h4><p>触发器是与表有关的数据库对象，当触发器所在表上出现指定事件并满足定义条件的时候，将执行触发器中定义的语句集合。</p><h4 id="Q39-游标Cursor"><a href="#Q39-游标Cursor" class="headerlink" title="Q39.游标Cursor"></a>Q39.游标Cursor</h4><p>游标，就是游动的标识，可以充当指针的作用，使用游标可以遍历查询数据库返回的结果集中的所有记录，但是每次只能提取一条记录，即每次只能指向并取出一行的数据，以便进行相应的操作。</p><h4 id="Q40-最左前缀"><a href="#Q40-最左前缀" class="headerlink" title="Q40.最左前缀"></a>Q40.最左前缀</h4><p>下⾯面举例例对其进⾏行行说明:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">1. 一个 2 列列的索引 (name, age)，对 (name)、(name, age) 上建⽴立了了索引;<br>2. 一个 3 列列的索引 (name, age, sex)，对 (name)、(name, age)、(name, age, sex) 上建⽴立了了索引<br></code></pre></td></tr></table></figure><p>1、 B+ 树的数据项是复合的数据结构，⽐比如:(name, age, sex) 的时候，B+ 树是按照从左到右的顺序来建⽴立搜索 树的，⽐比如:当(⼩小明, 22, 男)这样的数据来检索的时候，B+ 树会优先⽐比较 name 来确定下⼀一步的所搜⽅方向，如果 name 相同再依次⽐比较 age 和 sex，最后得到检索的数据。但当 (22, 男) 这样没有 name 的数据来的时候，B+ 树 就不不知道第⼀一步该查哪个节点，因为建⽴立搜索树的时候 name 就是第⼀一个⽐比较因⼦子，必须要先根据 name 来搜索 才能知道下⼀一步去哪⾥里里查询。<br>2、 当 (⼩小明, 男) 这样的数据来检索时，B+ 树可以⽤用 name 来指定搜索⽅方向，但下⼀一个字段 age 的缺失，所以只能 把名字等于⼩小明的数据都找到，然后再匹配性别是男的数据了了， 这个是⾮非常􏰀要的性质，即索引的最左匹配特性。</p><h4 id="Q41-谈谈你对水平切分和垂直切分的理理解"><a href="#Q41-谈谈你对水平切分和垂直切分的理理解" class="headerlink" title="Q41.谈谈你对水平切分和垂直切分的理理解?"></a>Q41.谈谈你对水平切分和垂直切分的理理解?</h4><p><strong>⽔平切分</strong><br>是将同一个表中的记录拆分到多个结构相同的表中。当⼀个表的数据不断增多时，⽔平切分是必然的选择，它可以将数据分布到集群的不同节点上，从⽽缓存单个数据库的压力。<br><strong>垂直切分</strong><br>垂直切分是将⼀张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使⽤用的列切分到不同的表中。例如:将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p><h4 id="Q42-数据库并发策略"><a href="#Q42-数据库并发策略" class="headerlink" title="==Q42.数据库并发策略=="></a>==Q42.数据库并发策略==</h4><p>发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。</p><p><strong>乐观锁</strong><br>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据;悲观锁就刚好相反，觉得自 己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度;时间 戳就是不加锁，通过时间戳来控制并发出现的问题。</p><p><strong>悲观锁</strong><br>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加 锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数 据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允 许其他用户访问那部分数据。</p><p><strong>时间戳</strong><br>时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字 段也读出来，当写回去的时候，把该字段加 1，提交之前 ，跟数据库的该字段比较一次，如果比数 据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Q1-MySQL-的逻辑架构了解吗&quot;&gt;&lt;a href=&quot;#Q1-MySQL-的逻辑架构了解吗&quot; class=&quot;headerlink&quot; title=&quot;==Q1:MySQL 的逻辑架构了解吗?==&quot;&gt;&lt;/a&gt;==Q1:MySQL 的逻辑架构了解吗?==&lt;/h4&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/Kafka/"/>
    <id>http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/Kafka/</id>
    <published>2021-11-29T02:39:39.000Z</published>
    <updated>2021-11-29T02:42:46.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h4 id="1-Kafka-有⼏种数据保留的策略"><a href="#1-Kafka-有⼏种数据保留的策略" class="headerlink" title="1. Kafka 有⼏种数据保留的策略?"></a>1. Kafka 有⼏种数据保留的策略?</h4><p>1.按照过期时间保留。2.按照存储的消息⼤小保留。</p><h4 id="2-请说明什么是Apache-Kafka"><a href="#2-请说明什么是Apache-Kafka" class="headerlink" title="2. 请说明什么是Apache Kafka?"></a>2. <strong>请说明什么是Apache Kafka?</strong></h4><p>Apach Kafka 一种发布订阅消息系统。Kafka是一个<strong>分布式</strong>，<strong>可划分的</strong>，<strong>冗余备份</strong>的持久性的日志服务，它主要用于处理<strong>==流式数据==</strong>。</p><h4 id="2-0-Apache-Kafka是分布式流处理平台吗？如果是，你能用它做什么？"><a href="#2-0-Apache-Kafka是分布式流处理平台吗？如果是，你能用它做什么？" class="headerlink" title="2.0 Apache Kafka是分布式流处理平台吗？如果是，你能用它做什么？"></a>2.0 Apache Kafka是分布式流处理平台吗？如果是，你能用它做什么？</h4><p>Kafka是一个流处理平台。它可以完成以下工作：</p><ol><li>轻松推送记录。2. 可以存储大量记录，而不会出现任何存储问题。3. 它还可以在记录进入时对其进行处理。</li></ol><h4 id="2-1-1-Kafka的优点有那些？"><a href="#2-1-1-Kafka的优点有那些？" class="headerlink" title="==2.1.1 Kafka的优点有那些？=="></a>==2.1.1 Kafka的优点有那些？==</h4><ul><li><strong>高吞吐量</strong>：我们在Kafka中不需要任何大型硬件，因为它能够处理高速和大容量数据。此外，它还可以支持每秒数千条消息的消息吞吐量。</li><li><strong>低延迟</strong>：Kafka可以轻松处理这些消息，具有毫秒级的极低延迟，这是大多数新用例所要求的。</li><li><strong>容错</strong>：Kafka能够抵抗集群中的节点/机器故障。</li><li><strong>持久性</strong>：由于Kafka支持消息复制，因此消息永远不会丢失。这是持久性背后的原因之一。</li><li><strong>可扩展性</strong>：Kafka可以扩展，而不需要通过添加额外的节点而在运行中造成任何停机。</li></ul><h4 id="2-1-2-Kafka的缺点有哪些？"><a href="#2-1-2-Kafka的缺点有哪些？" class="headerlink" title="2.1.2 Kafka的缺点有哪些？"></a>2.1.2 Kafka的缺点有哪些？</h4><ul><li>由于是批量发送，数据并非真正的实时；</li><li>对于mqtt协议不支持；</li><li>不支持物联网传感数据直接接入；</li><li>仅支持统一分区内消息有序，无法实现全局消息有序；</li><li>监控不完善，需要安装插件；</li><li>依赖zookeeper进行元数据管理；</li></ul><h4 id="2-2-为什么要使用-Kafka？为什么要使用消息队列？"><a href="#2-2-为什么要使用-Kafka？为什么要使用消息队列？" class="headerlink" title="2.2 为什么要使用 Kafka？为什么要使用消息队列？"></a>2.2 为什么要使用 Kafka？为什么要使用消息队列？</h4><p><strong>解耦，削峰，异步和</strong></p><ul><li><strong>冗余</strong>：<br>可以采用一对多的方式，一个生产者发布消息，可以被多个订阅topic的服务消费到，供多个毫无关联的业务使用。</li><li><strong>健壮性</strong>：<br>消息队列可以堆积请求，所以消费端业务即使短时间死掉，也不会影响主要业务的正常进行。</li></ul><h4 id="3-Kafka中有哪几个组件"><a href="#3-Kafka中有哪几个组件" class="headerlink" title="3. Kafka中有哪几个组件?"></a>3. Kafka中有哪几个组件?</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwtzu76u8dj31hn0u0jy1.jpg" alt="image-20211127204436299"></p><p><strong>主题(Topic)</strong>：Kafka主题是一堆或一组消息。<br><strong>生产者(Producer)</strong>：在Kafka，生产者发布通信以及向Kafka主题发布消息。<br><strong>消费者(Consumer)</strong>：Kafka消费者订阅了一个主题，并且还从主题中读取和处理消息。<br><strong>经纪人(Brokers)</strong>：在管理主题中的消息存储时，我们使用Kafka Brokers</p><h4 id="3-1-什么是消费者组？"><a href="#3-1-什么是消费者组？" class="headerlink" title="3.1 什么是消费者组？"></a>3.1 什么是消费者组？</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwuv90p0frj314j0u0wih.jpg" alt="image-20211128145127151"></p><p>消费者组的概念是Apache Kafka独有的。基本上，每个Kafka消费群体都由一个或多个共同消费一组订阅主题的消费者组成。</p><p>详见 <strong>25. Consumer Group 是什么概念？</strong></p><h4 id="3-2-Leader和Follower的概念是什么？"><a href="#3-2-Leader和Follower的概念是什么？" class="headerlink" title="3.2 Leader和Follower的概念是什么？"></a>3.2 Leader和Follower的概念是什么？</h4><p>在Kafka的每个分区中，都有一个服务器充当leader，0到多个服务器充当follower的角色。</p><h4 id="3-3-Kafka-Follower如何与Leader同步数据"><a href="#3-3-Kafka-Follower如何与Leader同步数据" class="headerlink" title="3.3 Kafka Follower如何与Leader同步数据?"></a>3.3 Kafka Follower如何与Leader同步数据?</h4><p>Kafka 的复制机制既不是完全的同步复制，也不是单纯的异步复制。完全同步复制要求 All Alive Follower 都复制完，这条消息才会被认为 commit，这种复制方式极大的影响了吞吐率。而异步复制方式下，Follower 异步的从 Leader 复制数据，数据只要被 Leader 写入 log 就被认为已经 commit，这种情况下，如果 leader 挂掉，会丢失数据，kafka 使用 ISR 的方式很好的均衡了确保数据不丢失以及吞吐率。Follower 可以批量的从 Leader 复制数据，而且 Leader 充分利用磁盘顺序读以及 send file(zero copy) 机制，这样极大的提高复制性能，内部批量写磁盘，大幅减少了 Follower 与 Leader 的消息量差。</p><h4 id="4-数据传输的事物定义有哪三种"><a href="#4-数据传输的事物定义有哪三种" class="headerlink" title="4. 数据传输的事物定义有哪三种?"></a>4. 数据传输的事物定义有哪三种?</h4><p>数据传输的事务定义通常有以下三种级别:<br>(1)最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输<br>(2)最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输.<br>(3)精确的一次(Exactly once): 不会漏传输也不会重复传输,每个消息都传输被一次而 且仅仅被传输一次，这是大家所期望的</p><h4 id="5-Kafka-判断一个节点是否还活着有那两个条件"><a href="#5-Kafka-判断一个节点是否还活着有那两个条件" class="headerlink" title="==5. Kafka 判断一个节点是否还活着有那两个条件?=="></a>==5. Kafka 判断一个节点是否还活着有那两个条件?==</h4><p>(1)节点必须可以维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每个节点的连接<br>(2)如果节点是个 follower,他必须能及时的同步 leader 的写操作，延时不能太久</p><h4 id="5-1-Kafka中的-zookeeper-起到什么作用？可以不用zookeeper吗？"><a href="#5-1-Kafka中的-zookeeper-起到什么作用？可以不用zookeeper吗？" class="headerlink" title="==5.1 Kafka中的 zookeeper 起到什么作用？可以不用zookeeper吗？=="></a>==5.1 Kafka中的 zookeeper 起到什么作用？可以不用zookeeper吗？==</h4><p>zookeeper 是一个分布式的协调组件，早期版本的kafka用zk做meta信息存储，consumer的消费状态，group 的管理以及 offset 的值。考虑到 zookeeper 本身的一些因素以及整个架构较大概率存在单点问题，新版本中逐渐弱化了 zookeeper 的作用。新的 consumer 使用了 kafka 内部的 group coordination 协议，也减少了对 zookeeper 的依赖，</p><p>但是 broker 依然依赖于 zookeeper，zookeeper 在kafka中还用来选举 controller 和检测 broker 是否存活等等。</p><h4 id="6-producer-是否直接将数据发送到-broker-的-leader-主节点"><a href="#6-producer-是否直接将数据发送到-broker-的-leader-主节点" class="headerlink" title="6. producer 是否直接将数据发送到 broker 的 leader(主节点)?"></a>6. producer 是否直接将数据发送到 broker 的 leader(主节点)?</h4><p>是的。producer 直接将数据发送到 broker 的 leader(主节点)，不需要在多个节点进行分发，为了 帮助 producer 做到这点，所有的 Kafka 节点都可以及时的告知:哪些节点是活动的，目标 topic 目标分区的 leader 在哪。这样 producer 就可以直接将消息发送到目的地了</p><h4 id="7-Kafa-consumer-是否可以消费指定分区消息"><a href="#7-Kafa-consumer-是否可以消费指定分区消息" class="headerlink" title="7. Kafa consumer 是否可以消费指定分区消息?"></a>7. Kafa consumer 是否可以消费指定分区消息?</h4><p>Kafa consumer 消费消息时，向broker发出”fetch”请求去消费特定分区的消息，consumer指定消息在日志中的偏移量(offset)，就可以消费从这个位置开始的消息，customer拥有了offset的控制权，可以向后回滚去重新消费之前的消息，这是很有意义的</p><h4 id="7-1-Kafka-分区的目的？"><a href="#7-1-Kafka-分区的目的？" class="headerlink" title="7.1 Kafka 分区的目的？"></a>7.1 Kafka 分区的目的？</h4><p>分区对于 Kafka 集群的好处是：实现负载均衡。分区对于消费者来说，可以提高并发度，提高效率。</p><h4 id="8-Kafka-消息是采用-Pull-模式，还是-Push-模式"><a href="#8-Kafka-消息是采用-Pull-模式，还是-Push-模式" class="headerlink" title="==8. Kafka 消息是采用 Pull 模式，还是 Push 模式?=="></a>==8. Kafka 消息是采用 Pull 模式，还是 Push 模式?==</h4><p><strong>Kafka 还是选取了传统的pull模式。</strong></p><p>Kafka 最初考虑的问题是，customer 应该从 brokes 拉取消息还是 brokers 将消息推送到 consumer，也就是 pull 还 push。在这方面，Kafka 遵循了一种大部分消息系统共同的传统的设计:<strong>producer 将消息推送到 broker，consumer 从 broker 拉取消息</strong>。</p><p>一些消息系统比如 Scribe 和 Apache Flume 采用了 push 模式，将消息推送到下游的 consumer。这样做有好处也有坏处:由 broker 决定消息推送的速率，对于不同消费速率的 consumer 就不太好处理了。消息系统都致力于让 consumer 以最大的速率最快速的消费消息，但不幸的是，<strong>push 模式下，当 broker 推送的速率远大于 consumer 消费的速率时， consumer 恐怕就要崩溃了</strong>。最终 Kafka 还是选取了传统的 pull 模式。</p><p><strong>Pull 模式的另外一个好处是 consumer 可以自主决定是否批量的从 broker 拉取数据</strong>。Push 模式必须在不知道下游 consumer 消费能力和消费策略的情况下决定是立即推送每条消息还是缓存之后批量推送。如果为了避免 consumer 崩溃而采用较低的推送速率，将可能导致一 次只推送较少的消息而造成浪费。Pull 模式下，consumer 就可以根据自己的消费能力去决定这些策略</p><p><strong>Pull 有个缺点是，如果 broker 没有可供消费的消息，将导致 consumer 不断在循环中轮询， 直到新消息到达</strong>。为了避免这点，Kafka 有个参数可以让 consumer 阻塞直到新消息到达 (当然也可以阻塞直到消息的数量达到某个特定的量这样就可以批量发送）。</p><h4 id="9-Kafka-存储在硬盘上的消息格式是什么"><a href="#9-Kafka-存储在硬盘上的消息格式是什么" class="headerlink" title="==9. Kafka 存储在硬盘上的消息格式是什么?=="></a>==9. <strong>Kafka 存储在硬盘上的消息格式是什么?</strong>==</h4><p>消息由一个固定长度的头部和可变长度的字节数组组成。头部包含了一个版本号和 CRC32 校验码。</p><ul><li>消息长度: 4 bytes (value: 1+4+n)</li><li>版本号: 1 byte</li><li>CRC 校验码: 4 bytes</li><li>具体的消息: n bytes</li></ul><h4 id="9-1-Kafka可以接收的消息最大为多少？"><a href="#9-1-Kafka可以接收的消息最大为多少？" class="headerlink" title="9.1 Kafka可以接收的消息最大为多少？"></a>9.1 Kafka可以接收的消息最大为多少？</h4><p>Kafka可以接收的最大消息大小约为1000000字节。</p><h4 id="10-Kafka-高效文件存储设计特点"><a href="#10-Kafka-高效文件存储设计特点" class="headerlink" title="10. Kafka 高效文件存储设计特点:"></a>10. Kafka 高效文件存储设计特点:</h4><p>(1).Kafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。<br>(2).通过索引信息可以快速定位 message 和确定 response 的最大大小。<br>(3).通过 index 元数据全部映射到 memory，可以避免 segment file 的 IO 磁盘操作。<br>(4).通过索引文件稀疏存储，可以大幅降低 index 文件元数据占用空间大小</p><h4 id="11-Kafka-与传统消息系统之间有三个关键区别"><a href="#11-Kafka-与传统消息系统之间有三个关键区别" class="headerlink" title="11. Kafka 与传统消息系统之间有三个关键区别"></a>11. Kafka 与传统消息系统之间有三个关键区别</h4><p>(1).Kafka <strong>持久化日志</strong>，这些日志可以被重复读取和无限期保留<br>(2).Kafka 是一个<strong>分布式系统:</strong>它以集群的方式运行，可以<strong>灵活伸缩</strong>，在内部通过复制数据<strong>提升容错能力和高可用性</strong><br>(3).Kafka <strong>支持实时的流式处理</strong></p><h4 id="12-Kafka-创建-Topic-时如何将分区放置到不同的-Broker-中"><a href="#12-Kafka-创建-Topic-时如何将分区放置到不同的-Broker-中" class="headerlink" title="12. Kafka 创建 Topic 时如何将分区放置到不同的 Broker 中"></a>12. Kafka 创建 Topic 时如何将分区放置到不同的 Broker 中</h4><ul><li>副本因子不能大于 Broker 的个数;</li><li>第一个分区(编号为 0)的第一个副本放置位置是随机从 brokerList 选择的; </li><li>其他分区的第一个副本放置位置相对于第 0 个分区依次往后移。也就是如果我们有 5 个 Broker，5个分区，假设第一个分区放在第四个 Broker 上，那么第二个分区将会放在第五 个 Broker 上;第三个分区将会放在第一个 Broker 上;第四个分区将会放在第二个 Broker 上，依次类推;</li><li>剩余的副本相对于第一个副本放置位置其实是由 nextReplicaShift 决定的，而这个数也是随机产生的</li></ul><h4 id="13-Kafka-新建的分区会在哪个目录下创建"><a href="#13-Kafka-新建的分区会在哪个目录下创建" class="headerlink" title="13. Kafka 新建的分区会在哪个目录下创建"></a>13. Kafka 新建的分区会在哪个目录下创建</h4><p>在启动 Kafka 集群之前，我们需要配置好 log.dirs 参数，其值是 Kafka 数据的存放目录，这个参数可以配置多个目录，目录之间使用逗号分隔，通常这些目录是分布在不同的磁盘 上用于提高读写性能。当然我们也可以配置 log.dir 参数，含义一样。只需要设置其中一个即可。如果 log.dirs 参数只配置了一个目录，那么分配到各个 Broker 上的分区肯定只能在这个 目录下创建文件夹用于存放数据。</p><p>但是如果 log.dirs 参数配置了多个目录，那么 Kafka 会在哪个文件夹中创建分区目录呢? </p><p>答案是:<strong>Kafka 会在含有分区目录最少的文件夹中创建新的分区目录，</strong>分区目录名为 Topic 名+分区 ID。注意，是分区文件夹总数最少的目录，而不是磁盘使用量最少的目录!也就 是说，如果你给 log.dirs 参数新增了一个新的磁盘，新的分区目录肯定是先在这个新的磁盘上创建直到这个新的磁盘目录拥有的分区目录不是最少为止。</p><h4 id="14-partition-的数据如何保存到硬盘"><a href="#14-partition-的数据如何保存到硬盘" class="headerlink" title="14. partition 的数据如何保存到硬盘"></a>14. partition 的数据如何保存到硬盘</h4><ol><li>topic 中的多个 partition 以文件夹的形式保存到 broker，每个分区序号从 0 递增， 且消息有序</li><li>Partition 文件下有多个 segment(xxx.index，xxx.log)</li><li>segment 文件里的大小和配置文件大小一致可以根据要求修改默认为 1g</li><li>如果大小大于 1g 时，会滚动一个新的 segment 并且以上一个 segment 最后一条消息的偏移量命名</li></ol><h4 id="15-kafka-的-ack-机制"><a href="#15-kafka-的-ack-机制" class="headerlink" title="==15. kafka 的 ack 机制=="></a>==15. kafka 的 ack 机制==</h4><p><strong>request.required.acks 有三个值 0，1， -1</strong>。</p><p>0: 生产者不会等待 broker 的 ack，这个延迟最低但是存储的保证最弱当 server 挂掉的时候 就会丢数据</p><p>1: 服务端会等待 ack 值leader副本确认接收到消息后发送 ack 但是如果 leader 挂掉后他不确保是否复制完成新 leader 也会导致数据丢失</p><p>-1: 同样在1的基础上服务端会等所有的 follower 的Replica受到数据后才会收到 leader 发出 的 ack，这样数据不会丢失</p><h4 id="16-Kafka-的消费者如何消费数据"><a href="#16-Kafka-的消费者如何消费数据" class="headerlink" title="16. Kafka 的消费者如何消费数据"></a>16. Kafka 的消费者如何消费数据</h4><p>消费者每次消费数据的时候，消费者都会记录消费的物理偏移量(offset)的位置，等到下次消费时，他会接着上次位置继续消费。</p><h4 id="16-1-偏移的作用是什么？"><a href="#16-1-偏移的作用是什么？" class="headerlink" title="16.1 偏移的作用是什么？"></a>16.1 偏移的作用是什么？</h4><p>给分区中的消息提供了一个顺序ID号，我们称之为偏移量。因此，为了唯一地识别分区中的每条消息，我们使用这些偏移量。</p><h4 id="17-消费者负载均衡策略"><a href="#17-消费者负载均衡策略" class="headerlink" title="17. 消费者负载均衡策略"></a>17. 消费者负载均衡策略</h4><p>一个消费者组中的一个分片对应一个消费者成员，他能保证每个消费者成员都能访问，如果组中成员太多会有空闲的成员。</p><h4 id="18-数据有序"><a href="#18-数据有序" class="headerlink" title="18. 数据有序"></a>18. 数据有序</h4><p>一个消费者组里它的内部是有序的 </p><p>消费者组与消费者组之间是无序的</p><h4 id="19-kafaka-生产数据时数据的分组策略"><a href="#19-kafaka-生产数据时数据的分组策略" class="headerlink" title="19.kafaka 生产数据时数据的分组策略"></a>19.kafaka 生产数据时数据的分组策略</h4><ul><li>生产者决定数据产生到集群的哪个 partition 中</li><li>每一条消息都是以(key，value)格式</li><li>Key 是由生产者发送数据传入</li><li>所以生产者(key)决定了数据产生到集群的哪个 partition</li></ul><h4 id="20-Kafka系统工具有哪些类型？"><a href="#20-Kafka系统工具有哪些类型？" class="headerlink" title="20. Kafka系统工具有哪些类型？"></a>20. Kafka系统工具有哪些类型？</h4><ol><li><strong>Kafka迁移工具</strong>：它有助于将代理从一个版本迁移到另一个版本。</li><li><strong>Mirror Maker</strong>：Mirror Maker工具有助于将一个Kafka集群的镜像提供给另一个。</li><li><strong>消费者检查</strong>:对于指定的主题集和消费者组，它显示主题，分区，所有者。</li></ol><h4 id="20-1-监控-Kafka-的框架都有哪些"><a href="#20-1-监控-Kafka-的框架都有哪些" class="headerlink" title="20.1 监控 Kafka 的框架都有哪些?"></a>20.1 监控 Kafka 的框架都有哪些?</h4><ol><li><strong>Kafka Manager</strong>:应该算是最有名的专属 Kafka 监控框架了，是独立的监控系统。</li><li><strong>Kafka Monitor</strong>:LinkedIn 开源的免费框架，支持对集群进行系统测试，并实时监控测试结果。</li><li><strong>CruiseControl</strong>:也是 LinkedIn 公司开源的监控框架，用于实时监测资源使用率，以及 提供常用运维操作等。无 UI 界面，只提供REST API。</li><li><strong>JMX 监控</strong>:由于 Kafka 提供的监控指标都是基于 JMX 的，因此，市面上任何能够集成 JMX 的框架都可以使用，比如 Zabbix 和 Prometheus。</li><li><strong>已有大数据平台自己的监控体系</strong>:像 Cloudera 提供的 CDH 这类大数据平台，天然就提 供 Kafka 监控方案。</li><li><strong>JMXTool</strong>:社区提供的命令行工具，能够实时监控 JMX 指标。答上这一条，属于绝对 的加分项，因为知道的人很少，而且会给人一种你对 Kafka 工具非常熟悉的感觉。如果 你暂时不了解它的用法，可以在命令行以无参数方式执行一下kafka-run-class.sh kafka.tools.JmxTool，学习下它的用法。</li></ol><h4 id="21-Kafka-是如何实现高吞吐率的？"><a href="#21-Kafka-是如何实现高吞吐率的？" class="headerlink" title="==21 Kafka 是如何实现高吞吐率的？=="></a>==21 Kafka 是如何实现高吞吐率的？==</h4><p>Kafka是分布式消息系统，需要处理海量的消息，Kafka的设计是把所有的消息都写入速度低容量大的硬盘，以此来换取更强的存储能力，但实际上，使用硬盘并没有带来过多的性能损失。kafka主要使用了以下几个方式实现了超高的吞吐率：</p><ul><li><strong>顺序读写</strong>；由于现代的操作系统提供了预读和写技术，磁盘的顺序写大多数情况下比随机写内存还要快。</li><li><strong>零拷贝</strong>: 减少拷贝次数</li><li><strong>批量发送</strong>: Batching of Messages 批量量处理。合并小的请求，然后以流的方式进行交互，直顶网络上限。</li><li><strong>Pull 拉模式</strong>:使用拉模式进行消息的获取消费，与消费端处理能力相符。</li><li><strong>缓存</strong>: Cache Filesystem Cache PageCache缓存</li><li><strong>文件分段。</strong></li><li><strong>数据压缩。</strong></li></ul><blockquote><p>零拷贝</p><p>先来看看非零拷贝的情况：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwuvcfvylyj31ea0u0mzl.jpg" alt="image-20211128145445145"></p><p>可以看到数据的拷贝从内存拷贝到 Kafka 服务进程那块，又拷贝到 Socket 缓存那块，整个过程耗费的时间比较高。</p><p>Kafka 利用了 Linux 的 sendFile 技术（NIO），省去了进程切换和一次数据拷贝，让性能变得更好。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwuvczksbwj31fe0u0di3.jpg" alt="image-20211128145516465"></p></blockquote><h4 id="22-Kafka中的-ISR、AR-又代表什么？ISR-的伸缩又指什么？"><a href="#22-Kafka中的-ISR、AR-又代表什么？ISR-的伸缩又指什么？" class="headerlink" title="22. Kafka中的 ISR、AR 又代表什么？ISR 的伸缩又指什么？"></a>22. Kafka中的 ISR、AR 又代表什么？ISR 的伸缩又指什么？</h4><p>ISR：In-Sync Replicas 副本同步队列；</p><p>ISR是由leader维护，follower从leader同步数据有一些延迟（包括延迟时间replica.lag.time.max.ms和延迟条数replica.lag.max.messages两个维度, 版本0.10.x中只支持replica.lag.time.max.ms这个维度），任意一个超过阈值都会把follower剔除出ISR, 存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。AR=ISR+OSR。</p><p>AR：Assigned Replicas 所有副本；</p><h4 id="22-1-什么情况下一个-Broker-会从ISR中踢出去"><a href="#22-1-什么情况下一个-Broker-会从ISR中踢出去" class="headerlink" title="22.1 什么情况下一个 Broker 会从ISR中踢出去?"></a>22.1 什么情况下一个 Broker 会从ISR中踢出去?</h4><p>leader 会维护一个与其基本保持同步的 Replica 列表，该列表称为 ISR(in-sync Replica)，每个 Partition 都会有一个 ISR，而且是由 leader 动态维护 ，如果一个 follower 比一个 leader 落后太多，或者超过一定时间未发起数据复制请求，则 leader 将其重 ISR 中移除 。</p><h4 id="22-2-如果-Leader-Crash-时，ISR为空怎么办"><a href="#22-2-如果-Leader-Crash-时，ISR为空怎么办" class="headerlink" title="22.2 如果 Leader Crash 时，ISR为空怎么办"></a>22.2 如果 Leader Crash 时，ISR为空怎么办</h4><p>kafka在Broker端提供了一个配置参数：unclean.leader.election,这个参数有两个值：</p><p>true（默认）：<br>允许不同步副本成为leader，由于不同步副本的消息较为滞后，此时成为leader，可能会出现消息不一致的情况。<br>false：<br>不允许不同步副本成为leader，此时如果发生ISR列表为空，会一直等待旧leader恢复，降低了可用性。</p><h4 id="22-3-副本长时间不在ISR中，这意味着什么？"><a href="#22-3-副本长时间不在ISR中，这意味着什么？" class="headerlink" title="22.3 副本长时间不在ISR中，这意味着什么？"></a>22.3 副本长时间不在ISR中，这意味着什么？</h4><p>意味着 follower 不能像 leader 收集数据那样快速地获取数据。</p><h4 id="23-Kafka-Producer如何优化写入速度"><a href="#23-Kafka-Producer如何优化写入速度" class="headerlink" title="23. Kafka Producer如何优化写入速度?"></a>23. Kafka Producer如何优化写入速度?</h4><ul><li>增加线程</li><li>提高 batch.size</li><li>增加更多 producer 实例</li><li>增加 partition 数</li><li>设置 acks=-1 时，如果延迟增大：可以增大 num.replica.fetchers（follower 同步数据的线程数）来调解；</li><li>跨数据中心的传输：增加 socket 缓冲区设置以及 OS tcp 缓冲区设置。</li></ul><h4 id="24-Kafka-Unclean-配置代表什么？会对-spark-streaming-消费有什么影响？"><a href="#24-Kafka-Unclean-配置代表什么？会对-spark-streaming-消费有什么影响？" class="headerlink" title="24. Kafka Unclean 配置代表什么？会对 spark streaming 消费有什么影响？"></a>24. Kafka Unclean 配置代表什么？会对 spark streaming 消费有什么影响？</h4><p>unclean.leader.election.enable 为 true 的话，意味着非 ISR 集合的 broker 也可以参与选举，这样有可能就会丢数据，spark streaming在消费过程中拿到的 end offset 会突然变小，导致 spark streaming job 挂掉。如果 unclean.leader.election.enable 参数设置为 true，就有可能发生数据丢失和数据不一致的情况，Kafka 的可靠性就会降低；而如果 unclean.leader.election.enable 参数设置为 false，Kafka 的可用性就会降低。</p><h4 id="25-Kafka-中-Consumer-Group-是什么概念？"><a href="#25-Kafka-中-Consumer-Group-是什么概念？" class="headerlink" title="==25. Kafka 中 Consumer Group 是什么概念？=="></a>==25. Kafka 中 Consumer Group 是什么概念？==</h4><p>同样是逻辑上的概念，是Kafka实现单播和广播两种消息模型的手段。同一个topic的数据，会广播给不同的group；同一个group中的worker，只有一个worker能拿到这个数据。换句话说，对于同一个topic，每个group都可以拿到同样的所有数据，但是数据进入group后只能被其中的一个worker消费。group内的worker可以使用多线程或多进程来实现，也可以将进程分散在多台机器上，worker的数量通常不超过partition的数量，且二者最好保持整数倍关系，因为Kafka在设计时假定了一个partition只能被一个worker消费（同一group内）。</p><h4 id="26-Kafka-中的消息是否会丢失和重复消费？"><a href="#26-Kafka-中的消息是否会丢失和重复消费？" class="headerlink" title="==26. Kafka 中的消息是否会丢失和重复消费？=="></a>==26. Kafka 中的消息是否会丢失和重复消费？==</h4><p>要确定Kafka的消息是否丢失或重复，从两个方面分析入手：消息发送和消息消费。</p><ul><li><p>消息发送：Kafka消息发送有两种方式：<strong>同步</strong>（sync）和<strong>异步</strong>（async），默认是同步方式，可通过producer.type属性进行配置。</p><p>见“15. Kafka的ack机制”</p></li><li><p>消息消费：Kafka消息消费有两个consumer接口，Low-level API和High-level API：</p><blockquote><p>Low-level API：消费者自己维护offset等值，可以实现对Kafka的完全控制；</p><p>High-level API：封装了对parition和offset的管理，使用简单；<br>如果使用高级接口High-level API，可能存在一个问题就是当消息消费者从集群中把消息取出来、并提交了新的消息offset值后，还没来得及消费就挂掉了，那么下次再消费时之前没消费成功的消息就“诡异”的消失了；</p></blockquote></li><li><p>解决办法：</p><ul><li>针对消息丢失：<br>同步模式下，确认机制设置为-1，即让消息写入Leader和Follower之后再确认消息发送成功；<br>异步模式下，为防止缓冲区满，可以在配置文件设置不限制阻塞超时时间，当缓冲区满时让生产者一直处于阻塞状态；<ul><li>针对消息重复：<br>将消息的唯一标识保存到外部介质中，每次消费时判断是否处理过即可。</li></ul></li></ul></li></ul><h4 id="27-为什么Kafka不支持读写分离？"><a href="#27-为什么Kafka不支持读写分离？" class="headerlink" title="==27. 为什么Kafka不支持读写分离？=="></a>==27. 为什么Kafka不支持读写分离？==</h4><p>在 Kafka 中，生产者写入消息、消费者读取消息的操作都是与 leader 副本进行交互的，从而实现的是一种主写主读的生产消费模型。</p><p>Kafka 并不支持主写从读，因为主写从读有 2 个很明 显的缺点:</p><p><strong>数据一致性问题。</strong>数据从主节点转到从节点必然会有一个延时的时间窗口，这个时间窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中 A 数据的值都为 X， 之后将主节点中 A 的值修改为 Y，那么在这个变更通知到从节点之前，应用读取从节点中的 A 数据的值并不为最新的 Y，由此便产生了数据不一致的问题。<br><strong>延时问题</strong>。类似 Redis 这种组件，数据从写入主节点到同步至从节点中的过程需要经历网络→主节点内存→网络→从节点内存这几个阶段，整个过程会耗费一定的时间。而在 Kafka 中，主从同步会比 Redis 更加耗时，它需要经历网络→主节点内存→主节点磁盘→网络→从节点内存→从节点磁盘这几个阶段。对延时敏感的应用而言，主写从读的功能并不太适用。</p><h4 id="28-Kafka-中是怎么体现消息顺序性的？"><a href="#28-Kafka-中是怎么体现消息顺序性的？" class="headerlink" title="28. Kafka 中是怎么体现消息顺序性的？"></a>28. Kafka 中是怎么体现消息顺序性的？</h4><p>kafka 每个 partition 中的消息在写入时都是有序的，消费时，每个 partition 只能被每一个 group 中的一个消费者消费，保证了消费时也是有序的。<br>整个 topic 不保证有序。如果为了保证 topic 整个有序，那么将 partition 调整为1.</p><h4 id="29-Kafka-如何实现延迟队列"><a href="#29-Kafka-如何实现延迟队列" class="headerlink" title="29. Kafka 如何实现延迟队列?"></a>29. Kafka 如何实现延迟队列?</h4><p>Kafka并没有使用JDK自带的Timer或者DelayQueue来实现延迟的功能，而是<strong>基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer）</strong></p><p><strong>Kafka中的TimingWheel专门用来执行插入和删除TimerTaskEntry的操作，而DelayQueue专门负责时间推进的任务</strong>。</p><h4 id="30-Kafka中的HW、LEO、LSO、LW等分别代表什么？"><a href="#30-Kafka中的HW、LEO、LSO、LW等分别代表什么？" class="headerlink" title="30. Kafka中的HW、LEO、LSO、LW等分别代表什么？"></a><strong>30. Kafka中的HW、LEO、LSO、LW等分别代表什么？</strong></h4><p>HW:High Watermark 高水位，取一个partition对应的ISR中最小的LEO作为HW，consumer最多只能消费到HW所在的位置上一条信息。<br>LEO:LogEndOffset 当前日志文件中下一条待写信息的offset<br>HW/LEO这两个都是指最后一条的下一条的位置而不是指最后一条的位置。<br>LSO:Last Stable Offset 对未完成的事务而言，LSO 的值等于事务中第一条消息的位置(firstUnstableOffset)，对已完成的事务而言，它的值同 HW 相同。<br>LW:Low Watermark 低水位, 代表 AR 集合中最小的 logStartOffset 值</p><h4 id="31-“消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？如果不正确，那么有没有什么hack的手段？"><a href="#31-“消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？如果不正确，那么有没有什么hack的手段？" class="headerlink" title="31. “消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？如果不正确，那么有没有什么hack的手段？"></a><strong>31. “消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？如果不正确，那么有没有什么hack的手段？</strong></h4><p>不正确，通过自定义分区分配策略，可以将一个consumer指定消费所有partition。</p><h4 id="32-优先副本是什么？它有什么特殊的作用？"><a href="#32-优先副本是什么？它有什么特殊的作用？" class="headerlink" title="32. 优先副本是什么？它有什么特殊的作用？"></a><strong>32. 优先副本是什么？它有什么特殊的作用？</strong></h4><p>优先副本 会是默认的leader副本 发生leader变化时重选举会优先选择优先副本作为leader</p><h4 id="33-如果我指定了一个offset，Kafka怎么查找到对应的消息？"><a href="#33-如果我指定了一个offset，Kafka怎么查找到对应的消息？" class="headerlink" title="33.如果我指定了一个offset，Kafka怎么查找到对应的消息？"></a>33.<strong>如果我指定了一个offset，Kafka怎么查找到对应的消息？</strong></h4><p>1.通过文件名前缀数字x找到该绝对offset 对应消息所在文件<br>2.offset-x为在文件中的相对偏移<br>3.通过index文件中记录的索引找到最近的消息的位置<br>4.从最近位置开始逐条寻找</p><h4 id="34-谈一谈-Kafka-的再均衡"><a href="#34-谈一谈-Kafka-的再均衡" class="headerlink" title="34. 谈一谈 Kafka 的再均衡"></a>34. 谈一谈 Kafka 的再均衡</h4><p>在Kafka中，当有新消费者加入或者订阅的topic数发生变化时，会触发Rebalance(再均衡：在同一个消费者组当中，分区的所有权从一个消费者转移到另外一个消费者)机制，Rebalance顾名思义就是重新均衡消费者消费。Rebalance的过程如下：</p><p>第一步：所有成员都向coordinator发送请求，请求入组。一旦所有成员都发送了请求，coordinator会从中选择一个consumer担任leader的角色，并把组成员信息以及订阅信息发给leader。<br>第二步：leader开始分配消费方案，指明具体哪个consumer负责消费哪些topic的哪些partition。一旦完成分配，leader会将这个方案发给coordinator。coordinator接收到分配方案之后会把方案发给各个consumer，这样组内的所有成员就都知道自己应该消费哪些分区了。<br>所以对于Rebalance来说，Coordinator起着至关重要的作用</p><h4 id="35-如何调优-Kafka"><a href="#35-如何调优-Kafka" class="headerlink" title="==35. 如何调优 Kafka?=="></a>==35. 如何调优 Kafka?==</h4><ul><li><strong>Producer 端</strong>:增加 batch.size、linger.ms，启用压缩，关闭重试等。</li><li><strong>Broker 端</strong>:增加 num.replica.fetchers，提升 Follower 同步 TPS，避免 Broker Full GC 等。</li><li><strong>Consumer</strong>:增加 fetch.min.bytes 等。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Kafka&quot;&gt;&lt;a href=&quot;#Kafka&quot; class=&quot;headerlink&quot; title=&quot;Kafka&quot;&gt;&lt;/a&gt;Kafka&lt;/h1&gt;&lt;h4 id=&quot;1-Kafka-有⼏种数据保留的策略&quot;&gt;&lt;a href=&quot;#1-Kafka-有⼏种数据保留的策略&quot; cla
      
    
    </summary>
    
    
      <category term="Kafka" scheme="http://yoursite.com/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>B树,B+树,B*树</title>
    <link href="http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/B%E6%A0%91,B+%E6%A0%91,B*%E6%A0%91/"/>
    <id>http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/B%E6%A0%91,B+%E6%A0%91,B*%E6%A0%91/</id>
    <published>2021-11-29T02:38:39.000Z</published>
    <updated>2021-11-29T02:40:33.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><h2 id="B-树概述"><a href="#B-树概述" class="headerlink" title="B-树概述"></a>B-树概述</h2><p>B-树,这里的 B 表示 balance( 平衡的意思),B-树是一种多路自平衡的搜索树（B树是<strong>一颗多路平衡查找树</strong>）<br>它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。下图是 B-树的简化图.</p><p><img src="https:////upload-images.jianshu.io/upload_images/1446087-bc023e47bc74cfa1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p><h2 id="为什么数据库s需要用B树，而不是用AVL树，二叉树？"><a href="#为什么数据库s需要用B树，而不是用AVL树，二叉树？" class="headerlink" title="为什么数据库s需要用B树，而不是用AVL树，二叉树？"></a>为什么数据库s需要用B树，而不是用AVL树，二叉树？</h2><p>传统用来搜索的平衡二叉树有很多，如 AVL 树，红黑树等。这些树在一般情况下查询性能非常好，但当数据非常大的时候它们就无能为力了。<strong>原因当数据量非常大时，内存不够用，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。</strong>一般而言内存访问的时间约为 50 ns，而磁盘在 10 ms 左右。速度相差了近 5 个数量级，磁盘读取时间远远超过了数据在内存中比较的时间。这说明程序大部分时间会阻塞在磁盘 IO 上。</p><p><strong>B-树是专门为外部存储器设计的，如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中。</strong></p><h2 id="B树规则："><a href="#B树规则：" class="headerlink" title="B树规则："></a>B树规则：</h2><p>（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则（类似AVL）。</p><p>（2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外。（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</p><p>（3）关键字数：枝节点的<strong>关键字数量大于等于ceil(m/2)-1个且小于等于M-1个</strong>（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</p><p>（4）<strong>所有叶子节点均在同一层</strong>、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null。</p><h3 id="如：（M-3）"><a href="#如：（M-3）" class="headerlink" title="如：（M=3）"></a>如：（M=3）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5k621vpj30hc07gq3f.jpg" alt="img"></p><h2 id="B树有如下特点"><a href="#B树有如下特点" class="headerlink" title="B树有如下特点:"></a>B树有如下特点:</h2><ol><li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；</li><li>在关键字全集内做一次查找,性能逼近二分查找；</li><li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li><li>自动层次控制；</li></ol><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><h2 id="B-树的定义"><a href="#B-树的定义" class="headerlink" title="B+树的定义"></a>B+树的定义</h2><p><strong>B+树是应文件系统所需而出的一种B-树的变型树。一棵m阶的B+树和m阶的B-树的差异在于：</strong></p><p>1.有n棵子树的结点中含有n个关键字，<strong>==每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点==</strong>。</p><p>2.<strong>所有的叶子结点中包含了全部关键字的信息</strong>，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p>3.所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</p><h2 id="B-树规则："><a href="#B-树规则：" class="headerlink" title="B+树规则："></a>B+树规则：</h2><p>（1）B+跟B树不同B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</p><p>（2）B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有关键字都在叶子结点出现；所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</p><p>（3）B+树叶子节点的关键字从小到大有序排列，<strong>左边结尾数据都会保存右边节点开始数据的指针</strong>。</p><p>（4）<strong>非叶子节点的子节点数=关键字数（来源百度百科）</strong>（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</p><h3 id="如：（M-3）-1"><a href="#如：（M-3）-1" class="headerlink" title="如：（M=3）"></a>如：（M=3）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5xemzu8j30ft09ljs5.jpg" alt="img"></p><p>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在</p><p>非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p><h2 id="B-的特性："><a href="#B-的特性：" class="headerlink" title="B+的特性："></a>B+的特性：</h2><p>1、B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</p><p>2、B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p><p>3、B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</p><p>4、B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p><h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h1><p><strong>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5z873zjj30ft09l3zc.jpg" alt="img"></p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a><strong>规则</strong></h2><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p><p>（1）首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b<em>树的初始化个数为（cei(2/3</em>m)）</p><p>（2）B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h2><p>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；</p><h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><p><strong>B-树：</strong></p><p>多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；</p><p>所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p><p><strong>B+树：</strong></p><p>在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；</p><p>B+树总是到叶子结点才命中；</p><p><strong>B*树：</strong></p><p>在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;B树&quot;&gt;&lt;a href=&quot;#B树&quot; class=&quot;headerlink&quot; title=&quot;B树&quot;&gt;&lt;/a&gt;B树&lt;/h1&gt;&lt;h2 id=&quot;B-树概述&quot;&gt;&lt;a href=&quot;#B-树概述&quot; class=&quot;headerlink&quot; title=&quot;B-树概述&quot;&gt;&lt;/a&gt;B-树概
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>B树,B+树插入删除图解</title>
    <link href="http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/B%E6%A0%91,B+%E6%A0%91%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%9B%BE%E8%A7%A3/"/>
    <id>http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/B%E6%A0%91,B+%E6%A0%91%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%9B%BE%E8%A7%A3/</id>
    <published>2021-11-29T02:38:39.000Z</published>
    <updated>2021-11-29T02:40:58.718Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-2-B树插入"><a href="#1-2-B树插入" class="headerlink" title="1.2 B树插入"></a>1.2 B树插入</h4><p>插入的时候，我们需要记住一个规则：<strong>判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。</strong></p><p>例子：在5阶B树中，结点最多有4个key,最少有2个key（注意：下面的节点统一用一个节点表示key和value）。</p><ul><li>插入18，70，50,40</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nvjrd8j309h02nmx2.jpg" alt="img"></p><ul><li>插入22</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nns376j309t02t3yg.jpg" alt="img"></p><p>插入22时，发现这个节点的关键字已经大于4了，所以需要进行分裂，分裂的规则在上面已经讲了，分裂之后，如下。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5np2pe3j30cj05z3yp.jpg" alt="img"></p><ul><li>接着插入23，25，39</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5no3tjxj30g605e74l.jpg" alt="img"></p><p>分裂，得到下面的。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nw2r4lj30fv07m3yz.jpg" alt="img"></p><p>更过的插入的过程就不多介绍了，相信有这个例子你已经知道怎么进行插入操作了。</p><h4 id="1-3-B树的删除操作"><a href="#1-3-B树的删除操作" class="headerlink" title="1.3 B树的删除操作"></a>1.3 B树的删除操作</h4><p>B树的删除操作相对于插入操作是相对复杂一些的，但是，你知道记住几种情况，一样可以很轻松的掌握的。</p><ul><li>现在有一个初始状态是下面这样的B树，然后进行删除操作。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nom0wuj30kc09edgq.jpg" alt="img"></p><ul><li>删除15，这种情况是删除叶子节点的元素，如果删除之后，节点数还是大于<code>m/2</code>，这种情况只要直接删除即可。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nryptqj30kc09z3zh.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nxf6cyj30kc097wfd.jpg" alt="img"></p><ul><li>接着，我们把22删除，这种情况的规则：22是非叶子节点，<strong>对于非叶子节点的删除，我们需要用后继key（元素）覆盖要删除的key，然后在后继key所在的子支中删除该后继key</strong>。对于删除22，需要将后继元素24移到被删除的22所在的节点。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nr1lbnj30kc0bd75g.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nqhhx1j30kc092aay.jpg" alt="img"></p><p>此时发现26所在的节点只有一个元素，小于2个（m/2），这个节点不符合要求，这时候的规则（向兄弟节点借元素）：<strong>如果删除叶子节点，如果删除元素后元素个数少于（m/2），并且它的兄弟节点的元素大于（m/2），也就是说兄弟节点的元素比最少值m/2还多，将先将父节点的元素移到该节点，然后将兄弟节点的元素再移动到父节点</strong>。这样就满足要求了。</p><p>我们看看操作过程就更加明白了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nye3a8j30kc092t9p.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nxx4fqj30kc094dgp.jpg" alt="img"></p><ul><li>接着删除28，<strong>删除叶子节点</strong>，删除后不满足要求，所以，我们需要考虑向兄弟节点借元素，但是，兄弟节点也没有多的节点（2个），借不了，怎么办呢？如果遇到这种情况，<strong>首先，还是将先将父节点的元素移到该节点，然后，将当前节点及它的兄弟节点中的key合并，形成一个新的节点</strong>。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nsgk81j30kc0ardgw.jpg" alt="img"></p><p>移动之后，跟兄弟节点合并。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nrgyhcj30kc09q755.jpg" alt="img"></p><p>删除就只有上面的几种情况，根据不同的情况进行删除即可。</p><p>上面的这些介绍，相信对于B树已经有一定的了解了，接下来的一部分，我们接着讲解B+树，我相信加上B+树的对比，就更加清晰明了了。</p><h3 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2 B+树"></a>2 B+树</h3><h4 id="2-1-B-树概述"><a href="#2-1-B-树概述" class="headerlink" title="2.1 B+树概述"></a>2.1 B+树概述</h4><p>B+树其实和B树是非常相似的，我们首先看看<strong>相同点</strong>。</p><ul><li>根节点至少一个元素</li><li>非根节点元素范围：m/2 &lt;= k &lt;= m-1</li></ul><p><strong>不同点</strong>。</p><ul><li>B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。</li><li>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。</li><li>每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。</li><li>父节点存有右孩子的第一个元素的索引。</li></ul><p>下面我们看一个B+树的例子，感受感受它吧！</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5npm6inj30hg09yq3t.jpg" alt="img"></p><h4 id="2-2-插入操作"><a href="#2-2-插入操作" class="headerlink" title="2.2 插入操作"></a>2.2 插入操作</h4><p>对于插入操作很简单，只需要记住一个技巧即可：<strong>当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的</strong>。</p><p>下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。</p><ul><li>插入5，10，15，20</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nstlpxj309s04agll.jpg" alt="img"></p><ul><li>插入25，此时元素数量大于4个了，分裂</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nt8a3jj30f206qaad.jpg" alt="img"></p><ul><li>接着插入26，30，继续分裂</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5ntrvmsj30gq0653yu.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nx3g3uj30j306xjrw.jpg" alt="img"></p><p>有了这几个例子，相信插入操作没什么问题了，下面接着看看删除操作。</p><h4 id="2-3-删除操作"><a href="#2-3-删除操作" class="headerlink" title="2.3 删除操作"></a>2.3 删除操作</h4><p>对于删除操作是比B树简单一些的，因为<strong>叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key</strong>，下面我们看看具体的实例。</p><ul><li>初始状态</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nu7d10j30kc06rt9d.jpg" alt="img"></p><ul><li>删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5numd0aj30kc06s74x.jpg" alt="img"></p><ul><li>删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nq2d13j30kc07w3z7.jpg" alt="img"></p><ul><li>发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nv4474j30kc080t9g.jpg" alt="img"></p><p>这样，B+树的删除操作也就完成了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-2-B树插入&quot;&gt;&lt;a href=&quot;#1-2-B树插入&quot; class=&quot;headerlink&quot; title=&quot;1.2 B树插入&quot;&gt;&lt;/a&gt;1.2 B树插入&lt;/h4&gt;&lt;p&gt;插入的时候，我们需要记住一个规则：&lt;strong&gt;判断当前结点key的个数是否小于等于m-1
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>Kafka数据可靠性和一致性</title>
    <link href="http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/Kafka%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://yoursite.com/2021/11/29/Java%E9%9D%A2%E8%AF%95/Kafka%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2021-11-29T02:38:39.000Z</published>
    <updated>2021-11-29T02:43:08.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kafka数据可靠性和一致性"><a href="#Kafka数据可靠性和一致性" class="headerlink" title="Kafka数据可靠性和一致性"></a>Kafka数据可靠性和一致性</h1><h2 id="数据可靠性"><a href="#数据可靠性" class="headerlink" title="数据可靠性"></a>数据可靠性</h2><p>Kafka 作为一个商业级消息中间件，消息可靠性的重要性可想而知。本文从 Producter 往 Broker 发送消息、Topic 分区副本以及 Leader 选举几个角度介绍数据的可靠性。</p><h3 id="Topic-分区副本"><a href="#Topic-分区副本" class="headerlink" title="Topic 分区副本"></a>Topic 分区副本</h3><p>在 Kafka 0.8.0 之前，Kafka 是没有副本的概念的，那时候人们只会用 Kafka 存储一些不重要的数据，因为没有副本，数据很可能会丢失。但是随着业务的发展，支持副本的功能越来越强烈，所以为了保证数据的可靠性，Kafka 从 0.8.0 版本开始引入了分区副本。也就是说每个分区可以人为的配置几个副本（比如创建主题的时候指定 <code>replication-factor</code>，也可以在 Broker 级别进行配置 <code>default.replication.factor</code>），一般会设置为3。</p><p>Kafka 可以保证单个分区里的事件是有序的，分区可以在线（可用），也可以离线（不可用）。在众多的分区副本里面有一个副本是 Leader，其余的副本是 follower，所有的读写操作都是经过 Leader 进行的，同时 follower 会定期地去 leader 上的复制数据。当 Leader 挂了的时候，其中一个 follower 会重新成为新的 Leader。通过分区副本，引入了数据冗余，同时也提供了 Kafka 的数据可靠性。</p><p><strong>Kafka 的分区多副本架构是 Kafka 可靠性保证的核心，把消息写入多个副本可以使 Kafka 在发生崩溃时仍能保证消息的持久性。</strong></p><h3 id="Producer-往-Broker-发送消息"><a href="#Producer-往-Broker-发送消息" class="headerlink" title="Producer 往 Broker 发送消息"></a>Producer 往 Broker 发送消息</h3><p>如果我们要往 Kafka 对应的主题发送消息，我们需要通过 Producer 完成。前面我们讲过 Kafka 主题对应了多个分区，每个分区下面又对应了多个副本；为了让用户设置数据可靠性， Kafka 在 Producer 里面提供了消息确认机制。也就是说我们可以通过配置来决定消息发送到对应分区的几个副本才算消息发送成功。可以在定义 Producer 时通过 <code>acks</code> 参数指定。这个参数支持以下三种值：</p><ul><li>acks = 0：意味着如果生产者能够通过网络把消息发送出去，那么就认为消息已成功写入 Kafka 。在这种情况下还是有可能发生错误，比如发送的对象无能被序列化或者网卡发生故障，但如果是分区离线或整个集群长时间不可用，那就不会收到任何错误。在 acks=0 模式下的运行速度是非常快的（这就是为什么很多基准测试都是基于这个模式），你可以得到惊人的吞吐量和带宽利用率，不过如果选择了这种模式， 一定会丢失一些消息。</li><li>acks = 1：意味若 Leader 在收到消息并把它写入到分区数据文件（不一定同步到磁盘上）时会返回确认或错误响应。在这个模式下，如果发生正常的 Leader 选举，生产者会在选举时收到一个 LeaderNotAvailableException 异常，如果生产者能恰当地处理这个错误，它会重试发送悄息，最终消息会安全到达新的 Leader 那里。不过在这个模式下仍然有可能丢失数据，比如消息已经成功写入 Leader，但在消息被复制到 follower 副本之前 Leader发生崩溃。</li><li>acks = all（这个和 request.required.acks = -1 含义一样）：意味着 Leader 在返回确认或错误响应之前，会等待所有同步副本都收到悄息。如果和 <code>min.insync.replicas</code> 参数结合起来，就可以决定在返回确认前至少有多少个副本能够收到悄息，生产者会一直重试直到消息被成功提交。不过这也是最慢的做法，因为生产者在继续发送其他消息之前需要等待所有副本都收到当前的消息。</li></ul><p>根据实际的应用场景，我们设置不同的 <code>acks</code>，以此保证数据的可靠性。</p><p>另外，Producer 发送消息还可以选择同步（默认，通过 <code>producer.type=sync</code> 配置） 或者异步（<code>producer.type=async</code>）模式。如果设置成异步，虽然会极大的提高消息发送的性能，但是这样会增加丢失数据的风险。如果需要确保消息的可靠性，必须将 <code>producer.type</code> 设置为 sync。</p><h3 id="Leader-选举"><a href="#Leader-选举" class="headerlink" title="Leader 选举"></a>Leader 选举</h3><p>在介绍 Leader 选举之前，让我们先来了解一下 ISR（in-sync replicas）列表。每个分区的 leader 会维护一个 ISR 列表，ISR 列表里面就是 follower 副本的 Borker 编号，只有跟得上 Leader 的 follower 副本才能加入到 ISR 里面，这个是通过 <code>replica.lag.time.max.ms</code> 参数配置的。只有 ISR 里的成员才有被选为 leader 的可能。</p><p>所以当 Leader 挂掉了，而且 <code>unclean.leader.election.enable=false</code> 的情况下，Kafka 会从 ISR 列表中选择第一个 follower 作为新的 Leader，因为这个分区拥有最新的已经 committed 的消息。通过这个可以保证已经 committed 的消息的数据可靠性。</p><p>综上所述，为了保证数据的可靠性，我们最少需要配置一下几个参数：</p><ul><li>producer 级别：acks=all（或者 request.required.acks=-1），同时发生模式为同步 producer.type=sync</li><li>topic 级别：设置 replication.factor&gt;=3，并且 min.insync.replicas&gt;=2；</li><li>broker 级别：关闭不完全的 Leader 选举，即 unclean.leader.election.enable=false；</li></ul><h4 id="分区-Leader-选举策略有几种"><a href="#分区-Leader-选举策略有几种" class="headerlink" title="分区 Leader 选举策略有几种?"></a>分区 Leader 选举策略有几种?</h4><p>分区的 Leader 副本选举对用户是完全透明的，它是由 Controller 独立完成的。你需要回答的是，在哪些场景下，需要执行分区 Leader 选举。每一种场景对应于一种选举策略。当前，Kafka 有 4 种分区 Leader 选举策略。</p><ul><li><strong>OfflinePartition Leader 选举</strong>:每当有分区上线时，就需要执行 Leader 选举。所谓的分区上线，可能是创建了新分区，也可能是之前的下线分区重新上线。这是最常见的分区 Leader 选举场景。</li><li><strong>ReassignPartition Leader 选举</strong>:当你手动运行 kafka-reassign-partitions 命令，或者是调用 Admin 的 alterPartitionReassignments 方法执行分区副本重分配时，可能触发此类选举。假设原来的 AR 是[1，2，3]，Leader 是 1，当执行副本重分配后，副本集 合 AR 被设置成[4，5，6]，显然，Leader 必须要变更，此时会发生 Reassign Partition Leader 选举。</li><li><strong>PreferredReplicaPartition Leader 选举</strong>:当你手动运行 kafka-preferred-replica- election 命令，或自动触发了 Preferred Leader 选举时，该类策略被激活。所谓的 Preferred Leader，指的是 AR 中的第一个副本。比如 AR 是[3，2，1]，那么， Preferred Leader 就是 3。</li><li><strong>ControlledShutdownPartition Leader 选举</strong>:当 Broker 正常关闭时，该 Broker 上 的所有 Leader 副本都会下线，因此，需要为受影响的分区执行相应的 Leader 选举。</li></ul><p>这 4 类选举策略的大致思想是类似的，即从 AR 中挑选首个在 ISR 中的副本，作为新 Leader。当然，个别策略有些微小差异。不过，回答到这种程度，应该足以应付面试官 了。毕竟，微小差别对选举 Leader 这件事的影响很小。</p><h1 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h1><p>这里介绍的数据一致性主要是说不论是老的 Leader 还是新选举的 Leader，Consumer 都能读到一样的数据。那么 Kafka 是如何实现的呢？</p><p><a href="https://www.iteblog.com/pic/kafka/kafka_high_water_make-iteblog.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwuuojhzp6j313g0b6dhm.jpg" alt="Kafka 是如何保证数据可靠性和一致性"></a></p><p>假设分区的副本为3，其中副本0是 Leader，副本1和副本2是 follower，并且在 ISR 列表里面。虽然副本0已经写入了 Message4，但是 Consumer 只能读取到 Message2。因为所有的 ISR 都同步了 Message2，只有 High Water Mark 以上的消息才支持 Consumer 读取，而 High Water Mark 取决于 ISR 列表里面偏移量最小的分区，对应于上图的副本2，这个很类似于木桶原理。</p><p>这样做的原因是还没有被足够多副本复制的消息被认为是“不安全”的，如果 Leader 发生崩溃，另一个副本成为新 Leader，那么这些消息很可能丢失了。如果我们允许消费者读取这些消息，可能就会破坏一致性。试想，一个消费者从当前 Leader（副本0） 读取并处理了 Message4，这个时候 Leader 挂掉了，选举了副本1为新的 Leader，这时候另一个消费者再去从新的 Leader 读取消息，发现这个消息其实并不存在，这就导致了数据不一致性问题。</p><p>当然，引入了 High Water Mark 机制，会导致 Broker 间的消息复制因为某些原因变慢，那么消息到达消费者的时间也会随之变长（因为我们会先等待消息复制完毕）。延迟时间可以通过参数 <code>replica.lag.time.max.ms</code> 参数配置，它指定了副本在复制消息时可被允许的最大延迟时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Kafka数据可靠性和一致性&quot;&gt;&lt;a href=&quot;#Kafka数据可靠性和一致性&quot; class=&quot;headerlink&quot; title=&quot;Kafka数据可靠性和一致性&quot;&gt;&lt;/a&gt;Kafka数据可靠性和一致性&lt;/h1&gt;&lt;h2 id=&quot;数据可靠性&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="Kafka" scheme="http://yoursite.com/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>开窗函数</title>
    <link href="http://yoursite.com/2021/11/29/%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91/%E5%BC%80%E7%AA%97%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2021/11/29/%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91/%E5%BC%80%E7%AA%97%E5%87%BD%E6%95%B0/</id>
    <published>2021-11-29T02:30:39.000Z</published>
    <updated>2021-11-29T02:38:35.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开窗函数"><a href="#开窗函数" class="headerlink" title="开窗函数"></a>开窗函数</h1><h3 id="row-number-over"><a href="#row-number-over" class="headerlink" title="row_number() over"></a>row_number() over</h3><p>语法格式：row_number() over(partition by 分组列 order by 排序列 desc)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,age,salary,row_number()<span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> salary <span class="hljs-keyword">desc</span>) rn <br><span class="hljs-keyword">FROM</span> TEST_ROW_NUMBER_OVER t;<br></code></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/Rmf5Y6" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/06/23/Rmf5Y6.png" alt="Rmf5Y6.png"></a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,age,salary,<br>row_number()<span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> salary <span class="hljs-keyword">desc</span>) rn <br><span class="hljs-keyword">FROM</span> TEST_ROW_NUMBER_OVER t;<br></code></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/RmfWwR" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/06/23/RmfWwR.png" alt="RmfWwR.png"></a></p><p>row_number() over()分组排序功能：</p><p>在使用 row_number() over()函数时候，over()里头的分组以及排序的执行晚于 where 、group by、 order by 的执行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  * <br><span class="hljs-keyword">FROM</span><br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,age,salary,row_number() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> salary <span class="hljs-keyword">desc</span>) rn <br><span class="hljs-keyword">FROM</span> TEST_ROW_NUMBER_OVER) t1<br><span class="hljs-keyword">WHERE</span> t1.rn&lt;<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/RmfRm9" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/06/23/RmfRm9.png" alt="RmfRm9.png"></a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,age,salary,row_number()<span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> salary <span class="hljs-keyword">desc</span>)  rn <br><span class="hljs-keyword">FROM</span> TEST_ROW_NUMBER_OVER t <br><span class="hljs-keyword">WHERE</span> t.age <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">'13'</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">'16'</span>;<br></code></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/RmfTSO" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/06/23/RmfTSO.png" alt="RmfTSO.png"></a></p><p>with的用法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">with</span> tabs <span class="hljs-keyword">as</span><br>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>, age, salary, row_number()<span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> salary <span class="hljs-keyword">desc</span>) rn<br> <span class="hljs-keyword">from</span> TEST_ROW_NUMBER_OVER t)<br><span class="hljs-keyword">select</span> *<br><span class="hljs-keyword">from</span> tabs <span class="hljs-keyword">where</span> rn=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="rank-over"><a href="#rank-over" class="headerlink" title="rank() over"></a>rank() over</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,age,salary,<span class="hljs-keyword">rank</span>()<span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> salary <span class="hljs-keyword">desc</span>) rn <br><span class="hljs-keyword">FROM</span> TEST_ROW_NUMBER_OVER t;<br></code></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/RmffT1" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/06/23/RmffT1.png" alt="RmffT1.png"></a></p><h3 id="DENSE-RANK"><a href="#DENSE-RANK" class="headerlink" title="DENSE_RANK()"></a>DENSE_RANK()</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,age,salary, <span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> salary <span class="hljs-keyword">desc</span>) rn <br><span class="hljs-keyword">FROM</span> TEST_ROW_NUMBER_OVER t;<br></code></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/Rmf4Fx" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/06/23/Rmf4Fx.png" alt="Rmf4Fx.png"></a></p><h3 id="几个排序函数row-number-over-、rank-over-、dense-rank-over-、ntile-over-的区别"><a href="#几个排序函数row-number-over-、rank-over-、dense-rank-over-、ntile-over-的区别" class="headerlink" title="几个排序函数row_number() over()、rank() over()、dense_rank() over()、ntile() over()的区别"></a>几个排序函数row_number() over()、rank() over()、dense_rank() over()、ntile() over()的区别</h3><p>（1） row_number() over()：对相等的值不进行区分，相等的值对应的排名相同，序号从1到n连续。</p><p>（2） rank() over()：相等的值排名相同，但若有相等的值，则序号从1到n不连续。如果有两个人都排在第3名，则没有第4名。</p><p>（3） dense_rank() over()：对相等的值排名相同，但序号从1到n连续。如果有两个人都排在第一名，则排在第2名（假设仅有1个第二名）的人是第3个人。</p><p>（4） ntile( n ) over()：可以看作是把有序的数据集合平均分配到指定的数量n的桶中,将桶号分配给每一行，排序对应的数字为桶号。如果不能平均分配，则较小桶号的桶分配额外的行，并且各个桶中能放的数据条数最多相差1。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开窗函数&quot;&gt;&lt;a href=&quot;#开窗函数&quot; class=&quot;headerlink&quot; title=&quot;开窗函数&quot;&gt;&lt;/a&gt;开窗函数&lt;/h1&gt;&lt;h3 id=&quot;row-number-over&quot;&gt;&lt;a href=&quot;#row-number-over&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>8.2.哈希冲突与解决(拉链法,线性探测法)</title>
    <link href="http://yoursite.com/2021/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.2.%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E4%B8%8E%E8%A7%A3%E5%86%B3(%E6%8B%89%E9%93%BE%E6%B3%95,%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95)/"/>
    <id>http://yoursite.com/2021/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.2.%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E4%B8%8E%E8%A7%A3%E5%86%B3(%E6%8B%89%E9%93%BE%E6%B3%95,%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95)/</id>
    <published>2021-11-22T14:38:39.000Z</published>
    <updated>2021-11-22T14:38:34.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希冲突与解决-拉链法-线性探测法"><a href="#哈希冲突与解决-拉链法-线性探测法" class="headerlink" title="哈希冲突与解决(拉链法,线性探测法)"></a>哈希冲突与解决(拉链法,线性探测法)</h1><p>参考：<a href="https://blog.csdn.net/u012124438/article/details/78230478" target="_blank" rel="noopener">https://blog.csdn.net/u012124438/article/details/78230478</a></p><h2 id="1-线性探测-vs-拉链法"><a href="#1-线性探测-vs-拉链法" class="headerlink" title="1. 线性探测 vs 拉链法"></a>1. 线性探测 vs 拉链法</h2><p>开放寻址法和链表法。这两种冲突解决办法在实际的软件开发中都非常常用。比如，LinkedHashMap 就采用了链表法解决冲突，ThreadLocalMap 是通过线性探测的开放寻址法来解决冲突。那你知道，这两种冲突解决方法各有什么优势和劣势，又各自适用哪些场景吗？</p><p><strong>（1）开放寻址法优缺点</strong></p><ul><li>开放寻址法优点：<ul><li>散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。</li><li>数组实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没那么容易。你可不要小看序列化，很多场合都会用到的。</li></ul></li><li>开放寻址法缺点：<ul><li>用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。</li><li>在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。</li><li>装载因子的上限不能太大，导致这种方法比链表法更浪费内存空间。</li></ul></li></ul><p><strong>总结：</strong> <strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法。</strong>这也是 ThreadLocalMap 使用开放寻址法解决散列冲突的原因。</p><p><strong>（2）拉链法优缺点</strong></p><ul><li>拉链法优点：<ul><li>首先，链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。</li><li>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</li><li>可以将链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。</li></ul></li><li>拉链法缺点：<ul><li>链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。但如果我们存储的是大对象，此时存储对象远远大于指针大小（4 byte 或 8 byte），那链表中指针的内存消耗在大对象面前就可以忽略了。</li><li>因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。</li></ul></li></ul><p><strong>总结：</strong> <strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表。</strong>而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈希冲突与解决-拉链法-线性探测法&quot;&gt;&lt;a href=&quot;#哈希冲突与解决-拉链法-线性探测法&quot; class=&quot;headerlink&quot; title=&quot;哈希冲突与解决(拉链法,线性探测法)&quot;&gt;&lt;/a&gt;哈希冲突与解决(拉链法,线性探测法)&lt;/h1&gt;&lt;p&gt;参考：&lt;a hr
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>8.1.哈希表(散列表)</title>
    <link href="http://yoursite.com/2021/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.1.%E5%93%88%E5%B8%8C%E8%A1%A8(%E6%95%A3%E5%88%97%E8%A1%A8)/"/>
    <id>http://yoursite.com/2021/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.1.%E5%93%88%E5%B8%8C%E8%A1%A8(%E6%95%A3%E5%88%97%E8%A1%A8)/</id>
    <published>2021-11-22T14:37:39.000Z</published>
    <updated>2021-11-22T14:38:20.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="散列表-哈希表"><a href="#散列表-哈希表" class="headerlink" title="散列表(哈希表)"></a><strong>散列表(哈希表)</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>散列表也叫哈希表，是一种通过键值对直接访问数据的机构。<strong>借助散列函数对数组进行扩展，利用的是数组支持按照下标随机访问元素的特性。</strong>散列表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。散列函数有 MD5、SHA、CRC 等哈希算法。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmuu8vpaxj31200eodh1.jpg" alt="image-20211121163245049"></p><p>散列表的实现最关键的就是散列函数的定义和选择。</p><h2 id="2-散列函数"><a href="#2-散列函数" class="headerlink" title="2. 散列函数"></a>2. 散列函数</h2><p>什么才是好的散列函数：</p><ul><li><strong>散列函数的设计不能太复杂</strong>。过于复杂的散列函数，势必会占用更多 CPU，也就间接的影响到散列表的性能。</li><li><strong>散列函数生成的值要尽可能随机并且均匀分布</strong>。这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</li></ul><p><strong>一般常用的有以下几种散列函数：</strong></p><h3 id="2-1-直接定址法"><a href="#2-1-直接定址法" class="headerlink" title="2.1 直接定址法"></a>2.1 直接定址法</h3><blockquote><p>取关键字或关键字的某个线性函数值为散列地址。</p><p>关键码本身和地址之间存在某个线性函数关系时，散列函数取为关键码的线性函数，即：<code>hash(key) = a * key + b</code>（a、b 均为常数）。</p><p>这样的散列函数优点就是简单、均匀，也不会产生冲突，但问题是这需要事先知道关键字的分布情况，适合査找表较小且连续的情况。由于这样的限制，<strong>在现实应用中虽然简单，但却并不常用</strong>。</p></blockquote><h3 id="2-2-余数法"><a href="#2-2-余数法" class="headerlink" title="2.2 余数法"></a>2.2 <strong>余数法</strong></h3><blockquote><p>通过选择适当的正整数 p，按计算公式 <code>hash(K) = K % p</code> 来计算关键码 K 的散列地址。这种方法计算最简单，也不需根据全部关键码的分布情况研究如何从中析取数据，<strong>最常用</strong>。这种方式也可以在用过其他方法后再使用。该函数对 p 的选择很重要，一般取素数或者直接用 n。</p></blockquote><h3 id="2-3-平方取中法"><a href="#2-3-平方取中法" class="headerlink" title="2.3 平方取中法"></a>2.3 平方取中法</h3><blockquote><p>当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</p><p>将关键码 K 平方，取 K^2 中间几位作为其散列地址 hash(K) 的值。</p><p>假如有以下关键字序列 {421，423，436}，平方之后的结果为 {177241，178929，190096}，那么可以取 {72，89，00} 作为 Hash 地址。</p></blockquote><h3 id="2-4-随机数法"><a href="#2-4-随机数法" class="headerlink" title="2.4 随机数法"></a>2.4 随机数法</h3><blockquote><p>采用随机函数作为散列函数 <code>hash(Key) = random(Key)</code>，其中 random 为随机函数。<strong>当关键码长度不等时，采用该方法较恰当。</strong></p></blockquote><h3 id="2-5-数字分析法："><a href="#2-5-数字分析法：" class="headerlink" title="2.5 数字分析法："></a><strong>2.5 数字分析法</strong>：</h3><blockquote><p>通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。 </p></blockquote><h2 id="3-散列冲突"><a href="#3-散列冲突" class="headerlink" title="3. 散列冲突"></a><strong>3. 散列冲突</strong></h2><p>确定好散列函数之后，通过某个<code>key</code>值的确会得到一个唯一的<code>value</code>地址。但是却会出现一些特殊情况。<strong>即通过不同的<code>key</code>值可能会访问到同一个地址，这个现象称之为冲突。</strong></p><p>冲突在发生之后，当在对不同的<code>key</code>值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。</p><p>常用的冲突处理方式有很多，常用的包括以下几种：</p><h3 id="3-1-开放地址法（也叫开放寻址法）："><a href="#3-1-开放地址法（也叫开放寻址法）：" class="headerlink" title="3.1 开放地址法（也叫开放寻址法）："></a><strong>3.1 开放地址法</strong>（也叫开放寻址法）：</h3><p>如果出现了散列冲突，就重新探测一个空闲位置。根据重新探测的方式，又可以分为线性探测、二次探测、双重哈希三种。</p><ul><li><strong>线性探测(Linear Probing)</strong>：从发生冲突位置依次往后查找空闲位置。线性探测会导致数据集中到某一块区域。</li><li><strong>二次探测(Quadratic probing)</strong>：如果说线性探测每次探测的步长是 1，即线性探测的下标序列就是 hash(key) + 0，hash(key) + 1，hash(key) + 2……。而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key) + 02，hash(key) + 12，hash(key) + 22……。</li><li><strong>双重哈希(Double hashing)</strong>：前面的两种探测方式都只使用一个散列函数，而双重哈希则会使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。这种方式的缺点是时间增加了。 </li></ul><h3 id="3-2-链地址法："><a href="#3-2-链地址法：" class="headerlink" title="3.2 链地址法："></a><strong>3.2 链地址法</strong>：</h3><p>链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。使用链表将所有散列值相同的元素我们都放到相同槽位对应的链表中。当然，这个链表可能为简单链表，也可能是红黑树，如 HahMap。</p><p>==<strong>目前比较常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的</strong>==。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmuussdnij314k0l640l.jpg" alt="image-20211121163316703"></p><p>左侧数组的每个成员包括一个指针，指向一个链表的头。每发生一个冲突的数据，就将该数据作为链表的节点链接到链表尾部。这样一来，就可以保证冲突的数据能够区分并顺利访问。</p><p>考虑到链表过长造成的问题，还可以<strong>使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性</strong>。</p><h3 id="3-3-公共溢出区："><a href="#3-3-公共溢出区：" class="headerlink" title="3.3 公共溢出区："></a><strong>3.3 公共溢出区</strong>：</h3><p>这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。很少用。</p><p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子来表示空位的多少。<strong>装载因子（load factor）</strong>的计算公式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">散列表的装载因子 &#x3D; 表中的元素个数 &#x2F; 散列表的长度<br></code></pre></td></tr></table></figure><p>实例参考： <a href="https://www.jianshu.com/p/a89e9487a06c" target="_blank" rel="noopener">https://www.jianshu.com/p/a89e9487a06c</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;散列表-哈希表&quot;&gt;&lt;a href=&quot;#散列表-哈希表&quot; class=&quot;headerlink&quot; title=&quot;散列表(哈希表)&quot;&gt;&lt;/a&gt;&lt;strong&gt;散列表(哈希表)&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; clas
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>7.6.图的最短路径(Djkstra, Floyd)</title>
    <link href="http://yoursite.com/2021/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.6.%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(Djkstra,%20Floyd)/"/>
    <id>http://yoursite.com/2021/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.6.%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(Djkstra,%20Floyd)/</id>
    <published>2021-11-22T14:36:39.000Z</published>
    <updated>2021-11-22T14:38:06.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径-Djkstra-Floyd"><a href="#最短路径-Djkstra-Floyd" class="headerlink" title="最短路径(Djkstra, Floyd)"></a>最短路径(Djkstra, Floyd)</h1><h2 id="迪杰斯特拉算法介绍"><a href="#迪杰斯特拉算法介绍" class="headerlink" title="迪杰斯特拉算法介绍"></a><strong>迪杰斯特拉算法介绍</strong></h2><p>Dijkstra算法功能：给出<strong>加权连通图</strong>中一个顶点，称之为起点，找出起点到其它所有顶点之间的最短距离。</p><p>它的主要特点是以起始点为中心向外层层扩展(BFS广度优先搜索思想)，直到扩展到终点为止。</p><p><strong>基本思想</strong></p><p>   通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。</p><p>   此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。</p><p>   初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。</p><p><strong>操作步骤</strong></p><p><strong>(1)</strong> 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。</p><p><strong>(2)</strong> 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。</p><p><strong>(3)</strong> 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。</p><p><strong>(4)</strong> 重复步骤(2)和(3)，直到遍历完所有顶点。</p><p>单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。</p><h2 id="迪杰斯特拉算法图解"><a href="#迪杰斯特拉算法图解" class="headerlink" title="迪杰斯特拉算法图解"></a><strong>迪杰斯特拉算法图解</strong></h2><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/dijkstra/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwo7enm7kmj30aj07et8v.jpg" alt="img"></a></p><p>以上图G4为例，来对迪杰斯特拉进行算法演示(以第4个顶点D为起点)。(B的权重有错误)</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/dijkstra/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwo7eo046pj30jz184jw8.jpg" alt="img"></a></p><p><strong>初始状态</strong>：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！<br><strong>第1步</strong>：将顶点D加入到S中。<br>  此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。   注:C(3)表示C到起点D的距离是3。</p><p><strong>第2步</strong>：将顶点C加入到S中。<br>  上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。<br>  此时，S={D(0),C(3)}, U={A(∞),B(23),E(4),F(9),G(∞)}。</p><p><strong>第3步</strong>：将顶点E加入到S中。<br>  上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。<br>  此时，S={D(0),C(3),E(4)}, U={A(∞),B(23),F(6),G(12)}。</p><p><strong>第4步</strong>：将顶点F加入到S中。<br>  此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。</p><p><strong>第5步</strong>：将顶点G加入到S中。<br>  此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。</p><p><strong>第6步</strong>：将顶点B加入到S中。<br>  此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。</p><p><strong>第7步</strong>：将顶点A加入到S中。<br>  此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。</p><p>此时，起点D到各个顶点的最短距离就计算出来了：<strong>A(22) B(13) C(3) D(0) E(4) F(6) G(12)</strong>。</p><h2 id="迪杰斯特拉算法的代码说明"><a href="#迪杰斯特拉算法的代码说明" class="headerlink" title="迪杰斯特拉算法的代码说明"></a><strong>迪杰斯特拉算法的代码说明</strong></h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mEdgNum;        <span class="hljs-comment">// 边的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = Integer.MAX_VALUE;   <span class="hljs-comment">// 最大值</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-迪杰斯特拉算法"><a href="#2-迪杰斯特拉算法" class="headerlink" title="2. 迪杰斯特拉算法"></a><strong>2. 迪杰斯特拉算法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * Dijkstra最短路径。<br> * 即，统计图中"顶点vs"到其它各个顶点的最短路径。<br> *<br> * 参数说明：<br> *       vs -- 起始顶点(start vertex)。即计算"顶点vs"到其它顶点的最短路径。<br> *     prev -- 前驱顶点数组。即，prev[i]的值是"顶点vs"到"顶点i"的最短路径所经历的全部顶点中，位于"顶点i"之前的那个顶点。<br> *     dist -- 长度数组。即，dist[i]是"顶点vs"到"顶点i"的最短路径的长度。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vs, <span class="hljs-keyword">int</span>[] prev, <span class="hljs-keyword">int</span>[] dist)</span> </span>&#123;<br>    <span class="hljs-comment">// flag[i]=true表示"顶点vs"到"顶点i"的最短路径已成功获取</span><br>    <span class="hljs-keyword">boolean</span>[] flag = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[mVexs.length];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        flag[i] = <span class="hljs-keyword">false</span>;          <span class="hljs-comment">// 顶点i的最短路径还没获取到。</span><br>        prev[i] = <span class="hljs-number">0</span>;              <span class="hljs-comment">// 顶点i的前驱顶点为0。</span><br>        dist[i] = mMatrix[vs][i];  <span class="hljs-comment">// 顶点i的最短路径为"顶点vs"到"顶点i"的权。</span><br>    &#125;<br><br>    <span class="hljs-comment">// 对"顶点vs"自身进行初始化</span><br>    flag[vs] = <span class="hljs-keyword">true</span>;<br>    dist[vs] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 遍历mVexs.length-1次；每次找出一个顶点的最短路径。</span><br>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; mVexs.length; i++) &#123;<br>        <span class="hljs-comment">// 寻找当前最小的路径；</span><br>        <span class="hljs-comment">// 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。</span><br>        <span class="hljs-keyword">int</span> min = INF;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (flag[j]==<span class="hljs-keyword">false</span> &amp;&amp; dist[j]&lt;min) &#123;<br>                min = dist[j];<br>                k = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 标记"顶点k"为已经获取到最短路径</span><br>        flag[k] = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// 修正当前最短路径和前驱顶点</span><br>        <span class="hljs-comment">// 即，当已经"顶点k的最短路径"之后，更新"未获取最短路径的顶点的最短路径和前驱顶点"。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++) &#123;<br>            <span class="hljs-keyword">int</span> tmp = (mMatrix[k][j]==INF ? INF : (min + mMatrix[k][j]));<br>            <span class="hljs-keyword">if</span> (flag[j]==<span class="hljs-keyword">false</span> &amp;&amp; (tmp&lt;dist[j]) ) &#123;<br>                dist[j] = tmp;<br>                prev[j] = k;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印dijkstra最短路径的结果</span><br>    System.out.printf(<span class="hljs-string">"dijkstra(%c): \n"</span>, mVexs[vs]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; mVexs.length; i++)<br>        System.out.printf(<span class="hljs-string">"  shortest(%c, %c)=%d\n"</span>, mVexs[vs], mVexs[i], dist[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="弗洛伊德算法介绍"><a href="#弗洛伊德算法介绍" class="headerlink" title="弗洛伊德算法介绍"></a><strong>弗洛伊德算法介绍</strong></h2><p><strong>基本思想</strong></p><p>   通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入一个矩阵S，矩阵S中的元素a[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。</p><p>   假设图G中顶点个数为N，则需要对矩阵S进行N次更新。初始时，矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。 接下来开始，对矩阵S进行N次更新。第1次更新时，如果”a[i][j]的距离” &gt; “a[i][0]+a[0][j]”(a[i][0]+a[0][j]表示”i与j之间经过第1个顶点的距离”)，则更新a[i][j]为”a[i][0]+a[0][j]”。 同理，第k次更新时，如果”a[i][j]的距离” &gt; “a[i][k]+a[k][j]”，则更新a[i][j]为”a[i][k]+a[k][j]”。更新N次之后，操作完成！</p><p>   单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。</p><p>   <strong>与Djkstra比较：</strong>最后的邻接矩阵包含以任意顶点喂起点的最短路径。</p><h2 id="弗洛伊德算法图解"><a href="#弗洛伊德算法图解" class="headerlink" title="弗洛伊德算法图解"></a><strong>弗洛伊德算法图解</strong></h2><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/floyd/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwo7sofmklj30rc08fmy6.jpg" alt="img"></a></p><p>以上图G4为例，来对弗洛伊德进行算法演示。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/floyd/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwo7sqfkq5j30rv1r17d3.jpg" alt="img"></a></p><p><strong>初始状态</strong>：S是记录各个顶点间最短路径的矩阵。<br><strong>第1步</strong>：初始化S。<br>  矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。实际上，就是将图的原始矩阵复制到S中。<br>  注:a[i][j]表示矩阵S中顶点i(第i个顶点)到顶点j(第j个顶点)的距离。</p><p><strong>第2步</strong>：以顶点A(第1个顶点)为中介点，若a[i][j] &gt; a[i][0]+a[0][j]，则设置a[i][j]=a[i][0]+a[0][j]。<br>  以顶点a[1]<a href="http://i.cnblogs.com/即顶点B和顶点G之间的距离为例" target="_blank" rel="noopener">6</a>，上一步操作之后，a[1][6]=∞；而将A作为中介点时，(B,A)=12，(A,G)=14，因此B和G之间的距离可以更新为26。</p><p>同理，依次将顶点B,C,D,E,F,G作为中介点，并更新a[i][j]的大小。</p><h2 id="弗洛伊德算法的代码说明"><a href="#弗洛伊德算法的代码说明" class="headerlink" title="弗洛伊德算法的代码说明"></a><strong>弗洛伊德算法的代码说明</strong></h2><h3 id="1-基本定义-1"><a href="#1-基本定义-1" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mEdgNum;        <span class="hljs-comment">// 边的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = Integer.MAX_VALUE;   <span class="hljs-comment">// 最大值</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-弗洛伊德算法"><a href="#2-弗洛伊德算法" class="headerlink" title="2. 弗洛伊德算法"></a><strong>2. 弗洛伊德算法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * floyd最短路径。<br> * 即，统计图中各个顶点间的最短路径。<br> *<br> * 参数说明：<br> *     path -- 路径。path[i][j]=k表示，"顶点i"到"顶点j"的最短路径会经过顶点k。<br> *     dist -- 长度数组。即，dist[i][j]=sum表示，"顶点i"到"顶点j"的最短路径的长度是sum。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] path, <span class="hljs-keyword">int</span>[][] dist)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++) &#123;<br>            dist[i][j] = mMatrix[i][j];    <span class="hljs-comment">// "顶点i"到"顶点j"的路径长度为"i到j的权值"。</span><br>            path[i][j] = j;                <span class="hljs-comment">// "顶点i"到"顶点j"的最短路径是经过顶点j。</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算最短路径</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; mVexs.length; k++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++) &#123;<br><br>                <span class="hljs-comment">// 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]和path[i][j]</span><br>                <span class="hljs-keyword">int</span> tmp = (dist[i][k]==INF || dist[k][j]==INF) ? INF : (dist[i][k] + dist[k][j]);<br>                <span class="hljs-keyword">if</span> (dist[i][j] &gt; tmp) &#123;<br>                    <span class="hljs-comment">// "i到j最短路径"对应的值设，为更小的一个(即经过k)</span><br>                    dist[i][j] = tmp;<br>                    <span class="hljs-comment">// "i到j最短路径"对应的路径，经过k</span><br>                    path[i][j] = path[i][k];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印floyd最短路径的结果</span><br>    System.out.printf(<span class="hljs-string">"floyd: \n"</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++)<br>            System.out.printf(<span class="hljs-string">"%2d  "</span>, dist[i][j]);<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路径-Djkstra-Floyd&quot;&gt;&lt;a href=&quot;#最短路径-Djkstra-Floyd&quot; class=&quot;headerlink&quot; title=&quot;最短路径(Djkstra, Floyd)&quot;&gt;&lt;/a&gt;最短路径(Djkstra, Floyd)&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>7.5.图的最小生成树(Prime, Kruskal)</title>
    <link href="http://yoursite.com/2021/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.5.%E5%9B%BE%E7%9A%84%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91(Prime,%20Kruskal)/"/>
    <id>http://yoursite.com/2021/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.5.%E5%9B%BE%E7%9A%84%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91(Prime,%20Kruskal)/</id>
    <published>2021-11-22T14:35:39.000Z</published>
    <updated>2021-11-22T14:37:51.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小生成树-Prime-Kruskal"><a href="#最小生成树-Prime-Kruskal" class="headerlink" title="最小生成树(Prime, Kruskal)"></a>最小生成树(Prime, Kruskal)</h1><h2 id="最小生成树概念"><a href="#最小生成树概念" class="headerlink" title="最小生成树概念"></a><strong>最小生成树概念</strong></h2><p>在含有n个顶点的连通图中选择n-1条边，构成一棵极小连通子图，并使该连通子图中n-1条边上权值之和达到最小，则称其为连通网的最小生成树。<br><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn1aw8x2lj30aj07et8v.jpg" alt="img"></a></p><p>例如，对于如上图G4所示的连通网可以有多棵权值总和不相同的生成树。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn1awqlhsj30vj07et9l.jpg" alt="img"></a></p><h1 id="克鲁斯卡尔-Kruskal-算法"><a href="#克鲁斯卡尔-Kruskal-算法" class="headerlink" title="克鲁斯卡尔(Kruskal)算法"></a><strong>克鲁斯卡尔(Kruskal)算法</strong></h1><p>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。</p><p><strong>基本思想</strong>：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。<br><strong>具体做法</strong>：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。</p><h2 id="克鲁斯卡尔算法图解"><a href="#克鲁斯卡尔算法图解" class="headerlink" title="克鲁斯卡尔算法图解"></a><strong>克鲁斯卡尔算法图解</strong></h2><p>以上图G4为例，来对克鲁斯卡尔进行演示(假设，用数组R保存最小生成树结果)。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/03.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn1rekeu5j30do11u0vb.jpg" alt="img"></a></p><p><strong>第1步</strong>：将边&lt;E,F&gt;加入R中。<br>  边&lt;E,F&gt;的权值最小，因此将它加入到最小生成树结果R中。<br><strong>第2步</strong>：将边&lt;C,D&gt;加入R中。<br>  上一步操作之后，边&lt;C,D&gt;的权值最小，因此将它加入到最小生成树结果R中。<br><strong>第3步</strong>：将边&lt;D,E&gt;加入R中。<br>  上一步操作之后，边&lt;D,E&gt;的权值最小，因此将它加入到最小生成树结果R中。<br><strong>第4步</strong>：将边&lt;B,F&gt;加入R中。<br>  上一步操作之后，边&lt;C,E&gt;的权值最小，但&lt;C,E&gt;会和已有的边构成回路；因此，跳过边&lt;C,E&gt;。同理，跳过边&lt;C,F&gt;。将边&lt;B,F&gt;加入到最小生成树结果R中。<br><strong>第5步</strong>：将边&lt;E,G&gt;加入R中。<br>  上一步操作之后，边&lt;E,G&gt;的权值最小，因此将它加入到最小生成树结果R中。<br><strong>第6步</strong>：将边&lt;A,B&gt;加入R中。<br>  上一步操作之后，边&lt;F,G&gt;的权值最小，但&lt;F,G&gt;会和已有的边构成回路；因此，跳过边&lt;F,G&gt;。同理，跳过边&lt;B,C&gt;。将边&lt;A,B&gt;加入到最小生成树结果R中。</p><p>此时，最小生成树构造完成！它包括的边依次是：<strong>&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;</strong>。</p><h2 id="克鲁斯卡尔算法分析"><a href="#克鲁斯卡尔算法分析" class="headerlink" title="克鲁斯卡尔算法分析"></a><strong>克鲁斯卡尔算法分析</strong></h2><p>根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题：<br><strong>问题一</strong> 对图的所有边按照权值大小进行排序。<br><strong>问题二</strong> 将边添加到最小生成树中时，怎么样判断是否形成了回路。</p><p>问题一很好解决，采用排序算法进行排序即可。</p><p>问题二处理方式是：<strong>==记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”(<em>关于这一点，后面会通过图片给出说明</em>)。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。==</strong> 以下图来进行说明：</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/04.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn1y7epmpj30aj06c74g.jpg" alt="img"></a></p><p>在将&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt;加入到最小生成树R中之后，这几条边的顶点就都有了终点：</p><blockquote><p><strong>(01)</strong> C的终点是F。<br><strong>(02)</strong> D的终点是F。<br><strong>(03)</strong> E的终点是F。<br><strong>(04)</strong> F的终点是F。</p></blockquote><p>关于终点，就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是”与它连通的最大顶点”。 因此，接下来，虽然&lt;C,E&gt;是权值最小的边。但是C和E的重点都是F，即它们的终点相同，因此，将&lt;C,E&gt;加入最小生成树的话，会形成回路。这就是判断回路的方式。</p><h2 id="克鲁斯卡尔算法的代码说明"><a href="#克鲁斯卡尔算法的代码说明" class="headerlink" title="克鲁斯卡尔算法的代码说明"></a><strong>克鲁斯卡尔算法的代码说明</strong></h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><p>EData是邻接矩阵边对应的结构体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 边的结构体</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EData</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> start; <span class="hljs-comment">// 边的起点</span><br>    <span class="hljs-keyword">char</span> end;   <span class="hljs-comment">// 边的终点</span><br>    <span class="hljs-keyword">int</span> weight; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EData</span><span class="hljs-params">(<span class="hljs-keyword">char</span> start, <span class="hljs-keyword">char</span> end, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.start = start;<br>        <span class="hljs-keyword">this</span>.end = end;<br>        <span class="hljs-keyword">this</span>.weight = weight;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mEdgNum;        <span class="hljs-comment">// 边的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = Integer.MAX_VALUE;   <span class="hljs-comment">// 最大值</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-克鲁斯卡尔算法"><a href="#2-克鲁斯卡尔算法" class="headerlink" title="2. 克鲁斯卡尔算法"></a><strong>2. 克鲁斯卡尔算法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 克鲁斯卡尔（Kruskal)最小生成树<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;                      <span class="hljs-comment">// rets数组的索引</span><br>    <span class="hljs-keyword">int</span>[] vends = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[mEdgNum];     <span class="hljs-comment">// 用于保存"已有最小生成树"中每个顶点在该最小树中的终点。</span><br>    EData[] rets = <span class="hljs-keyword">new</span> EData[mEdgNum];  <span class="hljs-comment">// 结果数组，保存kruskal最小生成树的边</span><br>    EData[] edges;                      <span class="hljs-comment">// 图对应的所有边</span><br><br>    <span class="hljs-comment">// 获取"图中所有的边"</span><br>    edges = getEdges();<br>    <span class="hljs-comment">// 将边按照"权"的大小进行排序(从小到大)</span><br>    sortEdges(edges, mEdgNum);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;mEdgNum; i++) &#123;<br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i].start);      <span class="hljs-comment">// 获取第i条边的"起点"的序号</span><br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i].end);        <span class="hljs-comment">// 获取第i条边的"终点"的序号</span><br><br>        <span class="hljs-keyword">int</span> m = getEnd(vends, p1);                 <span class="hljs-comment">// 获取p1在"已有的最小生成树"中的终点</span><br>        <span class="hljs-keyword">int</span> n = getEnd(vends, p2);                 <span class="hljs-comment">// 获取p2在"已有的最小生成树"中的终点</span><br>        <span class="hljs-comment">// 如果m!=n，意味着"边i"与"已经添加到最小生成树中的顶点"没有形成环路</span><br>        <span class="hljs-keyword">if</span> (m != n) &#123;<br>            vends[m] = n;                       <span class="hljs-comment">// 设置m在"已有的最小生成树"中的终点为n</span><br>            rets[index++] = edges[i];           <span class="hljs-comment">// 保存结果</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 统计并打印"kruskal最小生成树"的信息</span><br>    <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>        length += rets[i].weight;<br>    System.out.printf(<span class="hljs-string">"Kruskal=%d: "</span>, length);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>        System.out.printf(<span class="hljs-string">"(%c,%c) "</span>, rets[i].start, rets[i].end);<br>    System.out.printf(<span class="hljs-string">"\n"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="普里姆-Prim-算法"><a href="#普里姆-Prim-算法" class="headerlink" title="普里姆(Prim)算法"></a>普里姆(Prim)算法</h1><p>普里姆(Prim)算法，是用来求加权连通图的最小生成树的算法。</p><p><strong>基本思想</strong><br>对于图G而言，V是所有顶点的集合；现在，设置两个新的集合U和T，其中U用于存放G的最小生成树中的顶点，T存放G的最小生成树中的边。 从所有uЄU，vЄ(V-U) (V-U表示出去U的所有顶点)的边中选取权值最小的边(u, v)，将顶点v加入集合U中，将边(u, v)加入集合T中，如此不断重复，直到U=V为止，最小生成树构造完毕，这时集合T中包含了最小生成树中的所有边。</p><h2 id="普里姆算法图解"><a href="#普里姆算法图解" class="headerlink" title="普里姆算法图解"></a><strong>普里姆算法图解</strong></h2><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/prim/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn3kzc05yj30aj07et8v.jpg" alt="img"></a></p><p>以上图G4为例，来对普里姆进行演示(从第一个顶点A开始通过普里姆算法生成最小生成树)。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/prim/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn3l4fltij30eq184jv3.jpg" alt="img"></a></p><p><strong>初始状态</strong>：V是所有顶点的集合，即V={A,B,C,D,E,F,G}；U和T都是空！<br><strong>第1步</strong>：将顶点A加入到U中。<br>  此时，U={A}。<br><strong>第2步</strong>：将顶点B加入到U中。<br>  上一步操作之后，U={A}, V-U={B,C,D,E,F,G}；因此，边(A,B)的权值最小。将顶点B添加到U中；此时，U={A,B}。<br><strong>第3步</strong>：将顶点F加入到U中。<br>  上一步操作之后，U={A,B}, V-U={C,D,E,F,G}；因此，边(B,F)的权值最小。将顶点F添加到U中；此时，U={A,B,F}。<br><strong>第4步</strong>：将顶点E加入到U中。<br>  上一步操作之后，U={A,B,F}, V-U={C,D,E,G}；因此，边(F,E)的权值最小。将顶点E添加到U中；此时，U={A,B,F,E}。<br><strong>第5步</strong>：将顶点D加入到U中。<br>  上一步操作之后，U={A,B,F,E}, V-U={C,D,G}；因此，边(E,D)的权值最小。将顶点D添加到U中；此时，U={A,B,F,E,D}。<br><strong>第6步</strong>：将顶点C加入到U中。<br>  上一步操作之后，U={A,B,F,E,D}, V-U={C,G}；因此，边(D,C)的权值最小。将顶点C添加到U中；此时，U={A,B,F,E,D,C}。<br><strong>第7步</strong>：将顶点G加入到U中。<br>  上一步操作之后，U={A,B,F,E,D,C}, V-U={G}；因此，边(F,G)的权值最小。将顶点G添加到U中；此时，U=V。</p><p>此时，最小生成树构造完成！它包括的顶点依次是：<strong>A B F E D C G</strong>。</p><h2 id="普里姆算法的代码说明"><a href="#普里姆算法的代码说明" class="headerlink" title="普里姆算法的代码说明"></a><strong>普里姆算法的代码说明</strong></h2><h3 id="1-基本定义-1"><a href="#1-基本定义-1" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = Integer.MAX_VALUE;   <span class="hljs-comment">// 最大值</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-普里姆算法"><a href="#2-普里姆算法" class="headerlink" title="2. 普里姆算法"></a><strong>2. 普里姆算法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * prim最小生成树<br> *<br> * 参数说明：<br> *   start -- 从图中的第start个元素开始，生成最小树<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num = mVexs.length;         <span class="hljs-comment">// 顶点个数</span><br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;                    <span class="hljs-comment">// prim最小树的索引，即prims数组的索引</span><br>    <span class="hljs-keyword">char</span>[] prims  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[num];  <span class="hljs-comment">// prim最小树的结果数组</span><br>    <span class="hljs-keyword">int</span>[] weights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num];   <span class="hljs-comment">// 顶点间边的权值</span><br><br>    <span class="hljs-comment">// prim最小生成树中第一个数是"图中第start个顶点"，因为是从start开始的。</span><br>    prims[index++] = mVexs[start];<br><br>    <span class="hljs-comment">// 初始化"顶点的权值数组"，</span><br>    <span class="hljs-comment">// 将每个顶点的权值初始化为"第start个顶点"到"该顶点"的权值。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++ )<br>        weights[i] = mMatrix[start][i];<br>    <span class="hljs-comment">// 将第start个顶点的权值初始化为0。</span><br>    <span class="hljs-comment">// 可以理解为"第start个顶点到它自身的距离为0"。</span><br>    weights[start] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>        <span class="hljs-comment">// 由于从start开始的，因此不需要再对第start个顶点进行处理。</span><br>        <span class="hljs-keyword">if</span>(start == i)<br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> min = INF;<br>        <span class="hljs-comment">// 在未被加入到最小生成树的顶点中，找出权值最小的顶点。</span><br>        <span class="hljs-keyword">while</span> (j &lt; num) &#123;<br>            <span class="hljs-comment">// 若weights[j]=0，意味着"第j个节点已经被排序过"(或者说已经加入了最小生成树中)。</span><br>            <span class="hljs-keyword">if</span> (weights[j] != <span class="hljs-number">0</span> &amp;&amp; weights[j] &lt; min) &#123;<br>                min = weights[j];<br>                k = j;<br>            &#125;<br>            j++;<br>        &#125;<br><br>        <span class="hljs-comment">// 经过上面的处理后，在未被加入到最小生成树的顶点中，权值最小的顶点是第k个顶点。</span><br>        <span class="hljs-comment">// 将第k个顶点加入到最小生成树的结果数组中</span><br>        prims[index++] = mVexs[k];<br>        <span class="hljs-comment">// 将"第k个顶点的权值"标记为0，意味着第k个顶点已经排序过了(或者说已经加入了最小树结果中)。</span><br>        weights[k] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 当第k个顶点被加入到最小生成树的结果数组中之后，更新其它顶点的权值。</span><br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span> ; j &lt; num; j++) &#123;<br>            <span class="hljs-comment">// 当第j个节点没有被处理，并且需要更新时才被更新。</span><br>            <span class="hljs-keyword">if</span> (weights[j] != <span class="hljs-number">0</span> &amp;&amp; mMatrix[k][j] &lt; weights[j])<br>                weights[j] = mMatrix[k][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算最小生成树的权值</span><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; index; i++) &#123;<br>        <span class="hljs-keyword">int</span> min = INF;<br>        <span class="hljs-comment">// 获取prims[i]在mMatrix中的位置</span><br>        <span class="hljs-keyword">int</span> n = getPosition(prims[i]);<br>        <span class="hljs-comment">// 在vexs[0...i]中，找出到j的权值最小的顶点。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">int</span> m = getPosition(prims[j]);<br>            <span class="hljs-keyword">if</span> (mMatrix[m][n]&lt;min)<br>                min = mMatrix[m][n];<br>        &#125;<br>        sum += min;<br>    &#125;<br>    <span class="hljs-comment">// 打印最小生成树</span><br>    System.out.printf(<span class="hljs-string">"PRIM(%c)=%d: "</span>, mVexs[start], sum);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>        System.out.printf(<span class="hljs-string">"%c "</span>, prims[i]);<br>    System.out.printf(<span class="hljs-string">"\n"</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最小生成树-Prime-Kruskal&quot;&gt;&lt;a href=&quot;#最小生成树-Prime-Kruskal&quot; class=&quot;headerlink&quot; title=&quot;最小生成树(Prime, Kruskal)&quot;&gt;&lt;/a&gt;最小生成树(Prime, Kruskal)&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>7.4.图的拓扑排序</title>
    <link href="http://yoursite.com/2021/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.4.%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2021/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.4.%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</id>
    <published>2021-11-22T14:34:39.000Z</published>
    <updated>2021-11-22T14:37:37.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h1><h2 id="一、拓扑排序"><a href="#一、拓扑排序" class="headerlink" title="一、拓扑排序"></a>一、拓扑排序</h2><h3 id="1-拓扑排序介绍"><a href="#1-拓扑排序介绍" class="headerlink" title="1. 拓扑排序介绍"></a><strong>1. 拓扑排序介绍</strong></h3><p>拓扑排序(Topological Order)是指，将一个<strong>有向无环图</strong>(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的线性序列。</p><p>拓扑排序通常用来“排序”具有依赖关系的任务。比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边 表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。</p><p>如果AOV网络有n个顶点，e条边，在拓扑排序的过程中，搜索入度为零的顶点所需的时间是O(n)。在正常情况下，每个顶点进一次栈，出一次栈，所需时间O(n)。每个顶点入度减1的运算共执行了e次。所以总的时间复杂为O(n+e)。</p><h3 id="2-拓扑排序的算法图解"><a href="#2-拓扑排序的算法图解" class="headerlink" title="2. 拓扑排序的算法图解"></a><strong>2. 拓扑排序的算法图解</strong></h3><p>拓扑排序算法的基本步骤：</p><blockquote><p><strong>1.</strong> 构造一个队列Q(queue) 和 拓扑排序的结果队列T(topological)；<br><strong>2.</strong> 把所有没有依赖顶点的节点放入Q；<br><strong>3.</strong> 当Q还有顶点的时候，执行下面步骤：<br><strong>3.1</strong> 从Q中取出一个顶点n(将n从Q中删掉)，并放入T(将n加入到结果集中)；<br><strong>3.2</strong> 对n每一个邻接点m(n是起点，m是终点)；<br><strong>3.2.1</strong> 去掉边&lt;n,m&gt;;<br><strong>3.2.2</strong> 如果m没有依赖顶点，则把m放入Q;<br><em>注：顶点A没有依赖顶点，是指不存在以A为终点的边。</em></p></blockquote><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/topsort/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmtodh85wj308f08ywek.jpg" alt="img"></a></p><p>以上图为例，来对拓扑排序进行演示。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/topsort/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmtonrt51j30aj0tfaax.jpg" alt="img"></a></p><p><strong>第1步</strong>：将B和C加入到排序结果中。<br>  顶点B和顶点C都是没有依赖顶点，因此将C和C加入到结果集T中。假设ABCDEFG按顺序存储，因此先访问B，再访问C。访问B之后，去掉边&lt;B,A&gt;和&lt;B,D&gt;，并将A和D加入到队列Q中。同样的，去掉边&lt;C,F&gt;和&lt;C,G&gt;，并将F和G加入到Q中。<br>  (01) 将B加入到排序结果中，然后去掉边&lt;B,A&gt;和&lt;B,D&gt;；此时，由于A和D没有依赖顶点，因此并将A和D加入到队列Q中。<br>  (02) 将C加入到排序结果中，然后去掉边&lt;C,F&gt;和&lt;C,G&gt;；此时，由于F有依赖顶点D，G有依赖顶点A，因此不对F和G进行处理。<br><strong>第2步</strong>：将A,D依次加入到排序结果中。<br>  第1步访问之后，A,D都是没有依赖顶点的，根据存储顺序，先访问A，然后访问D。访问之后，删除顶点A和顶点D的出边。<br><strong>第3步</strong>：将E,F,G依次加入到排序结果中。</p><p>因此访问顺序是：<strong>B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; F -&gt; G</strong></p><h3 id="3-拓扑排序的代码"><a href="#3-拓扑排序的代码" class="headerlink" title="3. 拓扑排序的代码"></a><strong>3. 拓扑排序的代码</strong></h3><h4 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h4><p>拓扑排序是对有向无环图的排序。下面以邻接表实现的有向图来对拓扑排序进行说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListDG</span> </span>&#123;<br>    <span class="hljs-comment">// 邻接表中表对应的链表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ENode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ivex;       <span class="hljs-comment">// 该边所指向的顶点的位置</span><br>        ENode nextEdge; <span class="hljs-comment">// 指向下一条弧的指针</span><br>    &#125;<br><br>    <span class="hljs-comment">// 邻接表中表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VNode</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> data;          <span class="hljs-comment">// 顶点信息</span><br>        ENode firstEdge;    <span class="hljs-comment">// 指向第一条依附该顶点的弧</span><br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> VNode[] mVexs;  <span class="hljs-comment">// 顶点数组</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>(1)</strong> ListDG是邻接表对应的结构体。 mVexs则是保存顶点信息的一维数组。<br><strong>(2)</strong> VNode是邻接表顶点对应的结构体。 data是顶点所包含的数据，而firstEdge是该顶点所包含链表的表头指针。<br><strong>(3)</strong> ENode是邻接表顶点所包含的链表的节点对应的结构体。 ivex是该节点所对应的顶点在vexs中的索引，而nextEdge是指向下一个节点的。</p><h4 id="2-拓扑排序"><a href="#2-拓扑排序" class="headerlink" title="2. 拓扑排序"></a><strong>2. 拓扑排序</strong></h4><p>说明：<br><strong>(1)</strong> queue的作用就是用来存储没有依赖顶点的顶点。它与前面所说的Q相对应。<br><strong>(2)</strong> tops的作用就是用来存储排序结果。它与前面所说的T相对应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 拓扑排序<br> *<br> * 返回值：<br> *     -1 -- 失败(由于内存不足等原因导致)<br> *      0 -- 成功排序，并输入结果<br> *      1 -- 失败(该有向图是有环的)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">topologicalSort</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> num = mVexs.size();<br>    <span class="hljs-keyword">int</span>[] ins;               <span class="hljs-comment">// 入度数组</span><br>    <span class="hljs-keyword">char</span>[] tops;             <span class="hljs-comment">// 拓扑排序结果数组，记录每个节点的排序后的序号。</span><br>    Queue&lt;Integer&gt; queue;    <span class="hljs-comment">// 辅组队列</span><br><br>    ins   = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num];<br>    tops  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[num];<br>    queue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br><br>    <span class="hljs-comment">// 统计每个顶点的入度数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br><br>        ENode node = mVexs.get(i).firstEdge; <span class="hljs-comment">//获取以该顶点为起点的出边队列</span><br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>            ins[node.ivex]++;<br>            node = node.nextEdge;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将所有入度为0的顶点入队列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i ++)<br>        <span class="hljs-keyword">if</span>(ins[i] == <span class="hljs-number">0</span>)<br>            queue.offer(i);                 <span class="hljs-comment">// 入队列</span><br><br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;              <span class="hljs-comment">// 队列非空</span><br>        <span class="hljs-keyword">int</span> j = queue.poll().intValue();    <span class="hljs-comment">// 出队列。j是顶点的序号</span><br>        tops[index++] = mVexs.get(j).data;  <span class="hljs-comment">// 将该顶点添加到tops中，tops是排序结果</span><br>        ENode node = mVexs.get(j).firstEdge;<span class="hljs-comment">// 获取以该顶点为起点的出边队列</span><br><br>        <span class="hljs-comment">// 将与"node"关联的节点的入度减1；</span><br>        <span class="hljs-comment">// 若减1之后，该节点的入度为0；则将该节点添加到队列中。</span><br>        <span class="hljs-keyword">while</span>(node != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 将节点(序号为node.ivex)的入度减1。</span><br>            ins[node.ivex]--;<br>            <span class="hljs-comment">// 若节点的入度为0，则将其"入队列"</span><br>            <span class="hljs-keyword">if</span>( ins[node.ivex] == <span class="hljs-number">0</span>)<br>                queue.offer(node.ivex);    <span class="hljs-comment">// 入队列</span><br><br>            node = node.nextEdge;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(index != num) &#123;<br>        System.out.printf(<span class="hljs-string">"Graph has a cycle\n"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印拓扑排序结果</span><br>    System.out.printf(<span class="hljs-string">"== TopSort: "</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i ++)<br>        System.out.printf(<span class="hljs-string">"%c "</span>, tops[i]);<br>    System.out.printf(<span class="hljs-string">"\n"</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图的应用&quot;&gt;&lt;a href=&quot;#图的应用&quot; class=&quot;headerlink&quot; title=&quot;图的应用&quot;&gt;&lt;/a&gt;图的应用&lt;/h1&gt;&lt;h2 id=&quot;一、拓扑排序&quot;&gt;&lt;a href=&quot;#一、拓扑排序&quot; class=&quot;headerlink&quot; title=&quot;一、拓扑排
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>7.3.图的遍历(DFS,BFS)</title>
    <link href="http://yoursite.com/2021/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.3.%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86(DFS,BFS)/"/>
    <id>http://yoursite.com/2021/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.3.%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86(DFS,BFS)/</id>
    <published>2021-11-22T14:32:39.000Z</published>
    <updated>2021-11-22T14:37:15.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a><strong>图的遍历</strong></h1><h2 id="一、深度优先搜索-Depth-First-Search-DFS"><a href="#一、深度优先搜索-Depth-First-Search-DFS" class="headerlink" title="一、深度优先搜索(Depth First Search, DFS)"></a>一、深度优先搜索(Depth First Search, DFS)</h2><h3 id="1-深度优先搜索介绍"><a href="#1-深度优先搜索介绍" class="headerlink" title="1. 深度优先搜索介绍"></a><strong>1. 深度优先搜索介绍</strong></h3><p>图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。</p><p>它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>显然，深度优先搜索是一个递归的过程。</p><h3 id="2-深度优先搜索图解"><a href="#2-深度优先搜索图解" class="headerlink" title="2. 深度优先搜索图解"></a><strong>2. 深度优先搜索图解</strong></h3><h4 id="2-1-无向图的深度优先搜索"><a href="#2-1-无向图的深度优先搜索" class="headerlink" title="2.1 无向图的深度优先搜索"></a><strong>2.1 无向图的深度优先搜索</strong></h4><p>下面以”无向图”为例，来对深度优先搜索进行演示。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmlnfvwp5j30bl08f74e.jpg" alt="img"></a></p><p>对上面的图G1进行深度优先遍历，从顶点A开始。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmlngl8zqj30c409h0t0.jpg" alt="img"></a></p><p><strong>第1步</strong>：访问A。<br><strong>第2步</strong>：访问(A的邻接点)C。<br>  在第1步访问A之后，接下来应该访问的是A的邻接点，即”C,D,F”中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在”D和F”的前面，因此，先访问C。<br><strong>第3步</strong>：访问(C的邻接点)B。<br>  在第2步访问C之后，接下来应该访问C的邻接点，即”B和D”中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。<br><strong>第4步</strong>：访问(C的邻接点)D。<br>  在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。<br><strong>第5步</strong>：访问(A的邻接点)F。<br>  前面已经访问了A，并且访问完了”A的邻接点B的所有邻接点(包括递归的邻接点在内)”；因此，此时返回到访问A的另一个邻接点F。<br><strong>第6步</strong>：访问(F的邻接点)G。<br><strong>第7步</strong>：访问(G的邻接点)E。</p><p>因此访问顺序是：<strong>A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E</strong></p><h4 id="2-2-有向图的深度优先搜索"><a href="#2-2-有向图的深度优先搜索" class="headerlink" title="2.2 有向图的深度优先搜索"></a><strong>2.2 有向图的深度优先搜索</strong></h4><p>下面以”有向图”为例，来对深度优先搜索进行演示。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/03.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmlpwnltaj308f08yt8t.jpg" alt="img"></a></p><p>对上面的图G2进行深度优先遍历，从顶点A开始。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/04.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmlpy4gxuj308f0a0wer.jpg" alt="img"></a></p><p><strong>第1步</strong>：访问A。<br><strong>第2步</strong>：访问B。<br>  在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。<br><strong>第3步</strong>：访问C。<br>  在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。<br><strong>第4步</strong>：访问E。<br>  接下来访问C的出边的另一个顶点，即顶点E。<br><strong>第5步</strong>：访问D。<br>  接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。<br><strong>第6步</strong>：访问F。<br>  接下应该回溯”访问A的出边的另一个顶点F”。<br><strong>第7步</strong>：访问G。</p><p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G</strong></p><h4 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><p><strong>邻接矩阵的深度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接矩阵的深度优先遍历</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 深度优先遍历</span><br><span class="hljs-keyword">boolean</span>[] beTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.vertices];<br><span class="hljs-comment">// 保存顶点的遍历状态，默认为false</span><br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>System.out.print(<span class="hljs-string">"深度优先遍历结果："</span>);<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList.get(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">this</span>.dfs(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, beTraversed);<br>System.out.println();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">boolean</span>[] beTraversed)</span> </span>&#123;<br><span class="hljs-comment">// 遍历x的第y个邻接点</span><br><span class="hljs-keyword">while</span> (y &lt; <span class="hljs-keyword">this</span>.vertices) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.edgeMatrix[x][y] != <span class="hljs-number">0</span> &amp;&amp; !beTraversed[y]) &#123;<br>beTraversed[y] = <span class="hljs-keyword">true</span>;<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList.get(y));<br><span class="hljs-keyword">this</span>.dfs(y, <span class="hljs-number">0</span>, beTraversed); <span class="hljs-comment">// 从y的第0个邻接点开始深度优先遍历</span><br>&#125;<br>y++;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>邻接表的深度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接表的深度优先遍历</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 深度优先遍历</span><br><span class="hljs-keyword">boolean</span>[] beTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.vertices];<br><span class="hljs-comment">// 保存顶点的遍历状态，默认为false</span><br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>System.out.print(<span class="hljs-string">"深度优先遍历结果："</span>);<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList[<span class="hljs-number">0</span>].data);<br><span class="hljs-keyword">this</span>.dfs(<span class="hljs-number">0</span>, beTraversed);<br>System.out.println();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">boolean</span>[] beTraversed)</span> </span>&#123;<br><span class="hljs-comment">// 从第i个顶点开始深度优先遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j : <span class="hljs-keyword">this</span>.vertexList[i].adj) &#123;<br><span class="hljs-keyword">if</span> (!beTraversed[j]) &#123;<br>beTraversed[j] = <span class="hljs-keyword">true</span>;<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList[j].data);<br><span class="hljs-keyword">this</span>.dfs(j, beTraversed);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自己构造邻接表的深度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bean.algorithm.graph;<br> <br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DFSGraph</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> V; <span class="hljs-comment">// 定义结点（vertices）</span><br> <br><span class="hljs-comment">// 图的邻接表表示（ Adjacency List）</span><br><span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; adj[];<br> <br><span class="hljs-comment">// 构造图的构造方法</span><br>DFSGraph(<span class="hljs-keyword">int</span> v) &#123;<br>V = v;<br>adj = <span class="hljs-keyword">new</span> LinkedList[v];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i)<br>adj[i] = <span class="hljs-keyword">new</span> LinkedList();<br>&#125;<br> <br><span class="hljs-comment">// 向图中添加边</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>adj[v].add(w); <br>&#125;<br> <br><span class="hljs-comment">// DFS算法工具</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFSUtil</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">boolean</span> visited[])</span> </span>&#123;<br><span class="hljs-comment">// 标记当前结点为已访问（visited）并输出</span><br>visited[v] = <span class="hljs-keyword">true</span>;<br>System.out.print(v + <span class="hljs-string">" "</span>);<br> <br><span class="hljs-comment">// 访问当前的结点的所有邻接结点</span><br>Iterator&lt;Integer&gt; i = adj[v].listIterator();<br><span class="hljs-keyword">while</span> (i.hasNext()) &#123;<br><span class="hljs-keyword">int</span> n = i.next();<br><span class="hljs-keyword">if</span> (!visited[n])<br>DFSUtil(n, visited);<br>&#125;<br>&#125;<br> <br><span class="hljs-comment">// DFS traversal. 用来回溯调用 DFSUtil()工具</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br><span class="hljs-comment">// 标记所有节点为未访问状态（ not visited），设置初始值为false。</span><br><span class="hljs-keyword">boolean</span> visited[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[V];<br> <br><span class="hljs-comment">// 回溯 DFS traversal</span><br>DFSUtil(v, visited);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>DFSGraph g = <span class="hljs-keyword">new</span> DFSGraph(<span class="hljs-number">4</span>);<br> <br>g.addEdge(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>g.addEdge(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>g.addEdge(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>g.addEdge(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>g.addEdge(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>g.addEdge(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br> <br>System.out.println(<span class="hljs-string">"下面是DFS搜索结果 "</span> + <span class="hljs-string">"(从2号结点开始)"</span>);<br> <br>g.DFS(<span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、广度优先搜索-Breadth-First-Search-BFS"><a href="#二、广度优先搜索-Breadth-First-Search-BFS" class="headerlink" title="二、广度优先搜索(Breadth First Search, BFS)"></a><strong>二、广度优先搜索(Breadth First Search, BFS)</strong></h2><h3 id="1-广度优先搜索介绍"><a href="#1-广度优先搜索介绍" class="headerlink" title="1. 广度优先搜索介绍"></a><strong>1. 广度优先搜索介绍</strong></h3><p>广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。</p><p>它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。</p><h3 id="2-广度优先搜索图解"><a href="#2-广度优先搜索图解" class="headerlink" title="2. 广度优先搜索图解"></a><strong>2. 广度优先搜索图解</strong></h3><h4 id="2-1-无向图的广度优先搜索"><a href="#2-1-无向图的广度优先搜索" class="headerlink" title="2.1 无向图的广度优先搜索"></a><strong>2.1 无向图的广度优先搜索</strong></h4><p>下面以”无向图”为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/05.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmltsvygcj30eq0e7dge.jpg" alt="img"></a></p><p><strong>第1步</strong>：访问A。<br><strong>第2步</strong>：依次访问C,D,F。<br>  在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在”D和F”的前面，因此，先访问C。再访问完C之后，再依次访问D,F。<br><strong>第3步</strong>：依次访问B,G。<br>  在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。<br><strong>第4步</strong>：访问E。<br>  在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。</p><p>因此访问顺序是：<strong>A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E</strong></p><h4 id="2-2-有向图的广度优先搜索"><a href="#2-2-有向图的广度优先搜索" class="headerlink" title="2.2 有向图的广度优先搜索"></a><strong>2.2 有向图的广度优先搜索</strong></h4><p>下面以”有向图”为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/06.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmluvpt0jj30fs0cnq3k.jpg" alt="img"></a></p><p><strong>第1步</strong>：访问A。<br><strong>第2步</strong>：访问B。<br><strong>第3步</strong>：依次访问C,E,F。<br>  在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。<br><strong>第4步</strong>：依次访问D,G。<br>  在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。</p><p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G</strong></p><h4 id="2-3-代码实现-1"><a href="#2-3-代码实现-1" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><p><strong>邻接矩阵的广度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接矩阵的广度优先遍历</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 宽度优先遍历</span><br><span class="hljs-keyword">boolean</span>[] beTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.vertices];<br><span class="hljs-comment">// 保存顶点的遍历状态，默认为false</span><br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>Queue queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>queue.offer(<span class="hljs-number">0</span>);<br><br>System.out.print(<span class="hljs-string">"宽度优先遍历："</span>);<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br><span class="hljs-keyword">int</span> index = queue.poll();<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList.get(index));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.vertices; i++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.edgeMatrix[index][i] != <span class="hljs-number">0</span> &amp;&amp; !beTraversed[i]) &#123;<br><span class="hljs-comment">// 找出所有没有访问过的邻接点</span><br>beTraversed[i] = <span class="hljs-keyword">true</span>;<br>queue.offer(i);<br>&#125;<br>&#125;<br>&#125;<br>System.out.println();<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>邻接表的广度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接表的广度优先遍历</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 宽度优先遍历</span><br><span class="hljs-keyword">boolean</span>[] beTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.vertices];<br><span class="hljs-comment">// 保存顶点的遍历状态，默认为false</span><br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>Queue queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>queue.offer(<span class="hljs-number">0</span>);<br><br>System.out.print(<span class="hljs-string">"宽度优先遍历："</span>);<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br><span class="hljs-keyword">int</span> index = queue.poll();<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList[index].data);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : <span class="hljs-keyword">this</span>.vertexList[index].adj) &#123;<br><span class="hljs-comment">// 所有未被访问过的邻接点入队</span><br><span class="hljs-keyword">if</span> (!beTraversed[i]) &#123;<br>beTraversed[i] = <span class="hljs-keyword">true</span>;<br>queue.offer(i);<br>&#125;<br>&#125;<br>&#125;<br>System.out.println();<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图的遍历&quot;&gt;&lt;a href=&quot;#图的遍历&quot; class=&quot;headerlink&quot; title=&quot;图的遍历&quot;&gt;&lt;/a&gt;&lt;strong&gt;图的遍历&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;一、深度优先搜索-Depth-First-Search-DFS&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>7.2.图的概念和储存结构</title>
    <link href="http://yoursite.com/2021/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.2.%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2021/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.2.%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2021-11-22T14:31:39.000Z</published>
    <updated>2021-11-22T14:37:03.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图-graph"><a href="#图-graph" class="headerlink" title="图(graph)"></a>图(graph)</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-图的定义"><a href="#1-图的定义" class="headerlink" title="1. 图的定义"></a><strong>1. 图的定义</strong></h3><p>定义：图(graph)是由一些点(vertex)和这些点之间的连线(edge)所组成的；其中，点通常被成为”顶点(vertex)”，而点与点之间的连线则被成为”边或弧”(edege)。通常记为，G=(V,E)。</p><h3 id="2-图的种类"><a href="#2-图的种类" class="headerlink" title="2. 图的种类"></a><strong>2. 图的种类</strong></h3><p>根据边是否有方向，将图可以划分为：<strong>无向图</strong>和<strong>有向图</strong></p><h4 id="2-1-无向图"><a href="#2-1-无向图" class="headerlink" title="2.1 无向图"></a><strong>2.1 无向图</strong></h4><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmg3skx7zj308f08fjrg.jpg" alt="img"></a></p><p>上面的图G0是无向图，无向图的所有的边都是不区分方向的。G0=(V1,{E1})。其中，</p><p><strong>(1)</strong> V1={A,B,C,D,E,F}。 V1表示由”A,B,C,D,E,F”几个顶点组成的集合。<br><strong>(2)</strong> E1={(A,B),(A,C),(B,C),(B,E),(B,F),(C,F), (C,D),(E,F),(C,E)}。 E1是由边(A,B),边(A,C)…等等组成的集合。其中，(A,C)表示由顶点A和顶点C连接成的边。</p><p><strong>无向完全图</strong>：在一个无向图中，如果任意两顶点都有一条直接边相连接，则称该图为无向完全图。可以证明，在一个含有n个顶点的无向完全图中，有n（n-1）/2条边。</p><h4 id="2-2-有向图"><a href="#2-2-有向图" class="headerlink" title="2.2 有向图"></a><strong>2.2 有向图</strong></h4><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmg8f6ii6j308f08yt8t.jpg" alt="img"></a></p><p>上面的图G2是有向图。和无向图不同，有向图的所有的边都是有方向的！ G2=(V2,{A2})。其中，</p><p><strong>(1)</strong> V2={A,C,B,F,D,E,G}。 V2表示由”A,B,C,D,E,F,G”几个顶点组成的集合。<br><strong>(2)</strong> A2={&lt;A,B&gt;,&lt;B,C&gt;,&lt;B,F&gt;,&lt;B,E&gt;,&lt;C,E&gt;,&lt;E,D&gt;,&lt;D,C&gt;,&lt;E,B&gt;,&lt;F,G&gt;}。 E1是由矢量&lt;A,B&gt;,矢量&lt;B,C&gt;…等等组成的集合。其中，矢量&lt;A,B&gt;表示由”顶点A”指向”顶点C”的有向边。</p><p><strong>有向完全图</strong>：在有一个有向图中，如果任意两顶点之间都有方向互为相反的两条弧相连接，则称该图为有向完全图。在一个含有n个顶点的有向完全图中，有n(n-1)条边。</p><h3 id="3-邻接点和度"><a href="#3-邻接点和度" class="headerlink" title="3. 邻接点和度"></a><strong>3. 邻接点和度</strong></h3><h4 id="3-1-邻接点"><a href="#3-1-邻接点" class="headerlink" title="3.1 邻接点"></a><strong>3.1 邻接点</strong></h4><p>一条边上的两个顶点叫做邻接点。<br><em>例如，上面无向图G0中的顶点A和顶点C就是邻接点。</em></p><p>在有向图中，除了邻接点之外；还有”入边”和”出边”的概念。<br>顶点的入边，是指以该顶点为终点的边。而顶点的出边，则是指以该顶点为起点的边。<br><em>例如，上面有向图G2中的B和E是邻接点；&lt;B,E&gt;是B的出边，还是E的入边。</em></p><h4 id="3-2-度"><a href="#3-2-度" class="headerlink" title="3.2 度"></a><strong>3.2 度</strong></h4><p>在无向图中，某个顶点的度是邻接到该顶点的边(或弧)的数目。<br><em>例如，上面无向图G0中顶点A的度是2。</em></p><p>在有向图中，度还有”入度”和”出度”之分。<br>某个顶点的入度，是指以该顶点为终点的边的数目。而顶点的出度，则是指以该顶点为起点的边的数目。<br><strong>顶点的度=入度+出度。</strong><br><em>例如，上面有向图G2中，顶点B的入度是2，出度是3；顶点B的度=2+3=5。</em></p><h3 id="4-路径和回路"><a href="#4-路径和回路" class="headerlink" title="4. 路径和回路"></a><strong>4. 路径和回路</strong></h3><p><strong>路径</strong>：如果顶点(Vm)到顶点(Vn)之间存在一个顶点序列。则表示Vm到Vn是一条路径。<br><strong>路径长度</strong>：路径中”边的数量”。<br><strong>简单路径</strong>：若一条路径上顶点不重复出现，则是简单路径。<br><strong>回路</strong>：若路径的第一个顶点和最后一个顶点相同，则是回路。<br><strong>简单回路</strong>：第一个顶点和最后一个顶点相同，其它各顶点都不重复的回路则是简单回路。</p><h3 id="5-连通图和连通分量"><a href="#5-连通图和连通分量" class="headerlink" title="5. 连通图和连通分量"></a><strong>5. 连通图和连通分量</strong></h3><p><strong>连通图</strong>：对无向图而言，<strong>任意两个顶点之间都存在一条无向路径</strong>，则称该无向图为连通图。 对有向图而言，若图中<strong>任意两个顶点之间都存在一条有向路径</strong>，则称该有向图为强连通图。</p><p><strong>连通分量</strong>：<strong>非连通图中的各个连通子图称为该图的连通分量</strong>。</p><h3 id="6-权"><a href="#6-权" class="headerlink" title="6. 权"></a><strong>6. 权</strong></h3><p>在学习”哈夫曼树”的时候，了解过”权”的概念。图中权的概念与此类似。</p><p>边的权、网：与边有关的数据信息称为权(Weight)。在实际应用中，权值可以有某种含义。例如，在一个反映城市交通线路的图中，边上的权值可以表示该条线路的长度或等级；对于一个电子线路图，边上的权值可以表示两个端点之间的电阻、电流或电压值；对于反映工程进度的图而言，边上的权值可以表示从前一个工程到后一个工程所需要的时间或其他代价等。边上带权的图称为网或网络（network）。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/03.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmgsy4rtpj308f08faa6.jpg" alt="img"></a></p><p>上面就是一个带权的图。</p><h3 id="7-生成树"><a href="#7-生成树" class="headerlink" title="7. 生成树"></a>7. 生成树</h3><p>所谓连通图G的生成树，是G的包含其全部n个顶点的一个极小连通子图，所谓极小连通子图是指在包含所有顶点且保证连通的前提下尽可能少地包含原图中的边。生成树必定包含且仅包含连通图G的n-1条边。在生成树中添加任意一条属于原图中的边必定会产生回路，因为新添加的边使其所依附的两个顶点之间有了第二条路径。若生成树中减少任意一条边，则必然成为非连通的。</p><h3 id="8-生成森林"><a href="#8-生成森林" class="headerlink" title="8. 生成森林"></a>8. 生成森林</h3><p>在非连通图中，由每个连通分量都可得到一个极小连通子图，即一棵生成树。这些连通分量的生成树就组成了一个非连通图的生成森林。</p><h2 id="二、图的存储结构"><a href="#二、图的存储结构" class="headerlink" title="二、图的存储结构"></a>二、图的存储结构</h2><h3 id="1-邻接矩阵"><a href="#1-邻接矩阵" class="headerlink" title="1. 邻接矩阵"></a><strong>1. 邻接矩阵</strong></h3><p>邻接矩阵是指用矩阵来表示图。它是采用矩阵来描述图中顶点之间的关系(及弧或边的权)。<br>假设图中顶点数为n，则邻接矩阵定义为：</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/04.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh21hzetj30bl035gln.jpg" alt="img"></a><br>下面通过示意图来进行解释。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/05.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh227kinj30lk08ymxu.jpg" alt="img"></a></p><p>图中的G1是无向图和它对应的邻接矩阵。</p><p>无向图的邻接矩阵是一个对称矩阵，是因为边不具有方向性，所以在邻接矩阵中对角线上皆为0。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/06.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh2xdkz2j30l108ygmb.jpg" alt="img"></a></p><p>图中的G2是无向图和它对应的邻接矩阵。</p><p>有向图由于边具有方向性，因此彼此顶点之间并不能相互达到，所以其邻接矩阵的对称性不再。</p><p>通常采用两个数组来实现邻接矩阵：一个一维数组用来保存顶点信息，一个二维数组来用保存边的信息。而根据实际情况可以分析得，图中的顶点并不是任意两个顶点间都会相连，不是都需要对其边上权重进行存储。那么存储的邻接矩阵实际上会存在大量的0。虽然可以通过稀疏表示等方式对稀疏性高的矩阵进行关键信息的存储，但是却增加了图存储的复杂性。<br><strong>缺点</strong>:就是比较耗费空间。</p><h3 id="2-邻接表"><a href="#2-邻接表" class="headerlink" title="2. 邻接表"></a><strong>2. 邻接表</strong></h3><p>邻接表是图的一种链式存储表示方法。它是改进后的”邻接矩阵”。</p><p><strong>缺点：是不方便判断两个顶点之间是否有边。</strong></p><p><strong>优点：相对邻接矩阵来说更省空间。</strong></p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/07.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh65wupuj30n409hmxw.jpg" alt="img"></a></p><p>图中的G1是无向图和它对应的邻接矩阵。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/08.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh97vnlnj30lk09hdgh.jpg" alt="img"></a></p><p>图中的G2是无向图和它对应的邻接矩阵。</p><p>由此看出，<strong>在对有向图进行表示时，邻接表只能求出图的出度，而无法求出入度。</strong>这个问题很好解决，那就是增加一个表用来存储能够到达某个顶点的相邻顶点。这个表称作逆邻接表。</p><h3 id="3-逆邻接表"><a href="#3-逆邻接表" class="headerlink" title="3. 逆邻接表"></a>3. <strong>逆邻接表</strong></h3><p>逆邻接表与邻接表结构类似，只不过图的顶点链接着能够到达该顶点的相邻顶点。也就是说，邻接表时顺着图中的箭头寻找相邻顶点，而逆邻接表时逆着图中的箭头寻找相邻顶点。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmhhjp483j314o0jedha.jpg" alt="image-20211121085043748"></p><p>邻接表和逆邻接表的共同使用下，就能够把一个完整的有向图结构进行表示。可以发现，邻接表和逆邻接表实际上有一部分数据时重合的，因此可以将两个表合二为一，从而得到了所谓的十字链表。</p><h3 id="4-十字链表"><a href="#4-十字链表" class="headerlink" title="4. 十字链表"></a>4. <strong>十字链表</strong></h3><p>十字链表似乎很简单，只需要通过相同的顶点分别链向以该顶点为终点和起点的相邻顶点即可。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmhjkii88j314e0icgns.jpg" alt="image-20211121085241805"></p><p>但这并不是最优的表示方式。虽然这样的方式共用了中间的顶点存储空间，但是邻接表和逆邻接表的链表节点中重复出现的顶点并没有得到重复利用，反而是进行了再次存储。因此，上图的表示方式还可以进行进一步优化。</p><p>十字链表优化后，可通过扩展的顶点结构和边结构来进行正逆邻接表的存储：（下面的弧头可看作是边的箭头那端，弧尾可看作是边的圆点那端）</p><p><strong>顶点结构</strong></p><blockquote><p><strong>data</strong>：用于存储该顶点中的数据； </p><p><strong>firstin指针</strong>：用于连接以当前顶点为弧头的其他顶点构成的链表，即从别的顶点指进来的顶点；</p><p><strong>firstout指针</strong>：用于连接以当前顶点为弧尾的其他顶点构成的链表，即从该顶点指出去的顶点;</p></blockquote><p><strong>边结构</strong>通过存储两个顶点来确定一条边，同时通过分别代表这两个顶点的指针来与相邻顶点进行链接：</p><blockquote><p><strong>tailvex</strong>：用于存储作为弧尾的顶点的编号； </p><p><strong>headvex</strong>：用于存储作为弧头的顶点的编号； </p><p><strong>headlink 指针</strong>：用于链接下一个存储作为弧头的顶点的节点； </p><p><strong>taillink 指针</strong>：用于链接下一个存储作为弧尾的顶点的节点；</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmhunyr03j31q90u0q7p.jpg" alt="image-20211121090318141"></p><p>以上图为例子，对于顶点A而言，其作为起点能够到达顶点E。因此在邻接表中顶点A要通过边<code>AE</code>（即边04）指向顶点E，顶点A的<code>firstout</code>指针需要指向边04的<code>tailvex</code>。同时，从B出发能够到达A，所以在逆邻接表中顶点A要通过边<code>AB</code>（即边10）指向B，顶点A的<code>firstin</code>指针需要指向边10的弧头，即<code>headlink</code>指针。依次类推。</p><p>十字链表采用了一种看起来比较繁乱的方式对边的方向性进行了表示，能够在尽可能降低存储空间的情况下增加指针保留顶点之间的方向性。具体的操作可能一时间不好弄懂，建议多看几次上图，弄清指针指向的意义，明白正向和逆向邻接表的表示。</p><h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><h3 id="1-邻接矩阵无向图"><a href="#1-邻接矩阵无向图" class="headerlink" title="1. 邻接矩阵无向图"></a>1. 邻接矩阵无向图</h3><p><strong>基本定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里介绍提供了两个创建矩阵的方法。一个是<strong>用已知数据</strong>，另一个则<strong>需要用户手动输入数据</strong>。</p><h4 id="1-1-创建图-用已提供的矩阵"><a href="#1-1-创建图-用已提供的矩阵" class="headerlink" title="1.1 创建图(用已提供的矩阵)"></a><strong>1.1 创建图(用已提供的矩阵)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 创建图(用已提供的矩阵)<br> *<br> * 参数说明：<br> *     vexs  -- 顶点数组<br> *     edges -- 边数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MatrixUDG</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vexs, <span class="hljs-keyword">char</span>[][] edges)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span><br>    <span class="hljs-keyword">int</span> vlen = vexs.length;<br>    <span class="hljs-keyword">int</span> elen = edges.length;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++)<br>        mVexs[i] = vexs[i];<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    mMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vlen][vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i][<span class="hljs-number">1</span>]);<br><br>        mMatrix[p1][p2] = <span class="hljs-number">1</span>;<br>        mMatrix[p2][p1] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是利用已知数据来创建一个邻接矩阵无向图。 实际上，在本文的测试程序源码中，该方法创建的无向图就是上面图G1。具体的调用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] vexs = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;;<br>    <span class="hljs-keyword">char</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[][]&#123;<br>        &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>&#125;, <br>        &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'D'</span>&#125;, <br>        &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'F'</span>&#125;, <br>        &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>&#125;, <br>        &#123;<span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>&#125;, <br>        &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'G'</span>&#125;, <br>        &#123;<span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;&#125;;<br>    MatrixUDG pG;<br><br>    pG = <span class="hljs-keyword">new</span> MatrixUDG(vexs, edges);<br></code></pre></td></tr></table></figure><h4 id="1-2-创建图-自己输入"><a href="#1-2-创建图-自己输入" class="headerlink" title="1.2 创建图(自己输入)"></a><strong>1.2 创建图(自己输入)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 创建图(自己输入数据)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MatrixUDG</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 输入"顶点数"和"边数"</span><br>    System.out.printf(<span class="hljs-string">"input vertex number: "</span>);<br>    <span class="hljs-keyword">int</span> vlen = readInt();<br>    System.out.printf(<span class="hljs-string">"input edge number: "</span>);<br>    <span class="hljs-keyword">int</span> elen = readInt();<br>    <span class="hljs-keyword">if</span> ( vlen &lt; <span class="hljs-number">1</span> || elen &lt; <span class="hljs-number">1</span> || (elen &gt; (vlen*(vlen - <span class="hljs-number">1</span>)))) &#123;<br>        System.out.printf(<span class="hljs-string">"input error: invalid parameters!\n"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        System.out.printf(<span class="hljs-string">"vertex(%d): "</span>, i);<br>        mVexs[i] = readChar();<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    mMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vlen][vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        System.out.printf(<span class="hljs-string">"edge(%d):"</span>, i);<br>        <span class="hljs-keyword">char</span> c1 = readChar();<br>        <span class="hljs-keyword">char</span> c2 = readChar();<br>        <span class="hljs-keyword">int</span> p1 = getPosition(c1);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(c2);<br><br>        <span class="hljs-keyword">if</span> (p1==-<span class="hljs-number">1</span> || p2==-<span class="hljs-number">1</span>) &#123;<br>            System.out.printf(<span class="hljs-string">"input error: invalid edge!\n"</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        mMatrix[p1][p2] = <span class="hljs-number">1</span>;<br>        mMatrix[p2][p1] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-邻接矩阵有向图"><a href="#2-邻接矩阵有向图" class="headerlink" title="2. 邻接矩阵有向图"></a><strong>2. 邻接矩阵有向图</strong></h3><p><strong>基本定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里介绍提供了两个创建矩阵的方法。一个是<strong>用已知数据</strong>，另一个则<strong>需要用户手动输入数据</strong>。</p><h4 id="2-1-创建图-用已提供的矩阵"><a href="#2-1-创建图-用已提供的矩阵" class="headerlink" title="2.1 创建图(用已提供的矩阵)"></a><strong>2.1 创建图(用已提供的矩阵)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 创建图(用已提供的矩阵)<br> *<br> * 参数说明：<br> *     vexs  -- 顶点数组<br> *     edges -- 边数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MatrixDG</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vexs, <span class="hljs-keyword">char</span>[][] edges)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span><br>    <span class="hljs-keyword">int</span> vlen = vexs.length;<br>    <span class="hljs-keyword">int</span> elen = edges.length;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++)<br>        mVexs[i] = vexs[i];<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    mMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vlen][vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i][<span class="hljs-number">1</span>]);<br><br>        mMatrix[p1][p2] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是创建一个邻接矩阵有向图。实际上，该方法创建的有向图，就是上面的图G2。它的调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] vexs = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;;<br><span class="hljs-keyword">char</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[][]&#123;<br>    &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>&#125;, <br>    &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>&#125;, <br>    &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'E'</span>&#125;, <br>    &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'F'</span>&#125;, <br>    &#123;<span class="hljs-string">'C'</span>, <span class="hljs-string">'E'</span>&#125;, <br>    &#123;<span class="hljs-string">'D'</span>, <span class="hljs-string">'C'</span>&#125;, <br>    &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'B'</span>&#125;, <br>    &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'D'</span>&#125;, <br>    &#123;<span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;&#125;; <br>MatrixDG pG;<br><br>pG = <span class="hljs-keyword">new</span> MatrixDG(vexs, edges);<br></code></pre></td></tr></table></figure><h4 id="2-2-创建图-自己输入"><a href="#2-2-创建图-自己输入" class="headerlink" title="2.2 创建图(自己输入)"></a><strong>2.2 创建图(自己输入)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 创建图(自己输入数据)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MatrixDG</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 输入"顶点数"和"边数"</span><br>    System.out.printf(<span class="hljs-string">"input vertex number: "</span>);<br>    <span class="hljs-keyword">int</span> vlen = readInt();<br>    System.out.printf(<span class="hljs-string">"input edge number: "</span>);<br>    <span class="hljs-keyword">int</span> elen = readInt();<br>    <span class="hljs-keyword">if</span> ( vlen &lt; <span class="hljs-number">1</span> || elen &lt; <span class="hljs-number">1</span> || (elen &gt; (vlen*(vlen - <span class="hljs-number">1</span>)))) &#123;<br>        System.out.printf(<span class="hljs-string">"input error: invalid parameters!\n"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        System.out.printf(<span class="hljs-string">"vertex(%d): "</span>, i);<br>        mVexs[i] = readChar();<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    mMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vlen][vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        System.out.printf(<span class="hljs-string">"edge(%d):"</span>, i);<br>        <span class="hljs-keyword">char</span> c1 = readChar();<br>        <span class="hljs-keyword">char</span> c2 = readChar();<br>        <span class="hljs-keyword">int</span> p1 = getPosition(c1);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(c2);<br><br>        <span class="hljs-keyword">if</span> (p1==-<span class="hljs-number">1</span> || p2==-<span class="hljs-number">1</span>) &#123;<br>            System.out.printf(<span class="hljs-string">"input error: invalid edge!\n"</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        mMatrix[p1][p2] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-邻接表无向图"><a href="#3-邻接表无向图" class="headerlink" title="3. 邻接表无向图"></a><strong>3. 邻接表无向图</strong></h3><p><strong>基本定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListUDG</span> </span>&#123;<br>    <span class="hljs-comment">// 邻接表中表对应的链表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ENode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ivex;       <span class="hljs-comment">// 该边所指向的顶点的位置</span><br>        ENode nextEdge; <span class="hljs-comment">// 指向下一条弧的指针</span><br>    &#125;<br><br>    <span class="hljs-comment">// 邻接表中表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VNode</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> data;          <span class="hljs-comment">// 顶点信息</span><br>        ENode firstEdge;    <span class="hljs-comment">// 指向第一条依附该顶点的弧</span><br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> VNode[] mVexs;  <span class="hljs-comment">// 顶点数组</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>(1)</strong> ListUDG是邻接表对应的结构体。mVexs则是保存顶点信息的一维数组。<br><strong>(2)</strong> VNode是邻接表顶点对应的结构体。 data是顶点所包含的数据，而firstEdge是该顶点所包含链表的表头指针。<br><strong>(3)</strong> ENode是邻接表顶点所包含的链表的节点对应的结构体。 ivex是该节点所对应的顶点在vexs中的索引，而nextEdge是指向下一个节点的。</p><h4 id="3-1-创建图-用已提供的矩阵"><a href="#3-1-创建图-用已提供的矩阵" class="headerlink" title="3.1 创建图(用已提供的矩阵)"></a><strong>3.1 创建图(用已提供的矩阵)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 创建图(用已提供的矩阵)<br> *<br> * 参数说明：<br> *     vexs  -- 顶点数组<br> *     edges -- 边数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListUDG</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vexs, <span class="hljs-keyword">char</span>[][] edges)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span><br>    <span class="hljs-keyword">int</span> vlen = vexs.length;<br>    <span class="hljs-keyword">int</span> elen = edges.length;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> VNode[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        mVexs[i] = <span class="hljs-keyword">new</span> VNode();<br>        mVexs[i].data = vexs[i];<br>        mVexs[i].firstEdge = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">char</span> c1 = edges[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">char</span> c2 = edges[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i][<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 初始化node1</span><br>        ENode node1 = <span class="hljs-keyword">new</span> ENode();<br>        node1.ivex = p2;<br>        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p1].firstEdge = node1;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p1].firstEdge, node1);<br>        <span class="hljs-comment">// 初始化node2</span><br>        ENode node2 = <span class="hljs-keyword">new</span> ENode();<br>        node2.ivex = p1;<br>        <span class="hljs-comment">// 将node2链接到"p2所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p2].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p2].firstEdge = node2;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p2].firstEdge, node2);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是创建一个邻接表无向图。实际上，该方法创建的无向图，就是上面图G1。调用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] vexs = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;;<br><span class="hljs-keyword">char</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[][]&#123;<br>    &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>&#125;, <br>    &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'D'</span>&#125;, <br>    &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'F'</span>&#125;, <br>    &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>&#125;, <br>    &#123;<span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>&#125;, <br>    &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'G'</span>&#125;, <br>    &#123;<span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;&#125;;<br>ListUDG pG;<br><br>pG = <span class="hljs-keyword">new</span> ListUDG(vexs, edges);<br></code></pre></td></tr></table></figure><h4 id="3-2-创建图-自己输入"><a href="#3-2-创建图-自己输入" class="headerlink" title="3.2 创建图(自己输入)"></a><strong>3.2 创建图(自己输入)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 创建图(自己输入数据)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListUDG</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 输入"顶点数"和"边数"</span><br>    System.out.printf(<span class="hljs-string">"input vertex number: "</span>);<br>    <span class="hljs-keyword">int</span> vlen = readInt();<br>    System.out.printf(<span class="hljs-string">"input edge number: "</span>);<br>    <span class="hljs-keyword">int</span> elen = readInt();<br>    <span class="hljs-keyword">if</span> ( vlen &lt; <span class="hljs-number">1</span> || elen &lt; <span class="hljs-number">1</span> || (elen &gt; (vlen*(vlen - <span class="hljs-number">1</span>)))) &#123;<br>        System.out.printf(<span class="hljs-string">"input error: invalid parameters!\n"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> VNode[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        System.out.printf(<span class="hljs-string">"vertex(%d): "</span>, i);<br>        mVexs[i] = <span class="hljs-keyword">new</span> VNode();<br>        mVexs[i].data = readChar();<br>        mVexs[i].firstEdge = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    <span class="hljs-comment">//mMatrix = new int[vlen][vlen];</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        System.out.printf(<span class="hljs-string">"edge(%d):"</span>, i);<br>        <span class="hljs-keyword">char</span> c1 = readChar();<br>        <span class="hljs-keyword">char</span> c2 = readChar();<br>        <span class="hljs-keyword">int</span> p1 = getPosition(c1);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(c2);<br>        <span class="hljs-comment">// 初始化node1</span><br>        ENode node1 = <span class="hljs-keyword">new</span> ENode();<br>        node1.ivex = p2;<br>        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p1].firstEdge = node1;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p1].firstEdge, node1);<br>        <span class="hljs-comment">// 初始化node2</span><br>        ENode node2 = <span class="hljs-keyword">new</span> ENode();<br>        node2.ivex = p1;<br>        <span class="hljs-comment">// 将node2链接到"p2所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p2].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p2].firstEdge = node2;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p2].firstEdge, node2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-邻接表有向图"><a href="#4-邻接表有向图" class="headerlink" title="4. 邻接表有向图"></a><strong>4. 邻接表有向图</strong></h3><p><strong>基本定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListDG</span> </span>&#123;<br>    <span class="hljs-comment">// 邻接表中表对应的链表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ENode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ivex;       <span class="hljs-comment">// 该边所指向的顶点的位置</span><br>        ENode nextEdge; <span class="hljs-comment">// 指向下一条弧的指针</span><br>    &#125;<br><br>    <span class="hljs-comment">// 邻接表中表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VNode</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> data;          <span class="hljs-comment">// 顶点信息</span><br>        ENode firstEdge;    <span class="hljs-comment">// 指向第一条依附该顶点的弧</span><br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> VNode[] mVexs;  <span class="hljs-comment">// 顶点数组</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>(1)</strong> ListDG是邻接表对应的结构体。 mVexs则是保存顶点信息的一维数组。<br><strong>(2)</strong> VNode是邻接表顶点对应的结构体。 data是顶点所包含的数据，而firstEdge是该顶点所包含链表的表头指针。<br><strong>(3)</strong> ENode是邻接表顶点所包含的链表的节点对应的结构体。 ivex是该节点所对应的顶点在vexs中的索引，而nextEdge是指向下一个节点的。</p><h4 id="4-1-创建图-用已提供的矩阵"><a href="#4-1-创建图-用已提供的矩阵" class="headerlink" title="4.1 创建图(用已提供的矩阵)"></a><strong>4.1 创建图(用已提供的矩阵)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 创建图(用已提供的矩阵)<br> *<br> * 参数说明：<br> *     vexs  -- 顶点数组<br> *     edges -- 边数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListDG</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vexs, <span class="hljs-keyword">char</span>[][] edges)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span><br>    <span class="hljs-keyword">int</span> vlen = vexs.length;<br>    <span class="hljs-keyword">int</span> elen = edges.length;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> VNode[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        mVexs[i] = <span class="hljs-keyword">new</span> VNode();<br>        mVexs[i].data = vexs[i];<br>        mVexs[i].firstEdge = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">char</span> c1 = edges[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">char</span> c2 = edges[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i][<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-comment">// 初始化node1</span><br>        ENode node1 = <span class="hljs-keyword">new</span> ENode();<br>        node1.ivex = p2;<br>        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p1].firstEdge = node1;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p1].firstEdge, node1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是创建一个邻接表有向图。实际上，该方法创建的有向图，就是上面的图G2。该函数的调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] vexs = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;;<br>    <span class="hljs-keyword">char</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[][]&#123;<br>        &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>&#125;, <br>        &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>&#125;, <br>        &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'E'</span>&#125;, <br>        &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'F'</span>&#125;, <br>        &#123;<span class="hljs-string">'C'</span>, <span class="hljs-string">'E'</span>&#125;, <br>        &#123;<span class="hljs-string">'D'</span>, <span class="hljs-string">'C'</span>&#125;, <br>        &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'B'</span>&#125;, <br>        &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'D'</span>&#125;, <br>        &#123;<span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;&#125;; <br>    ListDG pG;<br><br>    pG = <span class="hljs-keyword">new</span> ListDG(vexs, edges);<br></code></pre></td></tr></table></figure><h4 id="4-2-创建图-自己输入"><a href="#4-2-创建图-自己输入" class="headerlink" title="4.2 创建图(自己输入)"></a><strong>4.2 创建图(自己输入)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 创建图(自己输入数据)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListDG</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 输入"顶点数"和"边数"</span><br>    System.out.printf(<span class="hljs-string">"input vertex number: "</span>);<br>    <span class="hljs-keyword">int</span> vlen = readInt();<br>    System.out.printf(<span class="hljs-string">"input edge number: "</span>);<br>    <span class="hljs-keyword">int</span> elen = readInt();<br>    <span class="hljs-keyword">if</span> ( vlen &lt; <span class="hljs-number">1</span> || elen &lt; <span class="hljs-number">1</span> || (elen &gt; (vlen*(vlen - <span class="hljs-number">1</span>)))) &#123;<br>        System.out.printf(<span class="hljs-string">"input error: invalid parameters!\n"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> VNode[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        System.out.printf(<span class="hljs-string">"vertex(%d): "</span>, i);<br>        mVexs[i] = <span class="hljs-keyword">new</span> VNode();<br>        mVexs[i].data = readChar();<br>        mVexs[i].firstEdge = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    <span class="hljs-comment">//mMatrix = new int[vlen][vlen];</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        System.out.printf(<span class="hljs-string">"edge(%d):"</span>, i);<br>        <span class="hljs-keyword">char</span> c1 = readChar();<br>        <span class="hljs-keyword">char</span> c2 = readChar();<br>        <span class="hljs-keyword">int</span> p1 = getPosition(c1);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(c2);<br>        <span class="hljs-comment">// 初始化node1</span><br>        ENode node1 = <span class="hljs-keyword">new</span> ENode();<br>        node1.ivex = p2;<br>        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p1].firstEdge = node1;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p1].firstEdge, node1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图-graph&quot;&gt;&lt;a href=&quot;#图-graph&quot; class=&quot;headerlink&quot; title=&quot;图(graph)&quot;&gt;&lt;/a&gt;图(graph)&lt;/h1&gt;&lt;h2 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
</feed>
